// Copyright (c) 2010-2014 SharpDX - Alexandre Mutel
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

//------------------------------------------------------------------------------
// <auto-generated>
//     Types declaration for SharpDX.Direct3D10 namespace.
//     This code was generated by a tool.
//     Date : 17.06.2016 1:24:45
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
namespace SharpDX.Direct3D10 {

// Disable warning : XML comment is not placed on a valid language element
#pragma warning disable 419
#pragma warning disable 1587
#pragma warning disable 1574
    /// <summary>	
    /// <p>This interface encapsulates methods for retrieving data from the GPU asynchronously.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>There are three types of asynchronous interfaces, all of which inherit this interface:</p><ul> <li> <strong><see cref="SharpDX.Direct3D10.Query"/> Interface</strong> - Queries information from the GPU.</li> <li> <strong><see cref="SharpDX.Direct3D10.Predicate"/> Interface</strong> - Determines whether a piece of geometry should be processed or not depending on the results of a previous draw call.</li> <li> <strong><see cref="SharpDX.Direct3D10.Counter"/> Interface</strong> - Measures GPU performance.</li> </ul>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Asynchronous']/*"/>	
    /// <msdn-id>bb173500</msdn-id>	
    /// <unmanaged>ID3D10Asynchronous</unmanaged>	
    /// <unmanaged-short>ID3D10Asynchronous</unmanaged-short>	
    [Guid("9B7E4C0D-342C-4106-A19F-4F2704F689F0")]
    public partial class Asynchronous : SharpDX.Direct3D10.DeviceChild {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.Asynchronous"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Asynchronous(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.Asynchronous"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.Asynchronous(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.Asynchronous(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Starts the collection of GPU data.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Calling Begin starts the asynchronous collection of GPU data. Calling <strong><see cref="SharpDX.Direct3D10.Asynchronous.End"/></strong> causes data collection to stop.   See <strong><see cref="SharpDX.Direct3D10.Asynchronous"/> Interface</strong> for additional information.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Asynchronous::Begin']/*"/>	
        /// <msdn-id>bb173501</msdn-id>	
        /// <unmanaged>void ID3D10Asynchronous::Begin()</unmanaged>	
        /// <unmanaged-short>ID3D10Asynchronous::Begin</unmanaged-short>	
        public void Begin() {
            unsafe {
                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer,((void**)(*(void**)_nativePointer))[7]);		
            }
        }
        
        /// <summary>	
        /// <p>Ends the collection of GPU data.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Calling <strong><see cref="SharpDX.Direct3D10.Asynchronous.Begin"/></strong> starts the asynchronous collection of GPU data. Calling <strong><see cref="SharpDX.Direct3D10.Asynchronous.End"/></strong> causes data  collection to stop. See <strong><see cref="SharpDX.Direct3D10.Asynchronous"/> Interface</strong> for additional information.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Asynchronous::End']/*"/>	
        /// <msdn-id>bb173502</msdn-id>	
        /// <unmanaged>void ID3D10Asynchronous::End()</unmanaged>	
        /// <unmanaged-short>ID3D10Asynchronous::End</unmanaged-short>	
        public void End() {
            unsafe {
                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer,((void**)(*(void**)_nativePointer))[8]);		
            }
        }
        
        /// <summary>	
        /// <p>Get data from the GPU asynchronously.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>Address of memory that will receive the data. If <strong><c>null</c></strong>, <strong>GetData</strong> will be used only to check status. The type of data output depends on the type of asynchronous interface. See Remarks.</p> </dd></param>	
        /// <param name="dataSize"><dd>  <p>Size of the data to retrieve or 0. This value can be obtained with <strong><see cref="SharpDX.Direct3D10.Asynchronous.GetDataSize"/></strong>. Must be 0 when <em>pData</em> is <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="getDataFlags"><dd>  <p>Optional flags. Can be 0 or any combination of the flags enumerated by <strong><see cref="SharpDX.Direct3D10.AsynchronousFlags"/></strong>.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. Otherwise, possible  return values are the following:</p><ul> <li>S_FALSE</li> <li><see cref="SharpDX.DXGI.ResultCode.DeviceRemoved"/></li> <li><see cref="SharpDX.DXGI.ResultCode.InvalidCall"/></li> </ul></returns>	
        /// <remarks>	
        /// <p><strong>GetData</strong> retrieves the data collected between calls to <strong><see cref="SharpDX.Direct3D10.Asynchronous.Begin"/></strong> and <strong><see cref="SharpDX.Direct3D10.Asynchronous.End"/></strong>.  Certain queries only require a call to <strong><see cref="SharpDX.Direct3D10.Asynchronous.End"/></strong> in which case the data returned by <strong>GetData</strong> is accurate up to the last call to <strong><see cref="SharpDX.Direct3D10.Asynchronous.End"/></strong> (See <strong><see cref="SharpDX.Direct3D10.Query"/> Interface</strong>).</p><p>If <em>DataSize</em> is 0, <strong>GetData</strong> is only used to check status where a return value of <see cref="SharpDX.Result.Ok"/> indicates that data is available to give to an application, and a return value of S_FALSE indicates data is not yet available.</p><p>It is invalid to invoke this function on a predicate created with the flag D3D10_QUERY_MISCFLAG_PREDICATEHINT.</p><p>If the asynchronous interface that calls this function is <strong><see cref="SharpDX.Direct3D10.Query"/> Interface</strong>, then the following table applies.</p><table> <tr><th>Query Type</th><th>Output Data Type</th><th>Supports Begin Method</th></tr> <tr><td><see cref="SharpDX.Direct3D10.QueryType.Event"/></td><td><see cref="SharpDX.Mathematics.Interop.RawBool"/></td><td>NO</td></tr> <tr><td><see cref="SharpDX.Direct3D10.QueryType.Occlusion"/></td><td>UINT64</td><td>YES</td></tr> <tr><td><see cref="SharpDX.Direct3D10.QueryType.Timestamp"/></td><td>UINT64</td><td>NO</td></tr> <tr><td><see cref="SharpDX.Direct3D10.QueryType.TimestampDisjoint"/></td><td><see cref="SharpDX.Direct3D10.QueryDataTimestampDisjoint"/></td><td>YES</td></tr> <tr><td><see cref="SharpDX.Direct3D10.QueryType.PipelineStatistics"/></td><td><see cref="SharpDX.Direct3D10.QueryDataPipelineStatistics"/></td><td>YES</td></tr> <tr><td><see cref="SharpDX.Direct3D10.QueryType.OcclusionPredicate"/></td><td><see cref="SharpDX.Mathematics.Interop.RawBool"/></td><td>YES</td></tr> <tr><td><see cref="SharpDX.Direct3D10.QueryType.StreamOutputStatistics"/></td><td><see cref="SharpDX.Direct3D10.StreamOutputStatistics"/></td><td>YES</td></tr> <tr><td><see cref="SharpDX.Direct3D10.QueryType.StreamOutputOverflowPredicate"/></td><td><see cref="SharpDX.Mathematics.Interop.RawBool"/></td><td>YES</td></tr> </table><p>?</p><p>If the asynchronous interface that calls this API is <strong><see cref="SharpDX.Direct3D10.Counter"/> Interface</strong>, then the following applies.</p><table> <tr><th>Counter Type</th><th>Output Data Type</th><th>Units</th></tr> <tr><td><see cref="SharpDX.Direct3D10.CounterKind.GpuIdle"/></td><td>FLOAT32</td><td>fraction of time</td></tr> <tr><td><see cref="SharpDX.Direct3D10.CounterKind.VertexProcessing"/></td><td>FLOAT32</td><td>fraction of time</td></tr> <tr><td><see cref="SharpDX.Direct3D10.CounterKind.GeometryProcessing"/></td><td>FLOAT32</td><td>fraction of time</td></tr> <tr><td><see cref="SharpDX.Direct3D10.CounterKind.PixelProcessing"/></td><td>FLOAT32</td><td>fraction of time</td></tr> <tr><td><see cref="SharpDX.Direct3D10.CounterKind.OtherGpuProcessing"/></td><td>FLOAT32</td><td>fraction of time</td></tr> <tr><td><see cref="SharpDX.Direct3D10.CounterKind.HostAdapterBandwidthUtilization"/></td><td>FLOAT32</td><td>fraction of theoretical maximum</td></tr> <tr><td><see cref="SharpDX.Direct3D10.CounterKind.LocalVidmemBandwidthUtilization"/></td><td>FLOAT32</td><td>fraction of theoretical maximum</td></tr> <tr><td><see cref="SharpDX.Direct3D10.CounterKind.VertexThroughputUtilization"/></td><td>FLOAT32</td><td>fraction of theoretical maximum</td></tr> <tr><td><see cref="SharpDX.Direct3D10.CounterKind.TriangleSetupThroughputUtilization"/></td><td>FLOAT32</td><td>fraction of theoretical maximum</td></tr> <tr><td><see cref="SharpDX.Direct3D10.CounterKind.FillrateThroughputUtilization"/></td><td>FLOAT32</td><td>fraction of theoretical maximum</td></tr> <tr><td><see cref="SharpDX.Direct3D10.CounterKind.VertexShaderMemoryLimited"/></td><td>FLOAT32</td><td>fraction of time</td></tr> <tr><td><see cref="SharpDX.Direct3D10.CounterKind.VertexShaderComputationLimited"/></td><td>FLOAT32</td><td>fraction of time</td></tr> <tr><td><see cref="SharpDX.Direct3D10.CounterKind.GeometryShaderMemoryLimited"/></td><td>FLOAT32</td><td>fraction of time</td></tr> <tr><td><see cref="SharpDX.Direct3D10.CounterKind.GeometryShaderComputationLimited"/></td><td>FLOAT32</td><td>fraction of time</td></tr> <tr><td><see cref="SharpDX.Direct3D10.CounterKind.PixelShaderMemoryLimited"/></td><td>FLOAT32</td><td>fraction of time</td></tr> <tr><td><see cref="SharpDX.Direct3D10.CounterKind.PixelShaderComputationLimited"/></td><td>FLOAT32</td><td>fraction of time</td></tr> <tr><td><see cref="SharpDX.Direct3D10.CounterKind.PostTransformCacheHitRate"/></td><td>FLOAT32</td><td>fraction</td></tr> <tr><td><see cref="SharpDX.Direct3D10.CounterKind.TextureCacheHitRate"/></td><td>FLOAT32</td><td>fraction</td></tr> </table><p>?</p><p>The value returned by a <see cref="SharpDX.Direct3D10.CounterKind.GpuIdle"/>, <see cref="SharpDX.Direct3D10.CounterKind.VertexProcessing"/>, <see cref="SharpDX.Direct3D10.CounterKind.GeometryProcessing"/>, <see cref="SharpDX.Direct3D10.CounterKind.PixelProcessing"/>, or <see cref="SharpDX.Direct3D10.CounterKind.OtherGpuProcessing"/> counter may be different depending on the number of parallel counters that exist on a video card, and those values can be interpreted with the following equation:</p><p></p><p>The number of parallel counters that a video card has is available from <strong>NumDetectableParallelUnits</strong> in <strong><see cref="SharpDX.Direct3D10.CounterCapabilities"/></strong>, and it can be retrieved by calling <strong><see cref="SharpDX.Direct3D10.Device.GetCounterCapabilities"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Asynchronous::GetData']/*"/>	
        /// <msdn-id>bb173503</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Asynchronous::GetData([Out, Buffer, Optional] void* pData,[In] unsigned int DataSize,[In] unsigned int GetDataFlags)</unmanaged>	
        /// <unmanaged-short>ID3D10Asynchronous::GetData</unmanaged-short>	
        internal SharpDX.Result GetData(System.IntPtr dataRef, int dataSize, int getDataFlags) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)dataRef, dataSize, getDataFlags,((void**)(*(void**)_nativePointer))[9]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get the size of the data (in bytes) that is output when calling <strong><see cref="SharpDX.Direct3D10.Asynchronous.GetData"/></strong>.</p>	
        /// </summary>	
        /// <returns><p>Size of the data (in bytes) that is output when calling GetData.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Asynchronous::GetDataSize']/*"/>	
        /// <msdn-id>bb173504</msdn-id>	
        /// <unmanaged>unsigned int ID3D10Asynchronous::GetDataSize()</unmanaged>	
        /// <unmanaged-short>ID3D10Asynchronous::GetDataSize</unmanaged-short>	
        internal int GetDataSize() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[10]);		
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>This blend-state interface accesses blending state for a Direct3D 10.0 device for the output-merger stage.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Blending combines two pixel values. You have control over how the pixels are blended by using a predefined set of blending operations, as well as preblending operations. The Blending Block Diagram shows conceptually how blending works.</p><p>To create a blend-state interface, call <strong><see cref="SharpDX.Direct3D10.Device.CreateBlendState"/></strong>. To initialize the blend state, call <strong><see cref="SharpDX.Direct3D10.OutputMergerStage.SetBlendState"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10BlendState']/*"/>	
    /// <msdn-id>bb173505</msdn-id>	
    /// <unmanaged>ID3D10BlendState</unmanaged>	
    /// <unmanaged-short>ID3D10BlendState</unmanaged-short>	
    [Guid("EDAD8D19-8A35-4d6d-8566-2EA276CDE161")]
    public partial class BlendState : SharpDX.Direct3D10.DeviceChild {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.BlendState"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BlendState(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.BlendState"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.BlendState(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.BlendState(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Get the blend state.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10BlendState::GetDesc']/*"/>	
        /// <msdn-id>bb173506</msdn-id>	
        /// <unmanaged>GetDesc</unmanaged>	
        /// <unmanaged-short>GetDesc</unmanaged-short>	
        /// <unmanaged>void ID3D10BlendState::GetDesc([Out] D3D10_BLEND_DESC* pDesc)</unmanaged>
        public SharpDX.Direct3D10.BlendStateDescription Description {
                get { SharpDX.Direct3D10.BlendStateDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Get the blend state.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p>A reference to the blend state (see <strong><see cref="SharpDX.Direct3D10.BlendStateDescription"/></strong>).</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10BlendState::GetDesc']/*"/>	
        /// <msdn-id>bb173506</msdn-id>	
        /// <unmanaged>void ID3D10BlendState::GetDesc([Out] D3D10_BLEND_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3D10BlendState::GetDesc</unmanaged-short>	
        internal void GetDescription(out SharpDX.Direct3D10.BlendStateDescription descRef) {
            unsafe {
                var descRef_ = new SharpDX.Direct3D10.BlendStateDescription.__Native();
                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, &descRef_,((void**)(*(void**)_nativePointer))[7]);		
                descRef = new SharpDX.Direct3D10.BlendStateDescription();
                descRef.__MarshalFrom(ref descRef_);
            }
        }
    }
    /// <summary>	
    /// <p>This blend-state interface accesses blending state for a Direct3D 10.1 device for the output-merger stage.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Blending combines two pixel values. You have control over how the pixels are blended by using a predefined set of blending operations, as well as preblending operations. The Blending Block Diagram shows conceptually how blending works.</p><p>To create a blend-state interface, call <strong><see cref="SharpDX.Direct3D10.Device1.CreateBlendState1"/></strong>. To initialize the blend state, call <strong><see cref="SharpDX.Direct3D10.OutputMergerStage.SetBlendState"/></strong>.</p><p>This method requires Windows Vista Service Pack 1.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10BlendState1']/*"/>	
    /// <msdn-id>bb694544</msdn-id>	
    /// <unmanaged>ID3D10BlendState1</unmanaged>	
    /// <unmanaged-short>ID3D10BlendState1</unmanaged-short>	
    [Guid("EDAD8D99-8A35-4d6d-8566-2EA276CDE161")]
    public partial class BlendState1 : SharpDX.Direct3D10.BlendState {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.BlendState1"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public BlendState1(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.BlendState1"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.BlendState1(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.BlendState1(nativePointer);
		}
        
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10BlendState1::GetDesc1']/*"/>	
        /// <unmanaged>GetDesc1</unmanaged>	
        /// <unmanaged-short>GetDesc1</unmanaged-short>	
        /// <unmanaged>void ID3D10BlendState1::GetDesc1([Out] D3D10_BLEND_DESC1* pDesc)</unmanaged>
        public SharpDX.Direct3D10.BlendStateDescription1 Description1 {
                get { SharpDX.Direct3D10.BlendStateDescription1 __output__; GetDescription1(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="descRef">No documentation.</param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10BlendState1::GetDesc1']/*"/>	
        /// <unmanaged>void ID3D10BlendState1::GetDesc1([Out] D3D10_BLEND_DESC1* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3D10BlendState1::GetDesc1</unmanaged-short>	
        internal void GetDescription1(out SharpDX.Direct3D10.BlendStateDescription1 descRef) {
            unsafe {
                var descRef_ = new SharpDX.Direct3D10.BlendStateDescription1.__Native();
                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, &descRef_,((void**)(*(void**)_nativePointer))[8]);		
                descRef = new SharpDX.Direct3D10.BlendStateDescription1();
                descRef.__MarshalFrom(ref descRef_);
            }
        }
    }
    /// <summary>	
    /// <p>A buffer interface accesses a buffer resource, which is unstructured memory. Buffers typically store vertex or index data.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Three types of buffers can be created; vertex, index, and shader-constant buffers. To create a buffer resource, call <strong><see cref="SharpDX.Direct3D10.Device.CreateBuffer"/></strong>.</p><p>A buffer must be bound to the pipeline before it can be accessed. Buffers can be bound to the input-assembler stage by calls to <strong><see cref="SharpDX.Direct3D10.InputAssemblerStage.SetVertexBuffers"/></strong> and <strong><see cref="SharpDX.Direct3D10.InputAssemblerStage.SetIndexBuffer"/></strong>, and to the stream-output stage by a call to <strong><see cref="SharpDX.Direct3D10.StreamOutputStage.SetTargets"/></strong>.</p><p>Buffers can be bound to multiple pipeline stages simultaneously for reading. A buffer can also be bound to a single pipeline stage for writing; however, the same buffer cannot be bound for reading and writing simultaneously. For more information, see binding resources.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Buffer']/*"/>	
    /// <msdn-id>bb173510</msdn-id>	
    /// <unmanaged>ID3D10Buffer</unmanaged>	
    /// <unmanaged-short>ID3D10Buffer</unmanaged-short>	
    [Guid("9B7E4C02-342C-4106-A19F-4F2704F689F0")]
    public partial class Buffer : SharpDX.Direct3D10.Resource {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.Buffer"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Buffer(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.Buffer"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.Buffer(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.Buffer(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Get the properties of a buffer resource.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Buffer::GetDesc']/*"/>	
        /// <msdn-id>bb173511</msdn-id>	
        /// <unmanaged>GetDesc</unmanaged>	
        /// <unmanaged-short>GetDesc</unmanaged-short>	
        /// <unmanaged>void ID3D10Buffer::GetDesc([Out] D3D10_BUFFER_DESC* pDesc)</unmanaged>
        public SharpDX.Direct3D10.BufferDescription Description {
                get { SharpDX.Direct3D10.BufferDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Get a reference to the data contained in the resource and deny GPU access to the resource.</p>	
        /// </summary>	
        /// <param name="mapType"><dd>  <p>Flag that specifies the CPU's permissions for the reading and writing of a resource. For possible values, see <strong><see cref="SharpDX.Direct3D10.MapMode"/></strong>.</p> </dd></param>	
        /// <param name="mapFlags"><dd>  <p>Flag that specifies what the CPU should do when the GPU is busy (see <strong><see cref="SharpDX.Direct3D10.MapFlags"/></strong>). This flag is optional.</p> </dd></param>	
        /// <param name="dataOut"><dd>  <p>Pointer to the buffer resource data.</p> </dd></param>	
        /// <returns><p>If this function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. The following list contains some of the reasons that <strong>Map</strong> can fail: </p><ul> <li>If <em>MapFlags</em> specifies <see cref="SharpDX.Direct3D10.MapFlags.DoNotWait"/> and the GPU is not yet finished with the resource, <strong><see cref="SharpDX.Direct3D10.Buffer.Map"/></strong> returns <see cref="SharpDX.DXGI.ResultCode.WasStillDrawing"/>.</li> <li><strong><see cref="SharpDX.Direct3D10.Buffer.Map"/></strong> returns <see cref="SharpDX.DXGI.ResultCode.DeviceRemoved"/> if <em>MapType</em> includes any flags that permit reading and the hardware  device (that is, the video card) has been removed.</li> </ul><p>For more information about the preceding return values, see DXGI_ERROR.</p></returns>	
        /// <remarks>	
        /// <p>For the CPU to write the contents of a resource, the resource must be created with the dynamic usage flag, <see cref="SharpDX.Direct3D10.ResourceUsage.Dynamic"/>.  To both read and write those contents, the resource must be created with the staging usage flag, <see cref="SharpDX.Direct3D10.ResourceUsage.Staging"/>. (For more information about  these flags, see <strong><see cref="SharpDX.Direct3D10.ResourceUsage"/></strong>.) <strong><see cref="SharpDX.Direct3D10.Buffer.Map"/></strong> will retrieve a reference to the resource data.  For a discussion on how to access resources efficiently, see Copying and Accessing Resource Data (Direct3D 10).</p><p>Call <strong><see cref="SharpDX.Direct3D10.Buffer.Unmap"/></strong> to signify that the application has finished accessing the resource.</p><p><strong><see cref="SharpDX.Direct3D10.Buffer.Map"/></strong> has a few other restrictions. For example:</p><ul> <li>The same buffer cannot be mapped multiple times; in other words, do not call <strong><see cref="SharpDX.Direct3D10.Buffer.Map"/></strong> on a buffer that is already mapped.</li> <li>Any buffer that is bound to the pipeline must be unmapped before any rendering operation (that is, <strong><see cref="SharpDX.Direct3D10.Device.Draw"/></strong>)  can be executed.</li> </ul><table> <tr><td> <p>Differences between Direct3D 9 and Direct3D 10:</p> <p><strong><see cref="SharpDX.Direct3D10.Buffer.Map"/></strong> in Direct3D 10 is analogous to resource Lock in Direct3D 9.</p> </td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Buffer::Map']/*"/>	
        /// <msdn-id>bb173512</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Buffer::Map([In] D3D10_MAP MapType,[In] D3D10_MAP_FLAG MapFlags,[Out] void** ppData)</unmanaged>	
        /// <unmanaged-short>ID3D10Buffer::Map</unmanaged-short>	
        internal void Map(SharpDX.Direct3D10.MapMode mapType, SharpDX.Direct3D10.MapFlags mapFlags, out System.IntPtr dataOut) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dataOut_ = &dataOut)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, unchecked((int)mapType), unchecked((int)mapFlags), dataOut_,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Invalidate the reference to the resource retrieved by <strong><see cref="SharpDX.Direct3D10.Buffer.Map"/></strong> and reenable GPU access to the resource.</p>	
        /// </summary>	
        /// <remarks>	
        /// <table> <tr><td> <p>Differences between Direct3D 9 and Direct3D 10:</p> <p>Unmap() in Direct3D 10 is analogous to resource Unlock() in Direct3D 9.</p> </td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Buffer::Unmap']/*"/>	
        /// <msdn-id>bb173513</msdn-id>	
        /// <unmanaged>void ID3D10Buffer::Unmap()</unmanaged>	
        /// <unmanaged-short>ID3D10Buffer::Unmap</unmanaged-short>	
        public void Unmap() {
            unsafe {
                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer,((void**)(*(void**)_nativePointer))[11]);		
            }
        }
        
        /// <summary>	
        /// <p>Get the properties of a buffer resource.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p>Pointer to a resource description (see <strong><see cref="SharpDX.Direct3D10.BufferDescription"/></strong>) filled in by the method. This reference cannot be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Buffer::GetDesc']/*"/>	
        /// <msdn-id>bb173511</msdn-id>	
        /// <unmanaged>void ID3D10Buffer::GetDesc([Out] D3D10_BUFFER_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3D10Buffer::GetDesc</unmanaged-short>	
        internal void GetDescription(out SharpDX.Direct3D10.BufferDescription descRef) {
            unsafe {
                descRef = new SharpDX.Direct3D10.BufferDescription();
                fixed (void* descRef_ = &descRef)
                    SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, descRef_,((void**)(*(void**)_nativePointer))[12]);		
            }
        }
    }
    /// <summary>	
    /// <p>This interface encapsulates methods for measuring GPU performance.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A counter can be created with <strong><see cref="SharpDX.Direct3D10.Device.CreateCounter"/></strong>.</p><p>This is a derived class of <strong><see cref="SharpDX.Direct3D10.Asynchronous"/> Interface</strong>.</p><p>Counter data is gathered by issuing an <strong><see cref="SharpDX.Direct3D10.Asynchronous.Begin"/></strong> command, issuing some graphics commands, issuing an <strong><see cref="SharpDX.Direct3D10.Asynchronous.End"/></strong> command, and then calling <strong><see cref="SharpDX.Direct3D10.Asynchronous.GetData"/></strong> to get data about what happened in between the Begin and End calls. The data returned by GetData will be different depending on the type of counter. The call to End causes the data returned by GetData to be accurate up until the last call to End.</p><p>Counters are best suited for profiling.</p><p>For a list of the types of performance counters, see <strong><see cref="SharpDX.Direct3D10.CounterKind"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Counter']/*"/>	
    /// <msdn-id>bb173514</msdn-id>	
    /// <unmanaged>ID3D10Counter</unmanaged>	
    /// <unmanaged-short>ID3D10Counter</unmanaged-short>	
    [Guid("9B7E4C11-342C-4106-A19F-4F2704F689F0")]
    public partial class Counter : SharpDX.Direct3D10.Asynchronous {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.Counter"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Counter(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.Counter"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.Counter(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.Counter(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Get a counter description.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Counter::GetDesc']/*"/>	
        /// <msdn-id>bb173515</msdn-id>	
        /// <unmanaged>GetDesc</unmanaged>	
        /// <unmanaged-short>GetDesc</unmanaged-short>	
        /// <unmanaged>void ID3D10Counter::GetDesc([Out] D3D10_COUNTER_DESC* pDesc)</unmanaged>
        public SharpDX.Direct3D10.CounterDescription Description {
                get { SharpDX.Direct3D10.CounterDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Get a counter description.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p>Pointer to a counter description (see <strong><see cref="SharpDX.Direct3D10.CounterDescription"/></strong>).</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Counter::GetDesc']/*"/>	
        /// <msdn-id>bb173515</msdn-id>	
        /// <unmanaged>void ID3D10Counter::GetDesc([Out] D3D10_COUNTER_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3D10Counter::GetDesc</unmanaged-short>	
        internal void GetDescription(out SharpDX.Direct3D10.CounterDescription descRef) {
            unsafe {
                descRef = new SharpDX.Direct3D10.CounterDescription();
                fixed (void* descRef_ = &descRef)
                    SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, descRef_,((void**)(*(void**)_nativePointer))[11]);		
            }
        }
    }
    /// <summary>	
    /// <p>A depth-stencil-state interface accesses depth-stencil state which sets up the depth-stencil test for the output-merger stage.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Create a depth-stencil state object by calling <strong><see cref="SharpDX.Direct3D10.Device.CreateDepthStencilState"/></strong>.</p><p>To initialize depth-stencil state, bind the depth-stencil-state object to the pipeline by calling <strong><see cref="SharpDX.Direct3D10.OutputMergerStage.SetDepthStencilState"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10DepthStencilState']/*"/>	
    /// <msdn-id>bb173524</msdn-id>	
    /// <unmanaged>ID3D10DepthStencilState</unmanaged>	
    /// <unmanaged-short>ID3D10DepthStencilState</unmanaged-short>	
    [Guid("2B4B1CC8-A4AD-41f8-8322-CA86FC3EC675")]
    public partial class DepthStencilState : SharpDX.Direct3D10.DeviceChild {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.DepthStencilState"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DepthStencilState(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.DepthStencilState"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.DepthStencilState(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.DepthStencilState(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Get the depth-stencil state.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10DepthStencilState::GetDesc']/*"/>	
        /// <msdn-id>bb173525</msdn-id>	
        /// <unmanaged>GetDesc</unmanaged>	
        /// <unmanaged-short>GetDesc</unmanaged-short>	
        /// <unmanaged>void ID3D10DepthStencilState::GetDesc([Out] D3D10_DEPTH_STENCIL_DESC* pDesc)</unmanaged>
        public SharpDX.Direct3D10.DepthStencilStateDescription Description {
                get { SharpDX.Direct3D10.DepthStencilStateDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Get the depth-stencil state.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p>A reference to the depth-stencil state (see <strong><see cref="SharpDX.Direct3D10.DepthStencilStateDescription"/></strong>).</p> </dd></param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10DepthStencilState::GetDesc']/*"/>	
        /// <msdn-id>bb173525</msdn-id>	
        /// <unmanaged>void ID3D10DepthStencilState::GetDesc([Out] D3D10_DEPTH_STENCIL_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3D10DepthStencilState::GetDesc</unmanaged-short>	
        internal void GetDescription(out SharpDX.Direct3D10.DepthStencilStateDescription descRef) {
            unsafe {
                descRef = new SharpDX.Direct3D10.DepthStencilStateDescription();
                fixed (void* descRef_ = &descRef)
                    SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, descRef_,((void**)(*(void**)_nativePointer))[7]);		
            }
        }
    }
    /// <summary>	
    /// <p>A depth-stencil-view interface accesses a texture resource during  depth-stencil testing.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To create a depth-stencil view, call <strong><see cref="SharpDX.Direct3D10.Device.CreateDepthStencilView"/></strong>.</p><p>To bind a depth-stencil view to the pipeline, call <strong><see cref="SharpDX.Direct3D10.OutputMergerStage.SetRenderTargets"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10DepthStencilView']/*"/>	
    /// <msdn-id>bb173526</msdn-id>	
    /// <unmanaged>ID3D10DepthStencilView</unmanaged>	
    /// <unmanaged-short>ID3D10DepthStencilView</unmanaged-short>	
    [Guid("9B7E4C09-342C-4106-A19F-4F2704F689F0")]
    public partial class DepthStencilView : SharpDX.Direct3D10.ResourceView {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.DepthStencilView"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DepthStencilView(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.DepthStencilView"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.DepthStencilView(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.DepthStencilView(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Get the depth-stencil view.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10DepthStencilView::GetDesc']/*"/>	
        /// <msdn-id>bb173527</msdn-id>	
        /// <unmanaged>GetDesc</unmanaged>	
        /// <unmanaged-short>GetDesc</unmanaged-short>	
        /// <unmanaged>void ID3D10DepthStencilView::GetDesc([Out] D3D10_DEPTH_STENCIL_VIEW_DESC* pDesc)</unmanaged>
        public SharpDX.Direct3D10.DepthStencilViewDescription Description {
                get { SharpDX.Direct3D10.DepthStencilViewDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Get the depth-stencil view.</p>	
        /// </summary>	
        /// <param name="descRef">No documentation.</param>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10DepthStencilView::GetDesc']/*"/>	
        /// <msdn-id>bb173527</msdn-id>	
        /// <unmanaged>void ID3D10DepthStencilView::GetDesc([Out] D3D10_DEPTH_STENCIL_VIEW_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3D10DepthStencilView::GetDesc</unmanaged-short>	
        internal void GetDescription(out SharpDX.Direct3D10.DepthStencilViewDescription descRef) {
            unsafe {
                descRef = new SharpDX.Direct3D10.DepthStencilViewDescription();
                fixed (void* descRef_ = &descRef)
                    SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, descRef_,((void**)(*(void**)_nativePointer))[8]);		
            }
        }
    }
    /// <summary>	
    /// <p>The device interface represents a virtual adapter for Direct3D 10.0; it is used to perform rendering and create Direct3D resources.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A device is created using <strong><see cref="SharpDX.Direct3D10.D3D10.CreateDevice"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device']/*"/>	
    /// <msdn-id>bb173528</msdn-id>	
    /// <unmanaged>ID3D10Device</unmanaged>	
    /// <unmanaged-short>ID3D10Device</unmanaged-short>	
    [Guid("9B7E4C0F-342C-4106-A19F-4F2704F689F0")]
    public partial class Device : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.Device"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Device(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.Device"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.Device(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.Device(nativePointer);
		}
        
				
        /// <summary>Update nested inner interfaces pointer</summary>
        protected override void NativePointerUpdated(IntPtr oldPointer)
        {            
            base.NativePointerUpdated(oldPointer);
            if (VertexShader == null) 
                VertexShader = new SharpDX.Direct3D10.VertexShaderStage(IntPtr.Zero);
            VertexShader.NativePointer = NativePointer;
            if (PixelShader == null) 
                PixelShader = new SharpDX.Direct3D10.PixelShaderStage(IntPtr.Zero);
            PixelShader.NativePointer = NativePointer;
            if (InputAssembler == null) 
                InputAssembler = new SharpDX.Direct3D10.InputAssemblerStage(IntPtr.Zero);
            InputAssembler.NativePointer = NativePointer;
            if (GeometryShader == null) 
                GeometryShader = new SharpDX.Direct3D10.GeometryShaderStage(IntPtr.Zero);
            GeometryShader.NativePointer = NativePointer;
            if (OutputMerger == null) 
                OutputMerger = new SharpDX.Direct3D10.OutputMergerStage(IntPtr.Zero);
            OutputMerger.NativePointer = NativePointer;
            if (StreamOutput == null) 
                StreamOutput = new SharpDX.Direct3D10.StreamOutputStage(IntPtr.Zero);
            StreamOutput.NativePointer = NativePointer;
            if (Rasterizer == null) 
                Rasterizer = new SharpDX.Direct3D10.RasterizerStage(IntPtr.Zero);
            Rasterizer.NativePointer = NativePointer;
        }
      
		/// <summary>Inner interface giving access to VertexShaderStage methods. </summary>
        public VertexShaderStage VertexShader { get; private set; }		
      
		/// <summary>Inner interface giving access to PixelShaderStage methods. </summary>
        public PixelShaderStage PixelShader { get; private set; }		
      
		/// <summary>Inner interface giving access to InputAssemblerStage methods. </summary>
        public InputAssemblerStage InputAssembler { get; private set; }		
      
		/// <summary>Inner interface giving access to GeometryShaderStage methods. </summary>
        public GeometryShaderStage GeometryShader { get; private set; }		
      
		/// <summary>Inner interface giving access to OutputMergerStage methods. </summary>
        public OutputMergerStage OutputMerger { get; private set; }		
      
		/// <summary>Inner interface giving access to StreamOutputStage methods. </summary>
        public StreamOutputStage StreamOutput { get; private set; }		
      
		/// <summary>Inner interface giving access to RasterizerStage methods. </summary>
        public RasterizerStage Rasterizer { get; private set; }		
        
        /// <summary>	
        /// <p>Get the reason why the device was removed.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::GetDeviceRemovedReason']/*"/>	
        /// <msdn-id>bb173571</msdn-id>	
        /// <unmanaged>GetDeviceRemovedReason</unmanaged>	
        /// <unmanaged-short>GetDeviceRemovedReason</unmanaged-short>	
        /// <unmanaged>HRESULT ID3D10Device::GetDeviceRemovedReason()</unmanaged>
        public SharpDX.Result DeviceRemovedReason {
                get { return GetDeviceRemovedReason(); }
        }
        
        /// <summary>	
        /// <p>Get or sets the exception-mode flags.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>An exception-mode flag is used to elevate an error condition to a non-continuable exception. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::GetExceptionMode']/*"/>	
        /// <msdn-id>bb173572</msdn-id>	
        /// <unmanaged>GetExceptionMode / SetExceptionMode</unmanaged>	
        /// <unmanaged-short>GetExceptionMode</unmanaged-short>	
        /// <unmanaged>unsigned int ID3D10Device::GetExceptionMode()</unmanaged>
        public int ExceptionMode {
                get { return GetExceptionMode(); }
                set { SetExceptionMode(value); }
        }
        
        /// <summary>	
        /// <p>Draw indexed, non-instanced primitives.</p>	
        /// </summary>	
        /// <param name="indexCount"><dd>  <p>Number of indices to draw.</p> </dd></param>	
        /// <param name="startIndexLocation"><dd>  <p>Index of the first index to use when accesssing the vertex buffer; begin at <em>StartIndexLocation</em> to index vertices from the vertex buffer.</p> </dd></param>	
        /// <param name="baseVertexLocation"><dd>  <p>Offset from the start of the vertex buffer to the first vertex.</p> </dd></param>	
        /// <remarks>	
        /// <p>A draw API submits work to the rendering pipeline.</p><p>If the sum of both indices is negative, the result of the function call is undefined.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::DrawIndexed']/*"/>	
        /// <msdn-id>bb173565</msdn-id>	
        /// <unmanaged>void ID3D10Device::DrawIndexed([In] unsigned int IndexCount,[In] unsigned int StartIndexLocation,[In] int BaseVertexLocation)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::DrawIndexed</unmanaged-short>	
        public void DrawIndexed(int indexCount, int startIndexLocation, int baseVertexLocation) {
            unsafe {
                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, indexCount, startIndexLocation, baseVertexLocation,((void**)(*(void**)_nativePointer))[8]);		
            }
        }
        
        /// <summary>	
        /// <p>Draw non-indexed, non-instanced primitives.</p>	
        /// </summary>	
        /// <param name="vertexCount"><dd>  <p>Number of vertices to draw.</p> </dd></param>	
        /// <param name="startVertexLocation"><dd>  <p>Index of the first vertex, which is usually an offset in a vertex buffer; it could also be used as the first vertex id generated for a shader parameter marked with the <strong>SV_TargetId</strong>?system-value semantic.</p> </dd></param>	
        /// <remarks>	
        /// <p>A draw API submits work to the rendering pipeline.</p><p>The vertex data for a draw call normally comes from a vertex buffer that is bound to the pipeline. However, you could also provide the vertex data from a shader that has vertex data marked with the <strong>SV_VertexId</strong>?system-value semantic.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::Draw']/*"/>	
        /// <msdn-id>bb173563</msdn-id>	
        /// <unmanaged>void ID3D10Device::Draw([In] unsigned int VertexCount,[In] unsigned int StartVertexLocation)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::Draw</unmanaged-short>	
        public void Draw(int vertexCount, int startVertexLocation) {
            unsafe {
                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, vertexCount, startVertexLocation,((void**)(*(void**)_nativePointer))[9]);		
            }
        }
        
        /// <summary>	
        /// <p>Draw indexed, instanced primitives.</p>	
        /// </summary>	
        /// <param name="indexCountPerInstance"><dd>  <p>Size of the index buffer used in each instance.</p> </dd></param>	
        /// <param name="instanceCount"><dd>  <p>Number of instances to draw.</p> </dd></param>	
        /// <param name="startIndexLocation"><dd>  <p>Index of the first index.</p> </dd></param>	
        /// <param name="baseVertexLocation"><dd>  <p>Index of the first vertex. The index is signed, which allows a negative index. If the negative index plus the index value from the index buffer are less than 0, the result is undefined.</p> </dd></param>	
        /// <param name="startInstanceLocation"><dd>  <p>Index of the first instance.</p> </dd></param>	
        /// <remarks>	
        /// <p>A draw API submits work to the rendering pipeline.</p><p>Instancing may extend performance by reusing the same geometry to draw multiple objects in a scene. One example of instancing could be to draw the same object with different positions and colors. Indexing requires multiple vertex buffers: at least one for per-vertex data and a second buffer for per-instance data. For an example of instancing, see the Instancing10 Sample.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::DrawIndexedInstanced']/*"/>	
        /// <msdn-id>bb173566</msdn-id>	
        /// <unmanaged>void ID3D10Device::DrawIndexedInstanced([In] unsigned int IndexCountPerInstance,[In] unsigned int InstanceCount,[In] unsigned int StartIndexLocation,[In] int BaseVertexLocation,[In] unsigned int StartInstanceLocation)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::DrawIndexedInstanced</unmanaged-short>	
        public void DrawIndexedInstanced(int indexCountPerInstance, int instanceCount, int startIndexLocation, int baseVertexLocation, int startInstanceLocation) {
            unsafe {
                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, indexCountPerInstance, instanceCount, startIndexLocation, baseVertexLocation, startInstanceLocation,((void**)(*(void**)_nativePointer))[14]);		
            }
        }
        
        /// <summary>	
        /// <p>Draw non-indexed, instanced primitives.</p>	
        /// </summary>	
        /// <param name="vertexCountPerInstance"><dd>  <p>Number of vertices to draw.</p> </dd></param>	
        /// <param name="instanceCount"><dd>  <p>Number of instances to draw.</p> </dd></param>	
        /// <param name="startVertexLocation"><dd>  <p>Index of the first vertex.</p> </dd></param>	
        /// <param name="startInstanceLocation"><dd>  <p>Index of the first instance.</p> </dd></param>	
        /// <remarks>	
        /// <p>A draw API submits work to the rendering pipeline.</p><p>Instancing may extend performance by reusing the same geometry to draw multiple objects in a scene. One example of instancing could be to draw the same object with different positions and colors. For an example of instancing, see the Instancing10 Sample.</p><p>The vertex data for an instanced draw call normally comes from a vertex buffer that is bound to the pipeline. However, you could also provide the vertex data from a shader that has instanced data identified with a system-value semantic (SV_InstanceID).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::DrawInstanced']/*"/>	
        /// <msdn-id>bb173567</msdn-id>	
        /// <unmanaged>void ID3D10Device::DrawInstanced([In] unsigned int VertexCountPerInstance,[In] unsigned int InstanceCount,[In] unsigned int StartVertexLocation,[In] unsigned int StartInstanceLocation)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::DrawInstanced</unmanaged-short>	
        public void DrawInstanced(int vertexCountPerInstance, int instanceCount, int startVertexLocation, int startInstanceLocation) {
            unsafe {
                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, vertexCountPerInstance, instanceCount, startVertexLocation, startInstanceLocation,((void**)(*(void**)_nativePointer))[15]);		
            }
        }
        
        /// <summary>	
        /// <p>Set a rendering predicate.</p>	
        /// </summary>	
        /// <param name="predicateRef"><dd>  <p>Pointer to a predicate (see <strong><see cref="SharpDX.Direct3D10.Predicate"/></strong>). A <strong><c>null</c></strong> value indicates "no" predication; in this case, the value of PredicateValue is irrelevent but will be preserved for <strong><see cref="SharpDX.Direct3D10.Device.GetPredication"/></strong>.</p> </dd></param>	
        /// <param name="predicateValue"><dd>  <p>If <strong>TRUE</strong>, rendering will be affected by when the predicate's conditions are met. If <strong><see cref="SharpDX.Result.False"/></strong>, rendering will be affected when the conditions are not met.</p> </dd></param>	
        /// <remarks>	
        /// <p>The predicate must be in the "issued" or "signaled" state to be used for predication. While the predicate is set for predication, calls to <strong><see cref="SharpDX.Direct3D10.Asynchronous.Begin"/></strong> and <strong><see cref="SharpDX.Direct3D10.Asynchronous.End"/></strong> are invalid.</p><p>This method is used to denote that subsequent rendering and resource manipulation commands are not actually performed if the resulting Predicate data of the Predicate is equal to the PredicateValue. However, some Predicates are only hints, so they may not actually prevent operations from being performed. </p><p>The primary usefulness of Predication is to allow an application to issue graphics commands without taking the performance hit of spinning, waiting for <strong><see cref="SharpDX.Direct3D10.Asynchronous.GetData"/></strong> to return. So, Predication can occur while <strong><see cref="SharpDX.Direct3D10.Asynchronous.GetData"/></strong> returns S_FALSE. Another way to think of it: an application can also use Predication as a fallback, if it is possible that <strong><see cref="SharpDX.Direct3D10.Asynchronous.GetData"/></strong> returns S_FALSE. If <strong><see cref="SharpDX.Direct3D10.Asynchronous.GetData"/></strong> returns <see cref="SharpDX.Result.Ok"/>, the application can skip calling the graphics commands manually with it's own application logic.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::SetPredication']/*"/>	
        /// <msdn-id>bb173615</msdn-id>	
        /// <unmanaged>void ID3D10Device::SetPredication([In, Optional] ID3D10Predicate* pPredicate,[In] BOOL PredicateValue)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::SetPredication</unmanaged-short>	
        public void SetPredication(SharpDX.Direct3D10.Predicate predicateRef, SharpDX.Mathematics.Interop.RawBool predicateValue) {
            unsafe {
                SharpDX.Direct3D10.LocalInterop.Callivoid9(_nativePointer, (void*)((predicateRef == null)?IntPtr.Zero:predicateRef.NativePointer), predicateValue,((void**)(*(void**)_nativePointer))[21]);		
            }
        }
        
        /// <summary>	
        /// <p>Draw geometry of an unknown size that was created by the geometry shader stage. See remarks.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>A draw API submits work to the rendering pipeline.</p><p>After data has been streamed out to SO stage buffers, those buffers can be again bound to the Input Assembler stage at input slot 0 and DrawAuto will draw them without the application needing to know the amount of data that was written to the buffers. A measurement of the amount of data written to the SO stage buffers is maintained internally when the data is streamed out. This means that the CPU does not need to fetch the measurement before re-binding the data that was streamed as input data. Although this amount is tracked internally, it is still the responsibility of applications to use input layouts to describe the format of the data in the SO stage buffers so that the layouts are available when the buffers are again bound to the input assembler.</p><p>The following diagram shows the DrawAuto process.</p><p></p><p>Calling DrawAuto does not change the state of the streaming-output buffers that were bound again as inputs.</p><p>DrawAuto only works when drawing with one input buffer bound as an input to the IA stage at slot 0. Applications must create the SO buffer resource with both binding flags, <strong><see cref="SharpDX.Direct3D10.BindFlags.VertexBuffer"/></strong> and <strong><see cref="SharpDX.Direct3D10.BindFlags.StreamOutput"/></strong>.</p><p>This API does not support indexing or instancing.</p><p>If an application needs to retrieve the size of the streaming-output buffer, it can query for statistics on streaming output by using <strong><see cref="SharpDX.Direct3D10.QueryType.StreamOutputStatistics"/></strong>.</p><p>Example of using DrawAuto can be found in the ParticlesGS Sample and PipesGS Sample.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::DrawAuto']/*"/>	
        /// <msdn-id>bb173564</msdn-id>	
        /// <unmanaged>void ID3D10Device::DrawAuto()</unmanaged>	
        /// <unmanaged-short>ID3D10Device::DrawAuto</unmanaged-short>	
        public void DrawAuto() {
            unsafe {
                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer,((void**)(*(void**)_nativePointer))[28]);		
            }
        }
        
        /// <summary>	
        /// <p>Copy a region from a source resource to a destination resource.</p>	
        /// </summary>	
        /// <param name="dstResourceRef"><dd>  <p>A reference to the destination resource (see <strong><see cref="SharpDX.Direct3D10.Resource"/></strong>).</p> </dd></param>	
        /// <param name="dstSubresource"><dd>  <p> Subresource index of the destination.</p> </dd></param>	
        /// <param name="dstX"><dd>  <p>The x coordinate of the upper left corner of the destination region.</p> </dd></param>	
        /// <param name="dstY"><dd>  <p>The y coordinate of the upper left corner of the destination region.</p> </dd></param>	
        /// <param name="dstZ"><dd>  <p>The z coordinate of the upper left corner of the destination region. For a 1D or 2D subresource, this must be zero.</p> </dd></param>	
        /// <param name="srcResourceRef"><dd>  <p>A reference to the source resource (see <strong><see cref="SharpDX.Direct3D10.Resource"/></strong>).</p> </dd></param>	
        /// <param name="srcSubresource"><dd>  <p> Subresource index of the source.</p> </dd></param>	
        /// <param name="srcBoxRef"><dd>  <p>A 3D box (see <strong><see cref="SharpDX.Direct3D10.ResourceRegion"/></strong>) that defines the source subresource that can be copied. If <strong><c>null</c></strong>, the entire source subresource is copied. The box must fit within the source resource.</p> <p>An empty box results in a no-op. A box is empty if the top value is greater than or equal to the bottom value, or the left value is greater than or equal to the right value, or the front value is greater than or equal to the back value. When the box is empty, <strong>CopySubresourceRegion</strong> doesn't perform a copy operation.</p> </dd></param>	
        /// <remarks>	
        /// <p>The source box must be within the size of the source resource. The destination location is an absolute value (not a relative value). The destination location can be offset from the source location; however, the size of the region to copy (including the destination location) must fit in the destination resource.</p><p>If the resources are buffers, all coordinates are in bytes; if the resources are textures, all coordinates are in texels. </p><p> <strong>D3D10CalcSubresource</strong> is a helper function for calculating subresource indexes.</p><p><strong>CopySubresourceRegion</strong> performs the copy on the GPU (similar to a memcpy by the CPU). As a consequence, the source and destination resources must meet the following criteria:</p><ul> <li>Must be different subresources (although they can be from the same resource).</li> <li>Must be the same type.</li> <li>Must have compatible <strong>formats</strong> (the formats must either be identical or be from the same type group). For example, a <see cref="SharpDX.DXGI.Format.R32G32B32_Float"/> texture can be copied to an <see cref="SharpDX.DXGI.Format.R32G32B32_UInt"/> texture because both of these formats are in the <see cref="SharpDX.DXGI.Format.R32G32B32_Typeless"/> group. Beginning with Direct3D 10.1, <strong>CopySubresourceRegion</strong> can copy between a few format types. For more info, see Format Conversion using Direct3D 10.1.</li> <li>May not be currently mapped.</li> </ul><p><strong>CopySubresourceRegion</strong> supports only copy; it does not support any stretch, color key, blend, or format conversions. Beginning with Direct3D 10.1, <strong>CopySubresourceRegion</strong> can reinterpret the resource data between a few format types. For more info, see Format Conversion using Direct3D 10.1.</p><p>If your app needs to copy an entire resource, we recommend to use <strong><see cref="SharpDX.Direct3D10.Device.CopyResource_"/></strong> instead.</p><p><strong>CopySubresourceRegion</strong> is an asynchronous call that the runtime can add  to the command-buffer queue. This asynchronous behaviorattempts to remove pipeline stalls that may occur when copying data. See performance considerations for more details.</p><table> <tr><td> <p>Differences between Direct3D 10 and Direct3D 10.1:</p> <p>Direct3D 10 has the following limitations:</p> <ul> <li>You cannot use a depth-stencil resource as a destination.</li> <li>You cannot use an immutable resource as a destination.</li> <li>You cannot use a multisampled texture as either a source or a destination</li> </ul> <p>Direct3D 10.1 has added support for the following features:</p> <ul> <li>You can use a depth-stencil buffer as a source or a destination.</li> <li>You can use multisampled resources as  source and destination only if both source and destination have identical multisampled count and quality. If source and destination differ in multisampled count and quality or if the source is multisampled and the destination is not multisampled (or vice versa), the call to <strong><see cref="SharpDX.Direct3D10.Device.CopySubresourceRegion_"/></strong> fails.</li> <li>You can copy between uncompressed and compressed resources. During copy, the format conversions that are specified in  Format Conversion using Direct3D 10.1 are supported automatically. The uncompressed resource must be at least prestructured, and typed. You must also account for the difference between the virtual and the physical size of the mipmaps levels.</li> </ul> </td></tr> </table><p>?</p><p><strong>Note</strong>??If you use <strong>CopySubresourceRegion</strong> with a depth-stencil buffer or a multisampled resource, you must copy the whole subresource. You must also pass 0 to the <em>DstX</em>, <em>DstY</em>, and <em>DstZ</em> parameters and <strong><c>null</c></strong> to the <em>pSrcBox</em> parameter. In addition, source and destination resources, which are represented by the <em>pSrcResource</em> and <em>pDstResource</em> parameters respectively, must have identical sample count values.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::CopySubresourceRegion']/*"/>	
        /// <msdn-id>bb173542</msdn-id>	
        /// <unmanaged>void ID3D10Device::CopySubresourceRegion([In] ID3D10Resource* pDstResource,[In] unsigned int DstSubresource,[In] unsigned int DstX,[In] unsigned int DstY,[In] unsigned int DstZ,[In] ID3D10Resource* pSrcResource,[In] unsigned int SrcSubresource,[In, Optional] const D3D10_BOX* pSrcBox)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::CopySubresourceRegion</unmanaged-short>	
        internal void CopySubresourceRegion_(SharpDX.Direct3D10.Resource dstResourceRef, int dstSubresource, int dstX, int dstY, int dstZ, SharpDX.Direct3D10.Resource srcResourceRef, int srcSubresource, SharpDX.Direct3D10.ResourceRegion? srcBoxRef) {
            unsafe {
                SharpDX.Direct3D10.ResourceRegion srcBoxRef_;
                if (srcBoxRef.HasValue)
                    srcBoxRef_ = srcBoxRef.Value;				
                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, (void*)((dstResourceRef == null)?IntPtr.Zero:dstResourceRef.NativePointer), dstSubresource, dstX, dstY, dstZ, (void*)((srcResourceRef == null)?IntPtr.Zero:srcResourceRef.NativePointer), srcSubresource, (srcBoxRef.HasValue)?&srcBoxRef_:(void*)IntPtr.Zero,((void**)(*(void**)_nativePointer))[32]);		
            }
        }
        
        /// <summary>	
        /// <p>Copy the entire contents of the source resource to the destination resource using the GPU. </p>	
        /// </summary>	
        /// <param name="dstResourceRef"><dd>  <p>A reference to the destination resource (see <strong><see cref="SharpDX.Direct3D10.Resource"/></strong>).</p> </dd></param>	
        /// <param name="srcResourceRef"><dd>  <p>A reference to the source resource (see <strong><see cref="SharpDX.Direct3D10.Resource"/></strong>).</p> </dd></param>	
        /// <remarks>	
        /// <p>This method is unusual in that it causes the GPU to perform the copy operation (similar to a memcpy by the CPU). As a result, it has a few restrictions designed for improving performance. For instance, the source and destination resources:</p><ul> <li>Must be different resources.</li> <li>Must be the same type.</li> <li>Must have identical dimensions (including width, height, depth, and size as appropriate).</li> <li>Must have compatible <strong>formats</strong>, which means the formats must be identical or at least from the same type group. For example, a <see cref="SharpDX.DXGI.Format.R32G32B32_Float"/> texture can be copied to an <see cref="SharpDX.DXGI.Format.R32G32B32_UInt"/> texture since both of these formats are in the <see cref="SharpDX.DXGI.Format.R32G32B32_Typeless"/> group. Beginning with Direct3D 10.1, <strong>CopyResource</strong> can copy between a few format types. For more info, see Format Conversion using Direct3D 10.1.</li> <li>May not be currently mapped.</li> </ul><p><strong>CopyResource</strong> supports only copy; it does not support any stretch, color key, blend, or format conversions. Beginning with Direct3D 10.1, <strong>CopyResource</strong> can reinterpret the resource data between a few format types. For more info, see Format Conversion using Direct3D 10.1.</p><p> <strong>Immutable</strong>, and <strong>depth-stencil</strong> resources cannot be used as a destination.  Resources created with <strong>multisampling capability</strong> cannot be used as either a source or destination.</p><p>The method is an asynchronous call which may be added to the command-buffer queue. This attempts to remove pipeline stalls that may occur when copying data. See performance considerations for more details.</p><p>An application that only needs to copy a portion of the data in a resource should use <strong><see cref="SharpDX.Direct3D10.Device.CopySubresourceRegion_"/></strong> instead.</p><table> <tr><td> <p>Differences between Direct3D 10 and Direct3D 10.1:</p> <p>Direct3D 10.1 enables depth-stencil resources to be used as either a source or destination. Direct3D 10.1 enables multisampled resources to be used as source and destination only if both source and destination have identical multisampled count and quality. If source and destination differ in multisampled count and quality or one of them is multisampled and the other is not multisampled, the call to <strong><see cref="SharpDX.Direct3D10.Device.CopyResource_"/></strong> fails.</p> <p>It is possible to copy between prestructured+typed resources and block-compressed textures. See Format Conversion using Direct3D 10.1.</p> </td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::CopyResource']/*"/>	
        /// <msdn-id>bb173541</msdn-id>	
        /// <unmanaged>void ID3D10Device::CopyResource([In] ID3D10Resource* pDstResource,[In] ID3D10Resource* pSrcResource)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::CopyResource</unmanaged-short>	
        internal void CopyResource_(SharpDX.Direct3D10.Resource dstResourceRef, SharpDX.Direct3D10.Resource srcResourceRef) {
            unsafe {
                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, (void*)((dstResourceRef == null)?IntPtr.Zero:dstResourceRef.NativePointer), (void*)((srcResourceRef == null)?IntPtr.Zero:srcResourceRef.NativePointer),((void**)(*(void**)_nativePointer))[33]);		
            }
        }
        
        /// <summary>	
        /// <p>The CPU copies data from memory to a subresource created in non-mappable memory. See remarks.</p>	
        /// </summary>	
        /// <param name="dstResourceRef">No documentation.</param>	
        /// <param name="dstSubresource">No documentation.</param>	
        /// <param name="dstBoxRef">No documentation.</param>	
        /// <param name="srcDataRef">No documentation.</param>	
        /// <param name="srcRowPitch">No documentation.</param>	
        /// <param name="srcDepthPitch">No documentation.</param>	
        /// <remarks>	
        /// <p>For a shader-constant buffer; set pDstBox to <strong><c>null</c></strong>. It is not possible to use this method to partially update a shader-constant buffer.</p><p>A resource cannot be used as a destination if:</p><ul> <li>the resource is created with <strong>immutable</strong> or <strong>dynamic</strong> usage.</li> <li>the resource is created as a depth-stencil resource.</li> <li>the resource is created with multisampling capability (see <strong><see cref="SharpDX.DXGI.SampleDescription"/></strong>).</li> </ul><p>When UpdateSubresource returns, the application is free to change or even free the data pointed to by pSrcData because the method has already copied/snapped away the original contents.</p><p>The performance of UpdateSubresource depends on whether or not there is contention for the destination resource. For example, contention for a vertex buffer resource occurs when the application executes a Draw call and later calls UpdateSubresource on the same vertex buffer before the Draw call is actually executed by the GPU.</p><ul> <li>When there is contention for the resource, UpdateSubresource will perform 2 copies of the source data. First, the data is copied by the CPU to a temporary storage space accessible by the command buffer. This copy happens before the method returns.  A second copy is then performed by the GPU to copy the source data into non-mappable memory. This second copy happens asynchronously because it is executed by GPU when the command buffer is flushed.</li> <li>When there is no resource contention, the behavior of UpdateSubresource is dependent on which is faster (from the CPU's perspective): copying the data to the command buffer and then having a second copy execute when the command buffer is flushed, or having the CPU copy the data to the final resource location. This is dependent on the architecture of the underlying system.</li> </ul><p>To better understand the source row pitch and source depth pitch parameters, consider the following illustration of a 3D volume texture.</p><p></p><p>Each block in this visual represents an element of data, and the size of each element is dependent on the resource's format. For example, if the resource format is <see cref="SharpDX.DXGI.Format.R32G32B32A32_Float"/>, then the size of each element would be 128 bits, or 16 bytes. This 3D volume texture has a width of two, a height of three, and a depth of four.</p><p>To calculate the source row pitch and source depth pitch for a given resource, use the following formulas:</p><ul> <li>Source Row Pitch = [size of one element in bytes] * [number of elements in one row]</li> <li>Source Depth Pitch = [Source Row Pitch] * [number of rows (height)]</li> </ul><p>In the case of this example 3D volume texture where the size of each element is 16 bytes, the formulas are as follows:</p><ul> <li>Source Row Pitch = 16 * 2 = 32</li> <li>Source Depth Pitch = 16 * 2 * 3 = 96</li> </ul><p>The following illustration shows the resource as it is laid out in memory.</p><p></p><p>For example, the following code snippet shows how to specify a destination region in a 2D texture. Assume the destination texture is 512x512 and the operation will copy the data pointed to by pData to  [(120,100)..(200,220)] in the destination texture. Also assume that rowPitch has been initialized with the proper value (as explained above). Front and back are set to 0 and 1 respectively, because by having front equal to back, the box is technically empty.</p><pre> <see cref="SharpDX.Direct3D10.ResourceRegion"/> destRegion;	
        /// destRegion.left = 120;	
        /// destRegion.right = 200;	
        /// destRegion.top = 100;	
        /// destRegion.bottom = 220;	
        /// destRegion.front = 0;	
        /// destRegion.back = 1; pd3dDevice-&gt;UpdateSubresource( pDestTexture, 0, &amp;destRegion, pData, rowPitch, 0 );	
        /// </pre><p>The 1D case is similar. The following snippet shows how to specify a destination region in a 1D texture. Use the same assumptions as above, except that the texture is 512 in length.</p><pre> <see cref="SharpDX.Direct3D10.ResourceRegion"/> destRegion;	
        /// destRegion.left = 120;	
        /// destRegion.right = 200;	
        /// destRegion.top = 0;	
        /// destRegion.bottom = 1;	
        /// destRegion.front = 0;	
        /// destRegion.back = 1; pd3dDevice-&gt;UpdateSubresource( pDestTexture, 0, &amp;destRegion, pData, rowPitch, 0 );	
        /// </pre><table> <tr><td> <p>Differences between Direct3D 10 and Direct3D 10.1:</p> <p>Direct3D 10.1 enables depth-stencil resources to be used as either a source or destination.</p> </td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::UpdateSubresource']/*"/>	
        /// <msdn-id>bb173621</msdn-id>	
        /// <unmanaged>void ID3D10Device::UpdateSubresource([In] ID3D10Resource* pDstResource,[In] unsigned int DstSubresource,[In, Optional] const D3D10_BOX* pDstBox,[In] const void* pSrcData,[In] unsigned int SrcRowPitch,[In] unsigned int SrcDepthPitch)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::UpdateSubresource</unmanaged-short>	
        public void UpdateSubresource(SharpDX.Direct3D10.Resource dstResourceRef, int dstSubresource, SharpDX.Direct3D10.ResourceRegion? dstBoxRef, System.IntPtr srcDataRef, int srcRowPitch, int srcDepthPitch) {
            unsafe {
                SharpDX.Direct3D10.ResourceRegion dstBoxRef_;
                if (dstBoxRef.HasValue)
                    dstBoxRef_ = dstBoxRef.Value;				
                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, (void*)((dstResourceRef == null)?IntPtr.Zero:dstResourceRef.NativePointer), dstSubresource, (dstBoxRef.HasValue)?&dstBoxRef_:(void*)IntPtr.Zero, (void*)srcDataRef, srcRowPitch, srcDepthPitch,((void**)(*(void**)_nativePointer))[34]);		
            }
        }
        
        /// <summary>	
        /// <p>Set all the elements in a render target to one value.</p>	
        /// </summary>	
        /// <param name="renderTargetViewRef"><dd>  <p>Pointer to the render target.</p> </dd></param>	
        /// <param name="colorRGBA"><dd>  <p>A 4-component array that represents the color to fill the render target with.</p> </dd></param>	
        /// <remarks>	
        /// <p>Applications that wish to clear a render target to a specific integer value bit pattern should render a screen-aligned quad instead of using this method.  The reason for this is because this method accepts as input a floating point value, which may not have the same bit pattern as the original integer.</p><table> <tr><td> <p>Differences between Direct3D 9 and Direct3D 10:</p> <p>Unlike Direct3D 9, the full extent of the resource view is always cleared. Viewport and scissor settings are not applied.</p> </td></tr> </table><p>?</p><p>When using 10Level9, <strong>ClearRenderTargetView</strong> only clears the first array slice in the render target view. This can impact (for example) cube map rendering scenarios. Applications should create a render target view for each face or array slice, then clear each view individually.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::ClearRenderTargetView']/*"/>	
        /// <msdn-id>bb173539</msdn-id>	
        /// <unmanaged>void ID3D10Device::ClearRenderTargetView([In] ID3D10RenderTargetView* pRenderTargetView,[In] const SHARPDX_COLOR4* ColorRGBA)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::ClearRenderTargetView</unmanaged-short>	
        public void ClearRenderTargetView(SharpDX.Direct3D10.RenderTargetView renderTargetViewRef, SharpDX.Mathematics.Interop.RawColor4 colorRGBA) {
            unsafe {
                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, (void*)((renderTargetViewRef == null)?IntPtr.Zero:renderTargetViewRef.NativePointer), &colorRGBA,((void**)(*(void**)_nativePointer))[35]);		
            }
        }
        
        /// <summary>	
        /// <p>Clears the depth-stencil resource.</p>	
        /// </summary>	
        /// <param name="depthStencilViewRef"><dd>  <p>Pointer to the depth stencil to be cleared.</p> </dd></param>	
        /// <param name="clearFlags"><dd>  <p>Which parts of the buffer to clear. See <strong><see cref="SharpDX.Direct3D10.DepthStencilClearFlags"/></strong>.</p> </dd></param>	
        /// <param name="depth"><dd>  <p>Clear the depth buffer with this value. This value will be clamped between 0 and 1.</p> </dd></param>	
        /// <param name="stencil"><dd>  <p>Clear the stencil buffer with this value.</p> </dd></param>	
        /// <remarks>	
        /// <table> <tr><td> <p>Differences between Direct3D 9 and Direct3D 10:</p> <p>Unlike Direct3D 9, the full extent of the resource view is always cleared. Viewport and scissor settings are not applied.</p> </td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::ClearDepthStencilView']/*"/>	
        /// <msdn-id>bb173538</msdn-id>	
        /// <unmanaged>void ID3D10Device::ClearDepthStencilView([In] ID3D10DepthStencilView* pDepthStencilView,[In] D3D10_CLEAR_FLAG ClearFlags,[In] float Depth,[In] unsigned char Stencil)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::ClearDepthStencilView</unmanaged-short>	
        public void ClearDepthStencilView(SharpDX.Direct3D10.DepthStencilView depthStencilViewRef, SharpDX.Direct3D10.DepthStencilClearFlags clearFlags, float depth, byte stencil) {
            unsafe {
                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, (void*)((depthStencilViewRef == null)?IntPtr.Zero:depthStencilViewRef.NativePointer), unchecked((int)clearFlags), depth, stencil,((void**)(*(void**)_nativePointer))[36]);		
            }
        }
        
        /// <summary>	
        /// <p>Generates mipmaps for the given shader resource.</p>	
        /// </summary>	
        /// <param name="shaderResourceViewRef"><dd>  <p>A reference to an <strong><see cref="SharpDX.Direct3D10.ShaderResourceView"/></strong>. The mipmaps will be generated for this shader resource.</p> </dd></param>	
        /// <remarks>	
        /// <p>GenerateMips may be called on any <see cref="SharpDX.Direct3D10.ShaderResourceView"/> in order to generate the lower mipmap levels. GenerateMips uses the largest mipmap level of the view to recursively generate the lower levels of the mip, stopping with the smallest level specified by the view. If the base resource was not created with <strong><see cref="SharpDX.Direct3D10.BindFlags.RenderTarget"/></strong> and <strong><see cref="SharpDX.Direct3D10.ResourceOptionFlags.GenerateMipMaps"/></strong>, this call has no effect.</p><p>Video adapters that support feature level 9.1 and higher support generating mipmaps if you use any of these formats:</p><pre> <see cref="SharpDX.DXGI.Format.R8G8B8A8_UNorm"/>	
        /// <see cref="SharpDX.DXGI.Format.R8G8B8A8_UNorm_SRgb"/>	
        /// <see cref="SharpDX.DXGI.Format.B5G6R5_UNorm"/>	
        /// <see cref="SharpDX.DXGI.Format.B8G8R8A8_UNorm"/>	
        /// <see cref="SharpDX.DXGI.Format.B8G8R8A8_UNorm_SRgb"/>	
        /// <see cref="SharpDX.DXGI.Format.B8G8R8X8_UNorm"/>	
        /// <see cref="SharpDX.DXGI.Format.B8G8R8X8_UNorm_SRgb"/>	
        /// </pre><p>Video adapters that support feature level 9.2 and higher support generating mipmaps if you use any of these formats in addition to any of the formats for feature level 9.1:</p><pre> <see cref="SharpDX.DXGI.Format.R16G16B16A16_Float"/>	
        /// <see cref="SharpDX.DXGI.Format.R16G16B16A16_UNorm"/>	
        /// <see cref="SharpDX.DXGI.Format.R16G16_Float"/>	
        /// <see cref="SharpDX.DXGI.Format.R16G16_UNorm"/>	
        /// <see cref="SharpDX.DXGI.Format.R32_Float"/>	
        /// </pre><p>Video adapters that support feature level 9.3 and higher support generating mipmaps if you use any of these formats in addition to any of the formats for feature levels 9.1 and 9.2:</p><pre> <see cref="SharpDX.DXGI.Format.R32G32B32A32_Float"/>	
        /// DXGI_FORMAT_B4G4R4A4 (optional)	
        /// </pre><p>Video adapters that support feature level 10 and higher support generating mipmaps if you use any of these formats in addition to any of the formats for feature levels 9.1, 9.2, and 9.3:</p><pre> <see cref="SharpDX.DXGI.Format.R32G32B32_Float"/> (optional)	
        /// <see cref="SharpDX.DXGI.Format.R16G16B16A16_SNorm"/>	
        /// <see cref="SharpDX.DXGI.Format.R32G32_Float"/>	
        /// <see cref="SharpDX.DXGI.Format.R10G10B10A2_UNorm"/>	
        /// <see cref="SharpDX.DXGI.Format.R11G11B10_Float"/>	
        /// <see cref="SharpDX.DXGI.Format.R8G8B8A8_SNorm"/>	
        /// <see cref="SharpDX.DXGI.Format.R16G16_SNorm"/>	
        /// <see cref="SharpDX.DXGI.Format.R8G8_UNorm"/>	
        /// <see cref="SharpDX.DXGI.Format.R8G8_SNorm"/>	
        /// <see cref="SharpDX.DXGI.Format.R16_Float"/>	
        /// <see cref="SharpDX.DXGI.Format.R16_UNorm"/>	
        /// <see cref="SharpDX.DXGI.Format.R16_SNorm"/>	
        /// <see cref="SharpDX.DXGI.Format.R8_UNorm"/>	
        /// <see cref="SharpDX.DXGI.Format.R8_SNorm"/>	
        /// <see cref="SharpDX.DXGI.Format.A8_UNorm"/>	
        /// <see cref="SharpDX.DXGI.Format.B5G5R5A1_UNorm"/> (optional)	
        /// </pre><p>For all other unsupported formats, this method will silently fail.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::GenerateMips']/*"/>	
        /// <msdn-id>bb173569</msdn-id>	
        /// <unmanaged>void ID3D10Device::GenerateMips([In] ID3D10ShaderResourceView* pShaderResourceView)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::GenerateMips</unmanaged-short>	
        public void GenerateMips(SharpDX.Direct3D10.ShaderResourceView shaderResourceViewRef) {
            unsafe {
                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, (void*)((shaderResourceViewRef == null)?IntPtr.Zero:shaderResourceViewRef.NativePointer),((void**)(*(void**)_nativePointer))[37]);		
            }
        }
        
        /// <summary>	
        /// <p>Copy a multisampled resource into a non-multisampled resource. This API is most useful when re-using the resulting rendertarget of one render pass as an input to a second render pass.</p>	
        /// </summary>	
        /// <param name="dstResourceRef"><dd>  <p>Destination resource. Must be a created with the <strong><see cref="SharpDX.Direct3D10.ResourceUsage.Default"/></strong> flag and be single-sampled. See <strong><see cref="SharpDX.Direct3D10.Resource"/></strong>.</p> </dd></param>	
        /// <param name="dstSubresource"><dd>  <p>A zero-based index, that identifies the destination subresource. See <strong>D3D10CalcSubresource</strong> for more details.</p> </dd></param>	
        /// <param name="srcResourceRef"><dd>  <p>Source resource. Must be multisampled.</p> </dd></param>	
        /// <param name="srcSubresource"><dd>  <p>The source subresource of the source resource.</p> </dd></param>	
        /// <param name="format"><dd>  <p> <strong><see cref="SharpDX.DXGI.Format"/></strong> that indicates how the multisampled resource will be resolved to a single-sampled resource. See remarks.</p> </dd></param>	
        /// <remarks>	
        /// <p>Both the source and destination resources must be the same resource type and have the same dimensions.</p><p>The source and destination must have compatible formats. There are three scenarios for this:</p><table> <tr><th>Scenario</th><th>Requirements</th></tr> <tr><td>Source and destination are prestructured and typed</td><td>Both the source and destination must have identical formats and that format must be specified in the Format parameter.</td></tr> <tr><td>One resource is prestructured and typed and the other is prestructured and typeless</td><td>The typed resource must have a format that is compatible with the typeless resource (i.e. the typed resource is <see cref="SharpDX.DXGI.Format.R32_Float"/> and the typeless resource is <see cref="SharpDX.DXGI.Format.R32_Typeless"/>). The format of the typed resource must be specified in the Format parameter.</td></tr> <tr><td>Source and destination are prestructured and typeless</td><td>Both the source and desintation must have the same typeless format (i.e. both must have <see cref="SharpDX.DXGI.Format.R32_Typeless"/>), and the Format parameter must specify a format that is compatible with the source and destination (i.e. if both are <see cref="SharpDX.DXGI.Format.R32_Typeless"/> then <see cref="SharpDX.DXGI.Format.R32_Float"/> or <see cref="SharpDX.DXGI.Format.R32_UInt"/> could be specified in the Format parameter).</td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::ResolveSubresource']/*"/>	
        /// <msdn-id>bb173607</msdn-id>	
        /// <unmanaged>void ID3D10Device::ResolveSubresource([In] ID3D10Resource* pDstResource,[In] unsigned int DstSubresource,[In] ID3D10Resource* pSrcResource,[In] unsigned int SrcSubresource,[In] DXGI_FORMAT Format)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::ResolveSubresource</unmanaged-short>	
        internal void ResolveSubresource_(SharpDX.Direct3D10.Resource dstResourceRef, int dstSubresource, SharpDX.Direct3D10.Resource srcResourceRef, int srcSubresource, SharpDX.DXGI.Format format) {
            unsafe {
                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, (void*)((dstResourceRef == null)?IntPtr.Zero:dstResourceRef.NativePointer), dstSubresource, (void*)((srcResourceRef == null)?IntPtr.Zero:srcResourceRef.NativePointer), srcSubresource, unchecked((int)format),((void**)(*(void**)_nativePointer))[38]);		
            }
        }
        
        /// <summary>	
        /// <p>Get the rendering predicate state.</p>	
        /// </summary>	
        /// <param name="predicateOut"><dd>  <p>Address of a reference to a predicate (see <strong><see cref="SharpDX.Direct3D10.Predicate"/></strong>). Value stored here will be <strong><c>null</c></strong> upon device creation.</p> </dd></param>	
        /// <param name="predicateValueRef"><dd>  <p>Address of a boolean to fill with the predicate comparison value. <strong><see cref="SharpDX.Result.False"/></strong> upon device creation.</p> </dd></param>	
        /// <remarks>	
        /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::GetPredication']/*"/>	
        /// <msdn-id>bb173573</msdn-id>	
        /// <unmanaged>void ID3D10Device::GetPredication([Out, Optional] ID3D10Predicate** ppPredicate,[Out, Optional] BOOL* pPredicateValue)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::GetPredication</unmanaged-short>	
        internal void GetPredication(out SharpDX.Direct3D10.Predicate predicateOut, out SharpDX.Mathematics.Interop.RawBool predicateValueRef) {
            unsafe {
                IntPtr predicateOut_ = IntPtr.Zero;
                predicateValueRef = new SharpDX.Mathematics.Interop.RawBool();
                fixed (void* predicateValueRef_ = &predicateValueRef)
                    SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, &predicateOut_, predicateValueRef_,((void**)(*(void**)_nativePointer))[53]);		
                predicateOut= (predicateOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.Predicate(predicateOut_);	
            }
        }
        
        /// <summary>	
        /// <p>Get the reason why the device was removed.</p>	
        /// </summary>	
        /// <returns><p>Possible return values include:  </p><ul> <li><see cref="SharpDX.DXGI.ResultCode.DeviceHung"/></li> <li><see cref="SharpDX.DXGI.ResultCode.DeviceRemoved"/></li> <li><see cref="SharpDX.DXGI.ResultCode.DeviceReset"/></li> <li><see cref="SharpDX.DXGI.ResultCode.DriverInternalError"/></li> <li><see cref="SharpDX.DXGI.ResultCode.InvalidCall"/></li> <li><see cref="SharpDX.Result.Ok"/></li> </ul><p>For more detail on these return codes, see DXGI_ERROR.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::GetDeviceRemovedReason']/*"/>	
        /// <msdn-id>bb173571</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::GetDeviceRemovedReason()</unmanaged>	
        /// <unmanaged-short>ID3D10Device::GetDeviceRemovedReason</unmanaged-short>	
        internal SharpDX.Result GetDeviceRemovedReason() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[63]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get the exception-mode flags.</p>	
        /// </summary>	
        /// <param name="raiseFlags"><dd>  <p>A value that contains one or more exception flags; each flag specifies a condition which will cause an exception to be raised. The flags are listed in <strong>D3D10_RAISE_FLAG</strong>. A default value of 0 means there are no flags.</p> </dd></param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>Set an exception-mode flag to elevate an error condition to a non-continuable exception. </p><p>Whenever an error occurs, a Direct3D device enters the DEVICEREMOVED state and if the appropriate exception flag has been set, an exception is raised. A raised exception is designed to terminate an application. Before termination, the last chance an application has to persist data is by using an UnhandledExceptionFilter (see Structured Exception Handling). In general, UnhandledExceptionFilters are leveraged to try to persist data when an application is crashing (to disk, for example). Any code that executes during an UnhandledExceptionFilter is not guaranteed to reliably execute (due to possible process corruption). Any data that the UnhandledExceptionFilter manages to persist, before the UnhandledExceptionFilter crashes again, should be treated as suspect, and therefore inspected by a new, non-corrupted process to see if it is usable.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::SetExceptionMode']/*"/>	
        /// <msdn-id>bb173614</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::SetExceptionMode([In] unsigned int RaiseFlags)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::SetExceptionMode</unmanaged-short>	
        internal void SetExceptionMode(int raiseFlags) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, raiseFlags,((void**)(*(void**)_nativePointer))[64]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get the exception-mode flags.</p>	
        /// </summary>	
        /// <returns><p>A value that contains one or more exception flags; each flag specifies a condition which will cause an exception to be raised. The flags are listed in <strong>D3D10_RAISE_FLAG</strong>. A default value of 0 means there are no flags.</p></returns>	
        /// <remarks>	
        /// <p>An exception-mode flag is used to elevate an error condition to a non-continuable exception. </p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::GetExceptionMode']/*"/>	
        /// <msdn-id>bb173572</msdn-id>	
        /// <unmanaged>unsigned int ID3D10Device::GetExceptionMode()</unmanaged>	
        /// <unmanaged-short>ID3D10Device::GetExceptionMode</unmanaged-short>	
        internal int GetExceptionMode() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[65]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get data from a device that is associated with a guid.</p>	
        /// </summary>	
        /// <param name="guid"><dd>  <p>Guid associated with the data.</p> </dd></param>	
        /// <param name="dataSizeRef"><dd>  <p>Size of the data.</p> </dd></param>	
        /// <param name="dataRef"><dd>  <p>Pointer to the data stored with the device. If pData is <strong><c>null</c></strong>, DataSize must also be 0, and any data previously associated with the guid will be destroyed.</p> </dd></param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>The data stored in the device is set with <strong><see cref="SharpDX.Direct3D10.Device.SetPrivateData"/></strong>. </p><p>The data retrieved and the guid will typically be application-defined.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::GetPrivateData']/*"/>	
        /// <msdn-id>bb173574</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::GetPrivateData([In] const GUID&amp; guid,[InOut] unsigned int* pDataSize,[Out, Buffer, Optional] void* pData)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::GetPrivateData</unmanaged-short>	
        public SharpDX.Result GetPrivateData(System.Guid guid, ref int dataSizeRef, System.IntPtr dataRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dataSizeRef_ = &dataSizeRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &guid, dataSizeRef_, (void*)dataRef,((void**)(*(void**)_nativePointer))[66]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Set data to a device and associate that data with a guid.</p>	
        /// </summary>	
        /// <param name="guid"><dd>  <p>Guid associated with the data.</p> </dd></param>	
        /// <param name="dataSize"><dd>  <p>Size of the data.</p> </dd></param>	
        /// <param name="dataRef"><dd>  <p>Pointer to the data to be stored with this device. If pData is <strong><c>null</c></strong>, DataSize must also be 0, and any data previously associated with the guid will be destroyed.</p> </dd></param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>The data stored in the device with this method can be retrieved with <strong><see cref="SharpDX.Direct3D10.DeviceChild.GetPrivateData"/></strong>.</p><p>The data and guid set with this method will typically be application-defined.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::SetPrivateData']/*"/>	
        /// <msdn-id>bb173616</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::SetPrivateData([In] const GUID&amp; guid,[In] unsigned int DataSize,[In, Buffer, Optional] const void* pData)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::SetPrivateData</unmanaged-short>	
        public void SetPrivateData(System.Guid guid, int dataSize, System.IntPtr dataRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &guid, dataSize, (void*)dataRef,((void**)(*(void**)_nativePointer))[67]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// No documentation.	
        /// </summary>	
        /// <param name="guid">No documentation.</param>	
        /// <param name="dataRef">No documentation.</param>	
        /// <returns>No documentation.</returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::SetPrivateDataInterface']/*"/>	
        /// <unmanaged>HRESULT ID3D10Device::SetPrivateDataInterface([In] const GUID&amp; guid,[In, Optional] const IUnknown* pData)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::SetPrivateDataInterface</unmanaged-short>	
        public void SetPrivateDataInterface(System.Guid guid, SharpDX.ComObject dataRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &guid, (void*)((dataRef == null)?IntPtr.Zero:dataRef.NativePointer),((void**)(*(void**)_nativePointer))[68]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Restore all default device settings; return the device to the state it was in when it was created. This will set all set all input/output resource slots, shaders, input layouts, predications, scissor rectangles, depth-stencil state, rasterizer state, blend state, sampler state, and viewports to <strong><c>null</c></strong>. The primitive topology will be set to UNDEFINED.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::ClearState']/*"/>	
        /// <msdn-id>bb173540</msdn-id>	
        /// <unmanaged>void ID3D10Device::ClearState()</unmanaged>	
        /// <unmanaged-short>ID3D10Device::ClearState</unmanaged-short>	
        public void ClearState() {
            unsafe {
                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer,((void**)(*(void**)_nativePointer))[69]);		
            }
        }
        
        /// <summary>	
        /// <p>Send queued-up commands in the command buffer to the GPU.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Most applications will not need to call this method. Calling this method when not necessary will incur a performance penalty. Each call to <strong>Flush</strong> incurs a significant amount of overhead.</p><p>When Direct3D state-setting, present, or draw commands are called by an application, those commands are queued into an internal command buffer. <strong>Flush</strong> sends those commands to the GPU for processing. Normally, these commands are sent to the GPU automatically whenever Direct3D determines that they need to be, such as when the command buffer is full or when mapping a resource. <strong>Flush</strong> will send the commands manually.</p><p><strong>Flush</strong> should be used when the CPU waits for an arbitrary amount of time (such as when calling Sleep, <strong>ID3DX10ThreadPump::WaitForAllItems</strong>, or <strong>WaitForVBlank</strong>.</p><p>For more information about how flushing works, see Accurately Profiling Direct3D API Calls (Direct3D 9).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::Flush']/*"/>	
        /// <msdn-id>bb173568</msdn-id>	
        /// <unmanaged>void ID3D10Device::Flush()</unmanaged>	
        /// <unmanaged-short>ID3D10Device::Flush</unmanaged-short>	
        public void Flush() {
            unsafe {
                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer,((void**)(*(void**)_nativePointer))[70]);		
            }
        }
        
        /// <summary>	
        /// <p>Create a buffer (vertex buffer, index buffer, or shader-constant buffer).</p>	
        /// </summary>	
        /// <param name="descRef">No documentation.</param>	
        /// <param name="initialDataRef">No documentation.</param>	
        /// <param name="bufferOut">No documentation.</param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>For example code, see:</p><ul> <li> Create a Vertex Buffer </li> <li> Create an Index Buffer </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::CreateBuffer']/*"/>	
        /// <msdn-id>bb173544</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::CreateBuffer([In] const D3D10_BUFFER_DESC* pDesc,[In, Optional] const D3D10_SUBRESOURCE_DATA* pInitialData,[Out, Fast] ID3D10Buffer** ppBuffer)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::CreateBuffer</unmanaged-short>	
        internal void CreateBuffer(ref SharpDX.Direct3D10.BufferDescription descRef, SharpDX.DataBox? initialDataRef, SharpDX.Direct3D10.Buffer bufferOut) {
            unsafe {
                SharpDX.DataBox initialDataRef_;
                if (initialDataRef.HasValue)
                    initialDataRef_ = initialDataRef.Value;				
                IntPtr bufferOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, descRef_, (initialDataRef.HasValue)?&initialDataRef_:(void*)IntPtr.Zero, &bufferOut_,((void**)(*(void**)_nativePointer))[71]);		
                ((SharpDX.Direct3D10.Buffer)bufferOut).NativePointer = bufferOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Create an array of 1D textures (see Texture1D).</p>	
        /// </summary>	
        /// <param name="descRef">No documentation.</param>	
        /// <param name="initialDataRef">No documentation.</param>	
        /// <param name="texture1DOut">No documentation.</param>	
        /// <returns><p>If the method succeeds, the return code is <see cref="SharpDX.Result.Ok"/>. See Direct3D 10 Return Codes for failing error codes.</p></returns>	
        /// <remarks>	
        /// <p>CreateTexture1D creates a 1D texture resource, which contains an array of 1D textures. The number of textures is specified in the texture description. All textures in a resource must have the same format, size, and number of mipmap levels.</p><p>All resources are made up of one or more subresources. To load data into the texture, applications may supply the data initially as part of <strong><see cref="SharpDX.DataBox"/></strong> structure pointed to by pInitialData, or it may use one of the Texturing Functions supplied by the SDK.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::CreateTexture1D']/*"/>	
        /// <msdn-id>bb173559</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::CreateTexture1D([In] const D3D10_TEXTURE1D_DESC* pDesc,[In, Buffer, Optional] const D3D10_SUBRESOURCE_DATA* pInitialData,[Out, Fast] ID3D10Texture1D** ppTexture1D)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::CreateTexture1D</unmanaged-short>	
        internal void CreateTexture1D(ref SharpDX.Direct3D10.Texture1DDescription descRef, SharpDX.DataBox[] initialDataRef, SharpDX.Direct3D10.Texture1D texture1DOut) {
            unsafe {
                SharpDX.DataBox[] initialDataRef__ = initialDataRef;
                IntPtr texture1DOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* descRef_ = &descRef)
                    fixed (void* initialDataRef_ = initialDataRef__)
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, descRef_, initialDataRef_, &texture1DOut_,((void**)(*(void**)_nativePointer))[72]);		
                ((SharpDX.Direct3D10.Texture1D)texture1DOut).NativePointer = texture1DOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Create an array of 2D textures (see Texture2D).</p>	
        /// </summary>	
        /// <param name="descRef">No documentation.</param>	
        /// <param name="initialDataRef">No documentation.</param>	
        /// <param name="texture2DOut">No documentation.</param>	
        /// <returns><p>If the method succeeds, the return code is <see cref="SharpDX.Result.Ok"/>. See Direct3D 10 Return Codes for failing error codes.</p></returns>	
        /// <remarks>	
        /// <p>CreateTexture2D creates a 2D texture resource, which contains an array of 1D textures. The number of textures is specified in the texture description. All textures in a resource must have the same format, size, and number of mipmap levels.</p><p>All resources are made up of one or more subresources. To load data into the texture, applications may supply the data initially as part of <strong><see cref="SharpDX.DataBox"/></strong> structure pointed to by pInitialData, or it may use one of the Texturing Functions supplied by the SDK.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::CreateTexture2D']/*"/>	
        /// <msdn-id>bb173560</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::CreateTexture2D([In] const D3D10_TEXTURE2D_DESC* pDesc,[In, Buffer, Optional] const D3D10_SUBRESOURCE_DATA* pInitialData,[Out, Fast] ID3D10Texture2D** ppTexture2D)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::CreateTexture2D</unmanaged-short>	
        internal void CreateTexture2D(ref SharpDX.Direct3D10.Texture2DDescription descRef, SharpDX.DataBox[] initialDataRef, SharpDX.Direct3D10.Texture2D texture2DOut) {
            unsafe {
                SharpDX.DataBox[] initialDataRef__ = initialDataRef;
                IntPtr texture2DOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* descRef_ = &descRef)
                    fixed (void* initialDataRef_ = initialDataRef__)
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, descRef_, initialDataRef_, &texture2DOut_,((void**)(*(void**)_nativePointer))[73]);		
                ((SharpDX.Direct3D10.Texture2D)texture2DOut).NativePointer = texture2DOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Create a single 3D texture (see Texture3D).</p>	
        /// </summary>	
        /// <param name="descRef">No documentation.</param>	
        /// <param name="initialDataRef">No documentation.</param>	
        /// <param name="texture3DOut">No documentation.</param>	
        /// <returns><p>If the method succeeds, the return code is <see cref="SharpDX.Result.Ok"/>. See Direct3D 10 Return Codes for failing error codes.</p></returns>	
        /// <remarks>	
        /// <p>CreateTexture3D creates a 3D texture resource, which contains an array of 1D textures. The number of textures is specified in the texture description. All textures in a resource must have the same format, size, and number of mipmap levels.</p><p>All resources are made up of one or more subresources. To load data into the texture, applications may supply the data initially as part of <strong><see cref="SharpDX.DataBox"/></strong> structure pointed to by pInitialData, or it may use one of the Texturing Functions supplied by the SDK.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::CreateTexture3D']/*"/>	
        /// <msdn-id>bb173561</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::CreateTexture3D([In] const D3D10_TEXTURE3D_DESC* pDesc,[In, Buffer, Optional] const D3D10_SUBRESOURCE_DATA* pInitialData,[Out, Fast] ID3D10Texture3D** ppTexture3D)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::CreateTexture3D</unmanaged-short>	
        internal void CreateTexture3D(ref SharpDX.Direct3D10.Texture3DDescription descRef, SharpDX.DataBox[] initialDataRef, SharpDX.Direct3D10.Texture3D texture3DOut) {
            unsafe {
                SharpDX.DataBox[] initialDataRef__ = initialDataRef;
                IntPtr texture3DOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* descRef_ = &descRef)
                    fixed (void* initialDataRef_ = initialDataRef__)
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, descRef_, initialDataRef_, &texture3DOut_,((void**)(*(void**)_nativePointer))[74]);		
                ((SharpDX.Direct3D10.Texture3D)texture3DOut).NativePointer = texture3DOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Create a shader-resource view for accessing data in a resource.</p>	
        /// </summary>	
        /// <param name="resourceRef">No documentation.</param>	
        /// <param name="descRef">No documentation.</param>	
        /// <param name="sRViewOut">No documentation.</param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>A resource is made up of one or more subresources, a view identifies which subresources to allow the pipeline to access. In addition, each resource is bound to the pipeline using a view. A shader-resource view is designed to bind any buffer or texture resource to the shader stages using the following API methods: <strong>VSSetShaderResources</strong>, <strong>GSSetShaderResources</strong> and <strong>PSSetShaderResources</strong>.</p><p>Since a view is fully typed, this means that typeless resources become fully typed when bound to the pipeline.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::CreateShaderResourceView']/*"/>	
        /// <msdn-id>bb173558</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::CreateShaderResourceView([In] ID3D10Resource* pResource,[In, Optional] const D3D10_SHADER_RESOURCE_VIEW_DESC* pDesc,[Out, Fast] ID3D10ShaderResourceView** ppSRView)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::CreateShaderResourceView</unmanaged-short>	
        internal void CreateShaderResourceView(SharpDX.Direct3D10.Resource resourceRef, SharpDX.Direct3D10.ShaderResourceViewDescription? descRef, SharpDX.Direct3D10.ShaderResourceView sRViewOut) {
            unsafe {
                SharpDX.Direct3D10.ShaderResourceViewDescription descRef_;
                if (descRef.HasValue)
                    descRef_ = descRef.Value;				
                IntPtr sRViewOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer), (descRef.HasValue)?&descRef_:(void*)IntPtr.Zero, &sRViewOut_,((void**)(*(void**)_nativePointer))[75]);		
                ((SharpDX.Direct3D10.ShaderResourceView)sRViewOut).NativePointer = sRViewOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Create a render-target view for accessing resource data.</p>	
        /// </summary>	
        /// <param name="resourceRef">No documentation.</param>	
        /// <param name="descRef">No documentation.</param>	
        /// <param name="rTViewOut">No documentation.</param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>A rendertarget view can be bound to the output merger stage by calling <strong><see cref="SharpDX.Direct3D10.OutputMergerStage.SetRenderTargets"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::CreateRenderTargetView']/*"/>	
        /// <msdn-id>bb173556</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::CreateRenderTargetView([In] ID3D10Resource* pResource,[In, Optional] const D3D10_RENDER_TARGET_VIEW_DESC* pDesc,[Out, Fast] ID3D10RenderTargetView** ppRTView)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::CreateRenderTargetView</unmanaged-short>	
        internal void CreateRenderTargetView(SharpDX.Direct3D10.Resource resourceRef, SharpDX.Direct3D10.RenderTargetViewDescription? descRef, SharpDX.Direct3D10.RenderTargetView rTViewOut) {
            unsafe {
                SharpDX.Direct3D10.RenderTargetViewDescription descRef_;
                if (descRef.HasValue)
                    descRef_ = descRef.Value;				
                IntPtr rTViewOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer), (descRef.HasValue)?&descRef_:(void*)IntPtr.Zero, &rTViewOut_,((void**)(*(void**)_nativePointer))[76]);		
                ((SharpDX.Direct3D10.RenderTargetView)rTViewOut).NativePointer = rTViewOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Create a depth-stencil view for accessing resource data.</p>	
        /// </summary>	
        /// <param name="resourceRef">No documentation.</param>	
        /// <param name="descRef">No documentation.</param>	
        /// <param name="depthStencilViewOut">No documentation.</param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>A depth-stencil view can be bound to the output-merger stage by calling <strong><see cref="SharpDX.Direct3D10.OutputMergerStage.SetRenderTargets"/></strong>.</p><p>For more background information, see the programming guide page about depth stencils.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::CreateDepthStencilView']/*"/>	
        /// <msdn-id>bb173547</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::CreateDepthStencilView([In] ID3D10Resource* pResource,[In, Optional] const D3D10_DEPTH_STENCIL_VIEW_DESC* pDesc,[Out, Fast] ID3D10DepthStencilView** ppDepthStencilView)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::CreateDepthStencilView</unmanaged-short>	
        internal void CreateDepthStencilView(SharpDX.Direct3D10.Resource resourceRef, SharpDX.Direct3D10.DepthStencilViewDescription? descRef, SharpDX.Direct3D10.DepthStencilView depthStencilViewOut) {
            unsafe {
                SharpDX.Direct3D10.DepthStencilViewDescription descRef_;
                if (descRef.HasValue)
                    descRef_ = descRef.Value;				
                IntPtr depthStencilViewOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer), (descRef.HasValue)?&descRef_:(void*)IntPtr.Zero, &depthStencilViewOut_,((void**)(*(void**)_nativePointer))[77]);		
                ((SharpDX.Direct3D10.DepthStencilView)depthStencilViewOut).NativePointer = depthStencilViewOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Create an input-layout object to describe the input-buffer data for the input-assembler stage.</p>	
        /// </summary>	
        /// <param name="inputElementDescsRef">No documentation.</param>	
        /// <param name="numElements">No documentation.</param>	
        /// <param name="shaderBytecodeWithInputSignatureRef">No documentation.</param>	
        /// <param name="bytecodeLength">No documentation.</param>	
        /// <param name="inputLayoutOut">No documentation.</param>	
        /// <returns><p>If the method succeeds, the return code is <see cref="SharpDX.Result.Ok"/>. See Direct3D 10 Return Codes for failing error codes.</p></returns>	
        /// <remarks>	
        /// <p>After creating an input layout object, it must be bound to the input-assembler stage before calling a draw API. See Getting Started with the Input-Assembler Stage (Direct3D 10) for example code.</p><p>Once an input-layout object is created from a shader signature, the input-layout object can be reused with any other shader that has an identical input signature (semantics included). This can simplify the creation of input-layout objects when you are working with many shaders with identical inputs.</p><p>If a data type in the input-layout declaration does not match the data type in a shader-input signature, CreateInputLayout will generate a warning during compilation. The warning is simply to call attention to the fact that the data may be reinterpreted when read from a register. You may either disregard this warning (if reinterpretation is intentional) or make the data types match in both declarations to eliminate the warning.  The Data Conversion Rules overview describes the rules applied for data type conversion.</p><table> <tr><td> <p>Differences between Direct3D 9 and Direct3D 10:</p> <p>Mapping the vertex data to the shader inputs with an input layout is a new way of doing things in Direct3D 10 that improves performance.</p> <p>In Direct3D 10 the vertex data is mapped to the shader inputs when the input layout object is created, whereas in Direct3D 9 this mapping was done at Draw time based on the currently bound vertex declarations, vertex buffers, and vertex shaders. Doing this mapping when the input layout object is created reduces or eliminates extra linkage work for drivers at Draw time because this re-mapping is no longer necessary.</p> </td></tr> </table><p>?</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::CreateInputLayout']/*"/>	
        /// <msdn-id>bb173550</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::CreateInputLayout([In, Buffer] const D3D10_INPUT_ELEMENT_DESC* pInputElementDescs,[In] unsigned int NumElements,[In, Buffer] const void* pShaderBytecodeWithInputSignature,[In] SIZE_T BytecodeLength,[Out, Fast] ID3D10InputLayout** ppInputLayout)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::CreateInputLayout</unmanaged-short>	
        internal void CreateInputLayout(SharpDX.Direct3D10.InputElement[] inputElementDescsRef, int numElements, System.IntPtr shaderBytecodeWithInputSignatureRef, SharpDX.PointerSize bytecodeLength, SharpDX.Direct3D10.InputLayout inputLayoutOut) {
            unsafe {
                SharpDX.Direct3D10.InputElement.__Native[] inputElementDescsRef__ = new SharpDX.Direct3D10.InputElement.__Native[inputElementDescsRef.Length];
                for (int i = 0; i < inputElementDescsRef.Length; i++)
                    inputElementDescsRef[i].__MarshalTo(ref inputElementDescsRef__[i]);				
                IntPtr inputLayoutOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* inputElementDescsRef_ = inputElementDescsRef__)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, inputElementDescsRef_, numElements, (void*)shaderBytecodeWithInputSignatureRef, (void*)bytecodeLength, &inputLayoutOut_,((void**)(*(void**)_nativePointer))[78]);		
                for (int i = 0; i < inputElementDescsRef.Length; i++)
                    inputElementDescsRef[i].__MarshalFree(ref inputElementDescsRef__[i]);
                ((SharpDX.Direct3D10.InputLayout)inputLayoutOut).NativePointer = inputLayoutOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Create a vertex-shader object from a compiled shader.</p>	
        /// </summary>	
        /// <param name="shaderBytecodeRef"><dd>  <p>A reference to the compiled shader. To get this reference see Getting a Pointer to a Compiled Shader.</p> </dd></param>	
        /// <param name="bytecodeLength"><dd>  <p>Size of the compiled vertex shader.</p> </dd></param>	
        /// <param name="vertexShaderOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D10.VertexShader"/> Interface</strong>. If this is <strong><c>null</c></strong>, all other parameters will be validated, and if all parameters pass validation this API will return S_FALSE instead of <see cref="SharpDX.Result.Ok"/>.</p> </dd></param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::CreateVertexShader']/*"/>	
        /// <msdn-id>bb173562</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::CreateVertexShader([In, Buffer] const void* pShaderBytecode,[In] SIZE_T BytecodeLength,[Out, Fast] ID3D10VertexShader** ppVertexShader)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::CreateVertexShader</unmanaged-short>	
        internal void CreateVertexShader(System.IntPtr shaderBytecodeRef, SharpDX.PointerSize bytecodeLength, SharpDX.Direct3D10.VertexShader vertexShaderOut) {
            unsafe {
                IntPtr vertexShaderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)shaderBytecodeRef, (void*)bytecodeLength, &vertexShaderOut_,((void**)(*(void**)_nativePointer))[79]);		
                ((SharpDX.Direct3D10.VertexShader)vertexShaderOut).NativePointer = vertexShaderOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Create a geometry shader.</p>	
        /// </summary>	
        /// <param name="shaderBytecodeRef"><dd>  <p>A reference to the compiled shader. To get this reference see Getting a Pointer to a Compiled Shader.</p> </dd></param>	
        /// <param name="bytecodeLength"><dd>  <p>Size of the compiled geometry shader.</p> </dd></param>	
        /// <param name="geometryShaderOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D10.GeometryShader"/> Interface</strong>.  If this is <strong><c>null</c></strong>, all other parameters will be validated, and if all parameters pass validation this API will return S_FALSE instead of <see cref="SharpDX.Result.Ok"/>.</p> </dd></param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>Once created, the shader can be set to the device by calling <strong><see cref="SharpDX.Direct3D10.GeometryShaderStage.Set"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::CreateGeometryShader']/*"/>	
        /// <msdn-id>bb173548</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::CreateGeometryShader([In, Buffer] const void* pShaderBytecode,[In] SIZE_T BytecodeLength,[Out, Fast] ID3D10GeometryShader** ppGeometryShader)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::CreateGeometryShader</unmanaged-short>	
        internal void CreateGeometryShader(System.IntPtr shaderBytecodeRef, SharpDX.PointerSize bytecodeLength, SharpDX.Direct3D10.GeometryShader geometryShaderOut) {
            unsafe {
                IntPtr geometryShaderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)shaderBytecodeRef, (void*)bytecodeLength, &geometryShaderOut_,((void**)(*(void**)_nativePointer))[80]);		
                ((SharpDX.Direct3D10.GeometryShader)geometryShaderOut).NativePointer = geometryShaderOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a geometry shader that can write to streaming output buffers.</p>	
        /// </summary>	
        /// <param name="shaderBytecodeRef"><dd>  <p>A reference to the compiled geometry shader for a standard geometry shader plus stream output. For info on how to get this reference, see Getting a Pointer to a Compiled Shader.</p> <p>To create the stream output without using a geometry shader, pass a reference to the output signature for the prior stage. To obtain this output signature, call the <strong><see cref="SharpDX.D3DCompiler.D3D.GetOutputSignatureBlob"/></strong> compiler function. You can also pass a reference to the compiled vertex shader that is used in the prior stage. This compiled shader provides the output signature for the data.</p> </dd></param>	
        /// <param name="bytecodeLength"><dd>  <p>Size of the compiled geometry shader.</p> </dd></param>	
        /// <param name="sODeclarationRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D10.StreamOutputElement"/></strong> array. Cannot be <strong><c>null</c></strong> if <em>NumEntries</em>&gt; 0.</p> </dd></param>	
        /// <param name="numEntries"><dd>  <p>The number of entries in the array pointed to by <em>pSODeclaration</em>. Minimum 0, maximum 64.</p> </dd></param>	
        /// <param name="outputStreamStride"><dd>  <p>The size, in bytes, of each element in the array pointed to by <em>pSODeclaration</em>. This parameter is only used when the output slot is 0 for all entries in <em>pSODeclaration</em>.</p> </dd></param>	
        /// <param name="geometryShaderOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D10.GeometryShader"/> Interface</strong>. If this is <strong><c>null</c></strong>, all other parameters will be validated, and if all parameters pass validation this API will return S_FALSE instead of <see cref="SharpDX.Result.Ok"/>.</p> </dd></param>	
        /// <returns><p>This method returns one of the Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>For more info about using <strong>CreateGeometryShaderWithStreamOutput</strong>, see Create a Geometry-Shader Object with Stream Output.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::CreateGeometryShaderWithStreamOutput']/*"/>	
        /// <msdn-id>bb173549</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::CreateGeometryShaderWithStreamOutput([In, Buffer] const void* pShaderBytecode,[In] SIZE_T BytecodeLength,[In, Buffer, Optional] const D3D10_SO_DECLARATION_ENTRY* pSODeclaration,[In] unsigned int NumEntries,[In] unsigned int OutputStreamStride,[Out, Fast] ID3D10GeometryShader** ppGeometryShader)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::CreateGeometryShaderWithStreamOutput</unmanaged-short>	
        internal void CreateGeometryShaderWithStreamOutput(System.IntPtr shaderBytecodeRef, SharpDX.PointerSize bytecodeLength, SharpDX.Direct3D10.StreamOutputElement[] sODeclarationRef, int numEntries, int outputStreamStride, SharpDX.Direct3D10.GeometryShader geometryShaderOut) {
            unsafe {
                SharpDX.Direct3D10.StreamOutputElement.__Native[] sODeclarationRef__ = (sODeclarationRef == null)? null : new SharpDX.Direct3D10.StreamOutputElement.__Native[sODeclarationRef.Length];
				if (sODeclarationRef != null)
                for (int i = 0; i < sODeclarationRef.Length; i++)
                    sODeclarationRef[i].__MarshalTo(ref sODeclarationRef__[i]);				
                IntPtr geometryShaderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* sODeclarationRef_ = sODeclarationRef__)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)shaderBytecodeRef, (void*)bytecodeLength, sODeclarationRef_, numEntries, outputStreamStride, &geometryShaderOut_,((void**)(*(void**)_nativePointer))[81]);		
                if (sODeclarationRef != null )															
                for (int i = 0; i < sODeclarationRef.Length; i++)
                    sODeclarationRef[i].__MarshalFree(ref sODeclarationRef__[i]);
                ((SharpDX.Direct3D10.GeometryShader)geometryShaderOut).NativePointer = geometryShaderOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Create a pixel shader.</p>	
        /// </summary>	
        /// <param name="shaderBytecodeRef"><dd>  <p>A reference to the compiled shader. To get this reference see Getting a Pointer to a Compiled Shader.</p> </dd></param>	
        /// <param name="bytecodeLength"><dd>  <p>Size of the compiled pixel shader.</p> </dd></param>	
        /// <param name="pixelShaderOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D10.PixelShader"/> Interface</strong>. If this is <strong><c>null</c></strong>, all other parameters will be validated, and if all parameters pass validation this API will return S_FALSE instead of <see cref="SharpDX.Result.Ok"/>.</p> </dd></param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>After creating the pixel shader, you can set it to the device using <strong><see cref="SharpDX.Direct3D10.PixelShaderStage.Set"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::CreatePixelShader']/*"/>	
        /// <msdn-id>bb173551</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::CreatePixelShader([In, Buffer] const void* pShaderBytecode,[In] SIZE_T BytecodeLength,[Out, Fast] ID3D10PixelShader** ppPixelShader)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::CreatePixelShader</unmanaged-short>	
        internal void CreatePixelShader(System.IntPtr shaderBytecodeRef, SharpDX.PointerSize bytecodeLength, SharpDX.Direct3D10.PixelShader pixelShaderOut) {
            unsafe {
                IntPtr pixelShaderOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)shaderBytecodeRef, (void*)bytecodeLength, &pixelShaderOut_,((void**)(*(void**)_nativePointer))[82]);		
                ((SharpDX.Direct3D10.PixelShader)pixelShaderOut).NativePointer = pixelShaderOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Create a blend-state object that encapsules blend state for the output-merger stage.</p>	
        /// </summary>	
        /// <param name="blendStateDescRef"><dd>  <p>Pointer to a blend-state description (see <strong><see cref="SharpDX.Direct3D10.BlendStateDescription"/></strong>).</p> </dd></param>	
        /// <param name="blendStateOut"><dd>  <p>Address of a reference to the blend-state object created (see <strong><see cref="SharpDX.Direct3D10.BlendState"/> Interface</strong>).</p> </dd></param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>An application can create up to 4096 unique blend-state objects. For each object created, the runtime checks to see if a previous object has the same state. If such a previous object exists, the runtime will return a reference to previous instance instead of creating a duplicate object.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::CreateBlendState']/*"/>	
        /// <msdn-id>bb173543</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::CreateBlendState([In] const D3D10_BLEND_DESC* pBlendStateDesc,[Out, Fast] ID3D10BlendState** ppBlendState)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::CreateBlendState</unmanaged-short>	
        internal void CreateBlendState(ref SharpDX.Direct3D10.BlendStateDescription blendStateDescRef, SharpDX.Direct3D10.BlendState blendStateOut) {
            unsafe {
                var blendStateDescRef_ = new SharpDX.Direct3D10.BlendStateDescription.__Native();
                blendStateDescRef.__MarshalTo(ref blendStateDescRef_);
                IntPtr blendStateOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &blendStateDescRef_, &blendStateOut_,((void**)(*(void**)_nativePointer))[83]);		
                blendStateDescRef.__MarshalFree(ref blendStateDescRef_);
                ((SharpDX.Direct3D10.BlendState)blendStateOut).NativePointer = blendStateOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Create a depth-stencil state object that encapsulates depth-stencil test information for the output-merger stage.</p>	
        /// </summary>	
        /// <param name="depthStencilDescRef">No documentation.</param>	
        /// <param name="depthStencilStateOut">No documentation.</param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>4096 unique depth-stencil state objects can be created on a device at a time.</p><p>If an application attempts to create a depth-stencil state with the same description as an already existing depth-stencil state, then the same interface with an incremented reference count will be returned and the total number of unique depth-stencil state objects will stay the same.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::CreateDepthStencilState']/*"/>	
        /// <msdn-id>bb173546</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::CreateDepthStencilState([In] const D3D10_DEPTH_STENCIL_DESC* pDepthStencilDesc,[Out, Fast] ID3D10DepthStencilState** ppDepthStencilState)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::CreateDepthStencilState</unmanaged-short>	
        internal void CreateDepthStencilState(ref SharpDX.Direct3D10.DepthStencilStateDescription depthStencilDescRef, SharpDX.Direct3D10.DepthStencilState depthStencilStateOut) {
            unsafe {
                IntPtr depthStencilStateOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* depthStencilDescRef_ = &depthStencilDescRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, depthStencilDescRef_, &depthStencilStateOut_,((void**)(*(void**)_nativePointer))[84]);		
                ((SharpDX.Direct3D10.DepthStencilState)depthStencilStateOut).NativePointer = depthStencilStateOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Create a rasterizer state object that tells the rasterizer stage how to behave.</p>	
        /// </summary>	
        /// <param name="rasterizerDescRef">No documentation.</param>	
        /// <param name="rasterizerStateOut">No documentation.</param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>4096 unique rasterizer state objects can be created on a device at a time.</p><p>If an application attempts to create a rasterizer state with the same description as an already existing rasterizer state, then the same interface with an incremented reference count will be returned and the total number of unique rasterizer state objects will stay the same.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::CreateRasterizerState']/*"/>	
        /// <msdn-id>bb173554</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::CreateRasterizerState([In] const D3D10_RASTERIZER_DESC* pRasterizerDesc,[Out, Fast] ID3D10RasterizerState** ppRasterizerState)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::CreateRasterizerState</unmanaged-short>	
        internal void CreateRasterizerState(ref SharpDX.Direct3D10.RasterizerStateDescription rasterizerDescRef, SharpDX.Direct3D10.RasterizerState rasterizerStateOut) {
            unsafe {
                IntPtr rasterizerStateOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* rasterizerDescRef_ = &rasterizerDescRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, rasterizerDescRef_, &rasterizerStateOut_,((void**)(*(void**)_nativePointer))[85]);		
                ((SharpDX.Direct3D10.RasterizerState)rasterizerStateOut).NativePointer = rasterizerStateOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Create a sampler-state object that encapsulates sampling information for a texture.</p>	
        /// </summary>	
        /// <param name="samplerDescRef">No documentation.</param>	
        /// <param name="samplerStateOut">No documentation.</param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>4096 unique sampler state objects can be created on a device at a time.</p><p>If an application attempts to create a sampler state with the same description as an already existing sampler state, then the same interface with an incremented reference count will be returned and the total number of unique sampler state objects will stay the same.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::CreateSamplerState']/*"/>	
        /// <msdn-id>bb173557</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::CreateSamplerState([In] const D3D10_SAMPLER_DESC* pSamplerDesc,[Out, Fast] ID3D10SamplerState** ppSamplerState)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::CreateSamplerState</unmanaged-short>	
        internal void CreateSamplerState(ref SharpDX.Direct3D10.SamplerStateDescription samplerDescRef, SharpDX.Direct3D10.SamplerState samplerStateOut) {
            unsafe {
                IntPtr samplerStateOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                fixed (void* samplerDescRef_ = &samplerDescRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, samplerDescRef_, &samplerStateOut_,((void**)(*(void**)_nativePointer))[86]);		
                ((SharpDX.Direct3D10.SamplerState)samplerStateOut).NativePointer = samplerStateOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>This interface encapsulates methods for querying information from the GPU.</p>	
        /// </summary>	
        /// <param name="queryDescRef"><dd>  <p>Pointer to a query description (see <strong><see cref="SharpDX.Direct3D11.QueryDescription"/></strong>).</p> </dd></param>	
        /// <param name="queryOut"><dd>  <p>Address of a reference to the query object created (see <strong><see cref="SharpDX.Direct3D11.Query"/></strong>).</p> </dd></param>	
        /// <returns><p>This method returns E_OUTOFMEMORY if there is insufficient memory to create the query object.   See Direct3D 11 Return Codes for other possible return values.</p></returns>	
        /// <remarks>	
        /// <p><strong>Windows?Phone?8:</strong> This API is supported.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::CreateQuery']/*"/>	
        /// <msdn-id>ff476515</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::CreateQuery([In] const D3D10_QUERY_DESC* pQueryDesc,[Out, Fast] ID3D10Query** ppQuery)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::CreateQuery</unmanaged-short>	
        internal void CreateQuery(SharpDX.Direct3D10.QueryDescription queryDescRef, SharpDX.Direct3D10.Query queryOut) {
            unsafe {
                IntPtr queryOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &queryDescRef, &queryOut_,((void**)(*(void**)_nativePointer))[87]);		
                ((SharpDX.Direct3D10.Query)queryOut).NativePointer = queryOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Creates a predicate.</p>	
        /// </summary>	
        /// <param name="predicateDescRef"><dd>  <p>Pointer to a query description where the type of query must be a <see cref="SharpDX.Direct3D10.QueryType.StreamOutputOverflowPredicate"/> or <see cref="SharpDX.Direct3D10.QueryType.OcclusionPredicate"/> (see <strong><see cref="SharpDX.Direct3D10.QueryDescription"/></strong>).</p> </dd></param>	
        /// <param name="predicateOut"><dd>  <p>Address of a reference to a predicate (see <strong><see cref="SharpDX.Direct3D10.Predicate"/> Interface</strong>).</p> </dd></param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::CreatePredicate']/*"/>	
        /// <msdn-id>bb173552</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::CreatePredicate([In] const D3D10_QUERY_DESC* pPredicateDesc,[Out, Fast] ID3D10Predicate** ppPredicate)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::CreatePredicate</unmanaged-short>	
        internal void CreatePredicate(SharpDX.Direct3D10.QueryDescription predicateDescRef, SharpDX.Direct3D10.Predicate predicateOut) {
            unsafe {
                IntPtr predicateOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &predicateDescRef, &predicateOut_,((void**)(*(void**)_nativePointer))[88]);		
                ((SharpDX.Direct3D10.Predicate)predicateOut).NativePointer = predicateOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Create a counter object for measuring GPU performance.</p>	
        /// </summary>	
        /// <param name="counterDescRef"><dd>  <p>Pointer to a counter description (see <strong><see cref="SharpDX.Direct3D10.CounterDescription"/></strong>).</p> </dd></param>	
        /// <param name="counterOut"><dd>  <p>Address of a reference to a counter (see <strong><see cref="SharpDX.Direct3D10.Counter"/> Interface</strong>).</p> </dd></param>	
        /// <returns><p>If this function succeeds, it will return <see cref="SharpDX.Result.Ok"/>. If it fails, possible return values are: S_FALSE, E_OUTOFMEMORY, <see cref="SharpDX.DXGI.ResultCode.Unsupported"/>, <see cref="SharpDX.DXGI.ResultCode.Nonexclusive"/>, or E_INVALIDARG.</p><p><see cref="SharpDX.DXGI.ResultCode.Unsupported"/> is returned whenever the application requests to create a well-known counter, but the current device does not support it.</p><p><see cref="SharpDX.DXGI.ResultCode.Nonexclusive"/> indicates that another device object is currently using the counters, so they cannot be used by this device at the moment.</p><p>E_INVALIDARG is returned whenever an out-of-range well-known or device-dependent counter is requested, or when the simulataneously active counters have been exhausted.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::CreateCounter']/*"/>	
        /// <msdn-id>bb173545</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::CreateCounter([In] const D3D10_COUNTER_DESC* pCounterDesc,[Out, Fast] ID3D10Counter** ppCounter)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::CreateCounter</unmanaged-short>	
        internal void CreateCounter(SharpDX.Direct3D10.CounterDescription counterDescRef, SharpDX.Direct3D10.Counter counterOut) {
            unsafe {
                IntPtr counterOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &counterDescRef, &counterOut_,((void**)(*(void**)_nativePointer))[89]);		
                ((SharpDX.Direct3D10.Counter)counterOut).NativePointer = counterOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get the support of a given format on the installed video device.</p>	
        /// </summary>	
        /// <param name="format"><dd>  <p>A <strong><see cref="SharpDX.DXGI.Format"/></strong> enumeration that describes a format for which to check for support.</p> </dd></param>	
        /// <returns><dd>  <p>A bitfield of <strong><see cref="SharpDX.Direct3D10.FormatSupport"/></strong> enumeration values describing how the specified format is supported on the installed device.  The values are ORed together.</p> </dd></returns>	
        /// <remarks>	
        /// <p>Most format support is based on the Direct3D feature level. Only a few specific use cases require checking for support.  See Hardware Support for Direct3D 10 Formats and Hardware Support for Direct3D 10.1 Formats for additional information.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::CheckFormatSupport']/*"/>	
        /// <msdn-id>bb173536</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::CheckFormatSupport([In] DXGI_FORMAT Format,[Out] D3D10_FORMAT_SUPPORT* pFormatSupport)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::CheckFormatSupport</unmanaged-short>	
        public SharpDX.Direct3D10.FormatSupport CheckFormatSupport(SharpDX.DXGI.Format format) {
            unsafe {
                SharpDX.Direct3D10.FormatSupport formatSupportRef;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, unchecked((int)format), &formatSupportRef,((void**)(*(void**)_nativePointer))[90]);		
                return formatSupportRef;
            }
        }
        
        /// <summary>	
        /// <p>Get the number of quality levels available during multisampling.</p>	
        /// </summary>	
        /// <param name="format"><dd>  <p>The texture format. See <strong><see cref="SharpDX.DXGI.Format"/></strong>.</p> </dd></param>	
        /// <param name="sampleCount"><dd>  <p>The number of samples during multisampling.</p> </dd></param>	
        /// <returns><dd>  <p>Number of quality levels supported by the adapter. See remarks.</p> </dd></returns>	
        /// <remarks>	
        /// <p>When multisampling a texture, the number of quality levels available for an adapter is dependent on the texture format used and the number of samples requested. The maximum sample count defined by D3D10_MAX_MULTISAMPLE_SAMPLE_COUNT in d3d10.h is 32. If the returned value of <em>pNumQualityLevels</em> is 0, the format and sample count combination is not supported for the installed adapter.</p><p>Furthermore, the definition of a quality level is up to each hardware vendor to define, however no facility is provided by Direct3D to help discover  this information.</p><p>Direct3D 10.1 devices are required to support 4x MSAA for all formats except R32G32B32A32 and R32G32B32 formats.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::CheckMultisampleQualityLevels']/*"/>	
        /// <msdn-id>bb173537</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::CheckMultisampleQualityLevels([In] DXGI_FORMAT Format,[In] unsigned int SampleCount,[Out] unsigned int* pNumQualityLevels)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::CheckMultisampleQualityLevels</unmanaged-short>	
        public int CheckMultisampleQualityLevels(SharpDX.DXGI.Format format, int sampleCount) {
            unsafe {
                int numQualityLevelsRef;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, unchecked((int)format), sampleCount, &numQualityLevelsRef,((void**)(*(void**)_nativePointer))[91]);		
                return numQualityLevelsRef;
            }
        }
        
        /// <summary>	
        /// <p>Get a counter's information.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::CheckCounterInfo']/*"/>	
        /// <msdn-id>bb173535</msdn-id>	
        /// <unmanaged>void ID3D10Device::CheckCounterInfo([Out] D3D10_COUNTER_INFO* pCounterInfo)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::CheckCounterInfo</unmanaged-short>	
        public SharpDX.Direct3D10.CounterCapabilities GetCounterCapabilities() {
            unsafe {
                SharpDX.Direct3D10.CounterCapabilities counterInfoRef;
                counterInfoRef = new SharpDX.Direct3D10.CounterCapabilities();
                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, &counterInfoRef,((void**)(*(void**)_nativePointer))[92]);		
                return counterInfoRef;
            }
        }
        
        /// <summary>	
        /// <p>Get the type, name, units of measure, and a description of an existing counter.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p>Pointer to a counter description (see <strong><see cref="SharpDX.Direct3D10.CounterDescription"/></strong>). Specifies which counter information is to be retrieved about.</p> </dd></param>	
        /// <param name="typeRef"><dd>  <p>Pointer to the data type of a counter (see <strong><see cref="SharpDX.Direct3D10.CounterType"/></strong>). Specifies the data type of the counter being retrieved.</p> </dd></param>	
        /// <param name="activeCountersRef"><dd>  <p>Pointer to the number of hardware counters that are needed for this counter type to be created. All instances of the same counter type use the same hardware counters.</p> </dd></param>	
        /// <param name="szName"><dd>  <p>String to be filled with a brief name for the counter. May be <strong><c>null</c></strong> if the application is not interested in the name of the counter.</p> </dd></param>	
        /// <param name="nameLengthRef"><dd>  <p>Length of the string returned to szName. Can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="szUnits"><dd>  <p>Name of the units a counter measures, provided the memory the reference points to has enough room to hold the string. Can be <strong><c>null</c></strong>. The returned string will always be in English.</p> </dd></param>	
        /// <param name="unitsLengthRef"><dd>  <p>Length of the string returned to szUnits. Can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <param name="szDescription"><dd>  <p>A description of the counter, provided the memory the reference points to has enough room to hold the string. Can be <strong><c>null</c></strong>. The returned string will always be in English.</p> </dd></param>	
        /// <param name="descriptionLengthRef"><dd>  <p>Length of the string returned to szDescription. Can be <strong><c>null</c></strong>.</p> </dd></param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>Length parameters can be <strong><c>null</c></strong>, which indicates the application is not interested in the length nor the corresponding string value. When a length parameter is non-<strong><c>null</c></strong> and the corresponding string is <strong><c>null</c></strong>, the input value of the length parameter is ignored, and the length of the corresponding string (including terminating <strong><c>null</c></strong>) will be returned through the length parameter. When length and the corresponding parameter are both non-<strong><c>null</c></strong>, the input value of length is checked to ensure there is enough room, and then the length of the string (including terminating <strong><c>null</c></strong> character) is passed out through the length parameter.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::CheckCounter']/*"/>	
        /// <msdn-id>bb173534</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::CheckCounter([In] const D3D10_COUNTER_DESC* pDesc,[Out] D3D10_COUNTER_TYPE* pType,[Out] unsigned int* pActiveCounters,[Out, Buffer, Optional] char* szName,[InOut, Optional] unsigned int* pNameLength,[Out, Buffer, Optional] char* szUnits,[InOut, Optional] unsigned int* pUnitsLength,[Out, Buffer, Optional] char* szDescription,[InOut, Optional] unsigned int* pDescriptionLength)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::CheckCounter</unmanaged-short>	
        internal void CheckCounter(SharpDX.Direct3D10.CounterDescription descRef, out SharpDX.Direct3D10.CounterType typeRef, out int activeCountersRef, System.IntPtr szName, System.IntPtr nameLengthRef, System.IntPtr szUnits, System.IntPtr unitsLengthRef, System.IntPtr szDescription, System.IntPtr descriptionLengthRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* typeRef_ = &typeRef)
                    fixed (void* activeCountersRef_ = &activeCountersRef)
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &descRef, typeRef_, activeCountersRef_, (void*)szName, (void*)nameLengthRef, (void*)szUnits, (void*)unitsLengthRef, (void*)szDescription, (void*)descriptionLengthRef,((void**)(*(void**)_nativePointer))[93]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get the flags used during the call to create the device with <strong><see cref="SharpDX.Direct3D10.D3D10.CreateDevice"/></strong>.</p>	
        /// </summary>	
        /// <returns><p>A bitfield containing the flags used to create the device. See <strong><see cref="SharpDX.Direct3D10.DeviceCreationFlags"/></strong>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::GetCreationFlags']/*"/>	
        /// <msdn-id>bb173570</msdn-id>	
        /// <unmanaged>unsigned int ID3D10Device::GetCreationFlags()</unmanaged>	
        /// <unmanaged-short>ID3D10Device::GetCreationFlags</unmanaged-short>	
        internal SharpDX.Direct3D10.DeviceCreationFlags GetCreationFlags() {
            unsafe {
                SharpDX.Direct3D10.DeviceCreationFlags __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.CalliSharpDXDirect3D10DeviceCreationFlags(_nativePointer,((void**)(*(void**)_nativePointer))[94]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Give a device access to a shared resource created on a different Direct3d device. </p>	
        /// </summary>	
        /// <param name="hResource"><dd>  <p>A resource handle. See remarks.</p> </dd></param>	
        /// <param name="returnedInterface"><dd>  <p>The globally unique identifier (<see cref="System.Guid"/>) for the resource interface. See remarks.</p> </dd></param>	
        /// <param name="resourceOut"><dd>  <p>Address of a reference to the resource we are gaining access to.</p> </dd></param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>To share a resource between two Direct3D 10 devices the resource must have been created with the  <strong><see cref="SharpDX.Direct3D10.ResourceOptionFlags.Shared"/></strong> flag, if it was created using the <see cref="SharpDX.Direct3D10.Device"/> interface.  If it was created using the <see cref="SharpDX.DXGI.Device"/> interface, then the resource is always shared.</p><p>The REFIID, or <see cref="System.Guid"/>, of the interface to the resource can be obtained by using the __uuidof() macro.  For example, __uuidof(<see cref="SharpDX.Direct3D10.Buffer"/>) will get the <see cref="System.Guid"/> of the interface to a buffer resource.</p><p>When sharing a resource between two Direct3D 10 devices the unique handle of the resource can be obtained by querying the resource for the <strong><see cref="SharpDX.DXGI.Resource"/></strong> interface and then calling <strong>GetSharedHandle</strong>.</p><pre> <see cref="SharpDX.DXGI.Resource"/>* pOtherResource(<c>null</c>);	
        /// hr = pOtherDeviceResource-&gt;QueryInterface( __uuidof(<see cref="SharpDX.DXGI.Resource"/>), (void**)&amp;pOtherResource );	
        /// HANDLE sharedHandle;	
        /// pOtherResource-&gt;GetSharedHandle(&amp;sharedHandle); </pre><p>The only resources that can be shared are 2D non-mipmapped textures.</p><p>To share a resource between a Direct3D 9 device and a Direct3D 10 device the texture must have been created using  the <em>pSharedHandle</em> argument of <strong>CreateTexture</strong>.   The shared Direct3D 9 handle is then passed to OpenSharedResource in the <em>hResource</em> argument.</p><p>The following code illustrates the method calls involved.</p><pre> sharedHandle = <c>null</c>; // must be set to <c>null</c> to create, can use a valid handle here to open in D3D9 	
        /// pDevice9-&gt;CreateTexture(..., pTex2D_9, &amp;sharedHandle); 	
        /// ... 	
        /// pDevice10-&gt;OpenSharedResource(sharedHandle, __uuidof(<see cref="SharpDX.Direct3D10.Resource"/>), (void**)(&amp;tempResource10)); 	
        /// tempResource10-&gt;QueryInterface(__uuidof(<see cref="SharpDX.Direct3D10.Texture2D"/>), (void**)(&amp;pTex2D_10)); 	
        /// tempResource10-&gt;Release(); 	
        /// // now use pTex2D_10 with pDevice10    </pre><p>Textures being shared from D3D9 to D3D10 have the following restrictions.</p><ul> <li>Textures must be 2D</li> <li>Only 1 mip level is allowed</li> <li>Texture must have default usage</li> <li>Texture must be write only</li> <li>MSAA textures are not allowed</li> <li>Bind flags must have SHADER_RESOURCE and RENDER_TARGET set</li> <li>Only R10G10B10A2_UNORM, R16G16B16A16_FLOAT and R8G8B8A8_UNORM formats are allowed</li> </ul><p>If a shared texture is updated on one device <strong><see cref="SharpDX.Direct3D10.Device.Flush"/></strong> must be called on that device.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::OpenSharedResource']/*"/>	
        /// <msdn-id>bb173598</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device::OpenSharedResource([In] void* hResource,[In] const GUID&amp; ReturnedInterface,[Out, Optional] void** ppResource)</unmanaged>	
        /// <unmanaged-short>ID3D10Device::OpenSharedResource</unmanaged-short>	
        internal void OpenSharedResource(System.IntPtr hResource, System.Guid returnedInterface, out System.IntPtr resourceOut) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* resourceOut_ = &resourceOut)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)hResource, &returnedInterface, resourceOut_,((void**)(*(void**)_nativePointer))[95]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>The device interface represents a virtual adapter for Direct3D 10.1; it is used to perform rendering and create Direct3D resources.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>A device is created using <strong><see cref="SharpDX.Direct3D10.D3D10.CreateDevice1"/></strong>.</p><p>This method requires Windows Vista Service Pack 1.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device1']/*"/>	
    /// <msdn-id>bb694546</msdn-id>	
    /// <unmanaged>ID3D10Device1</unmanaged>	
    /// <unmanaged-short>ID3D10Device1</unmanaged-short>	
    [Guid("9B7E4C8F-342C-4106-A19F-4F2704F689F0")]
    public partial class Device1 : SharpDX.Direct3D10.Device {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.Device1"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Device1(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.Device1"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.Device1(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.Device1(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Gets the feature level of the hardware device.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method requires Windows Vista Service Pack 1.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device1::GetFeatureLevel']/*"/>	
        /// <msdn-id>bb694549</msdn-id>	
        /// <unmanaged>GetFeatureLevel</unmanaged>	
        /// <unmanaged-short>GetFeatureLevel</unmanaged-short>	
        /// <unmanaged>D3D10_FEATURE_LEVEL1 ID3D10Device1::GetFeatureLevel()</unmanaged>
        public SharpDX.Direct3D10.FeatureLevel FeatureLevel {
                get { return GetFeatureLevel(); }
        }
        
        /// <summary>	
        /// <p>Create a shader-resource view for accessing data in a resource.</p>	
        /// </summary>	
        /// <param name="resourceRef">No documentation.</param>	
        /// <param name="descRef">No documentation.</param>	
        /// <param name="sRViewOut">No documentation.</param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>A resource is made up of one or more subresources, a view identifies which subresources to allow the pipeline to access. In addition, each resource is bound to the pipeline using a view. A shader-resource view is designed to bind any buffer or texture resource to the shader stages using the following API methods: <strong>VSSetShaderResources</strong>, <strong>GSSetShaderResources</strong> and <strong>PSSetShaderResources</strong>.</p><p>Since a view is fully typed, this means that typeless resources become fully typed when bound to the pipeline.</p><p>This method requires Windows Vista Service Pack 1.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device1::CreateShaderResourceView1']/*"/>	
        /// <msdn-id>bb694548</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device1::CreateShaderResourceView1([In] ID3D10Resource* pResource,[In, Optional] const D3D10_SHADER_RESOURCE_VIEW_DESC1* pDesc,[Out, Fast] ID3D10ShaderResourceView1** ppSRView)</unmanaged>	
        /// <unmanaged-short>ID3D10Device1::CreateShaderResourceView1</unmanaged-short>	
        internal void CreateShaderResourceView1(SharpDX.Direct3D10.Resource resourceRef, SharpDX.Direct3D10.ShaderResourceViewDescription1? descRef, SharpDX.Direct3D10.ShaderResourceView1 sRViewOut) {
            unsafe {
                SharpDX.Direct3D10.ShaderResourceViewDescription1 descRef_;
                if (descRef.HasValue)
                    descRef_ = descRef.Value;				
                IntPtr sRViewOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer), (descRef.HasValue)?&descRef_:(void*)IntPtr.Zero, &sRViewOut_,((void**)(*(void**)_nativePointer))[98]);		
                ((SharpDX.Direct3D10.ShaderResourceView1)sRViewOut).NativePointer = sRViewOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Create a blend-state object that encapsules blend state for the output-merger stage.</p>	
        /// </summary>	
        /// <param name="blendStateDescRef"><dd>  <p>Pointer to a blend-state description (see <strong><see cref="SharpDX.Direct3D10.BlendStateDescription1"/></strong>).</p> </dd></param>	
        /// <param name="blendStateOut"><dd>  <p>Address of a reference to the blend-state object created (see <strong><see cref="SharpDX.Direct3D10.BlendState1"/> Interface</strong>).</p> </dd></param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>An application can create up to 4096 unique blend-state objects. For each object created, the runtime checks to see if a previous object has the same state. If such a previous object exists, the runtime will return a reference to previous instance instead of creating a duplicate object.</p><p>This method requires Windows Vista Service Pack 1.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device1::CreateBlendState1']/*"/>	
        /// <msdn-id>bb694547</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Device1::CreateBlendState1([In] const D3D10_BLEND_DESC1* pBlendStateDesc,[Out, Fast] ID3D10BlendState1** ppBlendState)</unmanaged>	
        /// <unmanaged-short>ID3D10Device1::CreateBlendState1</unmanaged-short>	
        internal void CreateBlendState1(ref SharpDX.Direct3D10.BlendStateDescription1 blendStateDescRef, SharpDX.Direct3D10.BlendState1 blendStateOut) {
            unsafe {
                var blendStateDescRef_ = new SharpDX.Direct3D10.BlendStateDescription1.__Native();
                blendStateDescRef.__MarshalTo(ref blendStateDescRef_);
                IntPtr blendStateOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &blendStateDescRef_, &blendStateOut_,((void**)(*(void**)_nativePointer))[99]);		
                blendStateDescRef.__MarshalFree(ref blendStateDescRef_);
                ((SharpDX.Direct3D10.BlendState1)blendStateOut).NativePointer = blendStateOut_;
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Gets the feature level of the hardware device.</p>	
        /// </summary>	
        /// <returns><p>The feature level (see <strong><see cref="SharpDX.Direct3D10.FeatureLevel"/></strong>).</p></returns>	
        /// <remarks>	
        /// <p>This method requires Windows Vista Service Pack 1.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device1::GetFeatureLevel']/*"/>	
        /// <msdn-id>bb694549</msdn-id>	
        /// <unmanaged>D3D10_FEATURE_LEVEL1 ID3D10Device1::GetFeatureLevel()</unmanaged>	
        /// <unmanaged-short>ID3D10Device1::GetFeatureLevel</unmanaged-short>	
        internal SharpDX.Direct3D10.FeatureLevel GetFeatureLevel() {
            unsafe {
                SharpDX.Direct3D10.FeatureLevel __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.CalliSharpDXDirect3D10FeatureLevel(_nativePointer,((void**)(*(void**)_nativePointer))[100]);		
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>A device-child interface accesses data used by a device.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>There are several types of device child interfaces, all of which inherit this interface. They include shaders, state objects, and input layouts.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10DeviceChild']/*"/>	
    /// <msdn-id>bb173529</msdn-id>	
    /// <unmanaged>ID3D10DeviceChild</unmanaged>	
    /// <unmanaged-short>ID3D10DeviceChild</unmanaged-short>	
    [Guid("9B7E4C00-342C-4106-A19F-4F2704F689F0")]
    public partial class DeviceChild : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.DeviceChild"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DeviceChild(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.DeviceChild"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.DeviceChild(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.DeviceChild(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Get a reference to the device that created this interface.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Any returned interfaces will have their reference count incremented by one, so be sure to call ::release() on the returned reference(s) before they are freed or else you will have a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10DeviceChild::GetDevice']/*"/>	
        /// <msdn-id>bb173530</msdn-id>	
        /// <unmanaged>GetDevice</unmanaged>	
        /// <unmanaged-short>GetDevice</unmanaged-short>	
        /// <unmanaged>void ID3D10DeviceChild::GetDevice([Out] ID3D10Device** ppDevice)</unmanaged>
        public SharpDX.Direct3D10.Device Device {
                get { SharpDX.Direct3D10.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Get a reference to the device that created this interface.</p>	
        /// </summary>	
        /// <param name="deviceOut"><dd>  <p>Address of a reference to a device (see <strong><see cref="SharpDX.Direct3D10.Device"/> Interface</strong>).</p> </dd></param>	
        /// <remarks>	
        /// <p>Any returned interfaces will have their reference count incremented by one, so be sure to call ::release() on the returned reference(s) before they are freed or else you will have a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10DeviceChild::GetDevice']/*"/>	
        /// <msdn-id>bb173530</msdn-id>	
        /// <unmanaged>void ID3D10DeviceChild::GetDevice([Out] ID3D10Device** ppDevice)</unmanaged>	
        /// <unmanaged-short>ID3D10DeviceChild::GetDevice</unmanaged-short>	
        internal void GetDevice(out SharpDX.Direct3D10.Device deviceOut) {
            unsafe {
                IntPtr deviceOut_ = IntPtr.Zero;
                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, &deviceOut_,((void**)(*(void**)_nativePointer))[3]);		
                deviceOut= (deviceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.Device(deviceOut_);	
            }
        }
        
        /// <summary>	
        /// <p>Get application-defined data from a device child.</p>	
        /// </summary>	
        /// <param name="guid"><dd>  <p>Guid associated with the data.</p> </dd></param>	
        /// <param name="dataSizeRef"><dd>  <p>Size of the data.</p> </dd></param>	
        /// <param name="dataRef"><dd>  <p>Pointer to the data stored with the device child. If pData is <strong><c>null</c></strong>, DataSize must also be 0, and any data previously associated with the guid will be destroyed.</p> </dd></param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>The data stored in the device child is set with <strong><see cref="SharpDX.Direct3D10.DeviceChild.SetPrivateData"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10DeviceChild::GetPrivateData']/*"/>	
        /// <msdn-id>bb173531</msdn-id>	
        /// <unmanaged>HRESULT ID3D10DeviceChild::GetPrivateData([In] const GUID&amp; guid,[InOut] unsigned int* pDataSize,[Out, Buffer, Optional] void* pData)</unmanaged>	
        /// <unmanaged-short>ID3D10DeviceChild::GetPrivateData</unmanaged-short>	
        public SharpDX.Result GetPrivateData(System.Guid guid, ref int dataSizeRef, System.IntPtr dataRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dataSizeRef_ = &dataSizeRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &guid, dataSizeRef_, (void*)dataRef,((void**)(*(void**)_nativePointer))[4]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Set application-defined data to a device child and associate that data with an application-defined guid.</p>	
        /// </summary>	
        /// <param name="guid"><dd>  <p>Guid associated with the data.</p> </dd></param>	
        /// <param name="dataSize"><dd>  <p>Size of the data.</p> </dd></param>	
        /// <param name="dataRef"><dd>  <p>Pointer to the data to be stored with this device child. If pData is <strong><c>null</c></strong>, DataSize must also be 0, and any data previously associated with the specified guid will be destroyed.</p> </dd></param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>The data stored in the device child with this method can be retrieved with <strong><see cref="SharpDX.Direct3D10.DeviceChild.GetPrivateData"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10DeviceChild::SetPrivateData']/*"/>	
        /// <msdn-id>bb173532</msdn-id>	
        /// <unmanaged>HRESULT ID3D10DeviceChild::SetPrivateData([In] const GUID&amp; guid,[In] unsigned int DataSize,[In, Buffer, Optional] const void* pData)</unmanaged>	
        /// <unmanaged-short>ID3D10DeviceChild::SetPrivateData</unmanaged-short>	
        public void SetPrivateData(System.Guid guid, int dataSize, System.IntPtr dataRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &guid, dataSize, (void*)dataRef,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Associate an <see cref="SharpDX.ComObject"/>-derived interface with this device child and associate that interface with an application-defined guid.</p>	
        /// </summary>	
        /// <param name="guid">No documentation.</param>	
        /// <param name="dataRef">No documentation.</param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>When this method is called ::addref() will be called on the <see cref="SharpDX.ComObject"/>-derived interface, and when the device child is detroyed ::release() will be called on the <see cref="SharpDX.ComObject"/>-derived interface.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10DeviceChild::SetPrivateDataInterface']/*"/>	
        /// <msdn-id>bb173533</msdn-id>	
        /// <unmanaged>HRESULT ID3D10DeviceChild::SetPrivateDataInterface([In] const GUID&amp; guid,[In, Optional] const IUnknown* pData)</unmanaged>	
        /// <unmanaged-short>ID3D10DeviceChild::SetPrivateDataInterface</unmanaged-short>	
        public void SetPrivateDataInterface(System.Guid guid, SharpDX.ComObject dataRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &guid, (void*)((dataRef == null)?IntPtr.Zero:dataRef.NativePointer),((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>A debug interface controls debug settings, validates pipeline state and can only be used if the debug layer is turned on.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>This interface is obtained by querying it from the <strong><see cref="SharpDX.Direct3D10.Device"/> Interface</strong> using IUnknown::QueryInterface.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Debug']/*"/>	
    /// <msdn-id>bb173516</msdn-id>	
    /// <unmanaged>ID3D10Debug</unmanaged>	
    /// <unmanaged-short>ID3D10Debug</unmanaged-short>	
    [Guid("9B7E4E01-342C-4106-A19F-4F2704F689F0")]
    public partial class DeviceDebug : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.DeviceDebug"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public DeviceDebug(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.DeviceDebug"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.DeviceDebug(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.DeviceDebug(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Get or sets the number of milliseconds to sleep after <strong>Present</strong> is called.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Value is set with <strong><see cref="SharpDX.Direct3D10.DeviceDebug.SetPresentPerRenderOpDelay"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Debug::GetPresentPerRenderOpDelay']/*"/>	
        /// <msdn-id>bb173518</msdn-id>	
        /// <unmanaged>GetPresentPerRenderOpDelay / SetPresentPerRenderOpDelay</unmanaged>	
        /// <unmanaged-short>GetPresentPerRenderOpDelay</unmanaged-short>	
        /// <unmanaged>unsigned int ID3D10Debug::GetPresentPerRenderOpDelay()</unmanaged>
        public int PresentPerRenderOpDelay {
                get { return GetPresentPerRenderOpDelay(); }
                set { SetPresentPerRenderOpDelay(value); }
        }
        
        /// <summary>	
        /// <p>Get or sets the swap chain that the runtime will use for automatically calling <strong>Present</strong>.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The swap chain retrieved by this method will only be used if <see cref="SharpDX.Direct3D10.DebugFeatureFlags.PresentPerRender"/> is set in the <strong>feature mask</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Debug::GetSwapChain']/*"/>	
        /// <msdn-id>bb173519</msdn-id>	
        /// <unmanaged>GetSwapChain / SetSwapChain</unmanaged>	
        /// <unmanaged-short>GetSwapChain</unmanaged-short>	
        /// <unmanaged>HRESULT ID3D10Debug::GetSwapChain([Out] IDXGISwapChain** ppSwapChain)</unmanaged>
        public SharpDX.DXGI.SwapChain SwapChain {
                get { SharpDX.DXGI.SwapChain __output__; GetSwapChain(out __output__); return __output__; }
                set { SetSwapChain(value); }
        }
        
        /// <summary>	
        /// <p>Set a bitfield of flags that will turn debug features on and off.</p>	
        /// </summary>	
        /// <param name="mask"><dd>  <p>Feature-mask flags bitwise ORed together. If a flag is present, then that feature will be set to on, otherwise the feature will be set to off. See remarks for a list of flags.</p> </dd></param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p><strong>Note</strong>??If you call this API in a Session 0 process, it returns <strong><see cref="SharpDX.DXGI.ResultCode.NotCurrentlyAvailable"/></strong>.</p><p>Setting a feature-mask flag will cause a rendering-operation method (listed below) to do some extra task when called. The possible feature flags are:</p><table> <tr><td><see cref="SharpDX.Direct3D10.DebugFeatureFlags.FinishPerRender"/></td><td>Application will wait for the GPU to finish processing the rendering operation before continuing.</td></tr> <tr><td><see cref="SharpDX.Direct3D10.DebugFeatureFlags.FlushPerRender"/></td><td>Runtime will additionally call <strong><see cref="SharpDX.Direct3D10.Device.Flush"/></strong>.</td></tr> <tr><td><see cref="SharpDX.Direct3D10.DebugFeatureFlags.PresentPerRender"/></td><td>Runtime will call <strong>Present</strong>. Presentation of render buffers will occur according to the settings established by prior calls to <strong><see cref="SharpDX.Direct3D10.DeviceDebug.SetSwapChain"/></strong> and <strong><see cref="SharpDX.Direct3D10.DeviceDebug.SetPresentPerRenderOpDelay"/></strong>.</td></tr> </table><p>?</p><p>These feature-mask flags apply to the following rendering-operation methods:</p><ul> <li> <strong><see cref="SharpDX.Direct3D10.Device.Draw"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D10.Device.DrawIndexed"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D10.Device.DrawInstanced"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D10.Device.DrawIndexedInstanced"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D10.Device.DrawAuto"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D10.Device.ClearRenderTargetView"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D10.Device.ClearDepthStencilView"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D10.Device.CopySubresourceRegion_"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D10.Device.CopyResource_"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D10.Device.UpdateSubresource"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D10.Device.GenerateMips"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D10.Device.ResolveSubresource_"/></strong> </li> </ul>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Debug::SetFeatureMask']/*"/>	
        /// <msdn-id>bb173520</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Debug::SetFeatureMask([In] unsigned int Mask)</unmanaged>	
        /// <unmanaged-short>ID3D10Debug::SetFeatureMask</unmanaged-short>	
        internal void SetFeatureFlags(int mask) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, mask,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get a bitfield of flags that indicates which debug features are on or off.</p>	
        /// </summary>	
        /// <returns><p>Mask of feature-mask flags bitwise ORed together. If a flag is present, then that feature will be set to on, otherwise the feature will be set to off. See <strong><see cref="SharpDX.Direct3D10.DeviceDebug.SetFeatureFlags"/></strong> for a list of possible feature-mask flags.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Debug::GetFeatureMask']/*"/>	
        /// <msdn-id>bb173517</msdn-id>	
        /// <unmanaged>unsigned int ID3D10Debug::GetFeatureMask()</unmanaged>	
        /// <unmanaged-short>ID3D10Debug::GetFeatureMask</unmanaged-short>	
        internal int GetFeatureFlags() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Set the number of milliseconds to sleep after <strong>Present</strong> is called.</p>	
        /// </summary>	
        /// <param name="milliseconds">No documentation.</param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p><strong>Note</strong>??If you call this API in a Session 0 process, it returns <strong><see cref="SharpDX.DXGI.ResultCode.NotCurrentlyAvailable"/></strong>.</p><p>The application will only sleep if <see cref="SharpDX.Direct3D10.DebugFeatureFlags.PresentPerRender"/> is a set in the <strong>feature mask</strong>. If that flag is not set the number of milliseconds is set but ignored and the application does not sleep. 10ms is used as a default value if this method is never called.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Debug::SetPresentPerRenderOpDelay']/*"/>	
        /// <msdn-id>bb173521</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Debug::SetPresentPerRenderOpDelay([In] unsigned int Milliseconds)</unmanaged>	
        /// <unmanaged-short>ID3D10Debug::SetPresentPerRenderOpDelay</unmanaged-short>	
        internal void SetPresentPerRenderOpDelay(int milliseconds) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, milliseconds,((void**)(*(void**)_nativePointer))[5]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get the number of milliseconds to sleep after <strong>Present</strong> is called.</p>	
        /// </summary>	
        /// <returns><p>Number of milliseconds to sleep after Present is called.</p></returns>	
        /// <remarks>	
        /// <p>Value is set with <strong><see cref="SharpDX.Direct3D10.DeviceDebug.SetPresentPerRenderOpDelay"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Debug::GetPresentPerRenderOpDelay']/*"/>	
        /// <msdn-id>bb173518</msdn-id>	
        /// <unmanaged>unsigned int ID3D10Debug::GetPresentPerRenderOpDelay()</unmanaged>	
        /// <unmanaged-short>ID3D10Debug::GetPresentPerRenderOpDelay</unmanaged-short>	
        internal int GetPresentPerRenderOpDelay() {
            unsafe {
                int __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[6]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Set a swap chain that the runtime will use for automatically calling <strong>Present</strong>.</p>	
        /// </summary>	
        /// <param name="swapChainRef">No documentation.</param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p><strong>Note</strong>??If you call this API in a Session 0 process, it returns <strong><see cref="SharpDX.DXGI.ResultCode.NotCurrentlyAvailable"/></strong>.</p><p>The swap chain set by this method will only be used if <see cref="SharpDX.Direct3D10.DebugFeatureFlags.PresentPerRender"/> is set in the <strong>feature mask</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Debug::SetSwapChain']/*"/>	
        /// <msdn-id>bb173522</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Debug::SetSwapChain([In, Optional] IDXGISwapChain* pSwapChain)</unmanaged>	
        /// <unmanaged-short>ID3D10Debug::SetSwapChain</unmanaged-short>	
        internal void SetSwapChain(SharpDX.DXGI.SwapChain swapChainRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)((swapChainRef == null)?IntPtr.Zero:swapChainRef.NativePointer),((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get the swap chain that the runtime will use for automatically calling <strong>Present</strong>.</p>	
        /// </summary>	
        /// <param name="swapChainOut">No documentation.</param>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>The swap chain retrieved by this method will only be used if <see cref="SharpDX.Direct3D10.DebugFeatureFlags.PresentPerRender"/> is set in the <strong>feature mask</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Debug::GetSwapChain']/*"/>	
        /// <msdn-id>bb173519</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Debug::GetSwapChain([Out] IDXGISwapChain** ppSwapChain)</unmanaged>	
        /// <unmanaged-short>ID3D10Debug::GetSwapChain</unmanaged-short>	
        internal void GetSwapChain(out SharpDX.DXGI.SwapChain swapChainOut) {
            unsafe {
                IntPtr swapChainOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &swapChainOut_,((void**)(*(void**)_nativePointer))[8]);		
                swapChainOut= (swapChainOut_ == IntPtr.Zero)?null:new SharpDX.DXGI.SwapChain(swapChainOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Check the validity of pipeline state.</p>	
        /// </summary>	
        /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>When the debug layer is turned on all draw functions will do this operation.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Debug::Validate']/*"/>	
        /// <msdn-id>bb173523</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Debug::Validate()</unmanaged>	
        /// <unmanaged-short>ID3D10Debug::Validate</unmanaged-short>	
        public void Validate() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[9]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>An <strong><see cref="SharpDX.Direct3D10.Effect"/></strong> interface manages a set of state objects, resources, and shaders for implementing a rendering effect.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>An effect is created by calling <strong><see cref="SharpDX.Direct3D10.D3D10.CreateEffectFromMemory"/></strong>.</p><p>The effect system groups the information required for rendering into an effect which contains: state objects for assigning state changes in groups, resources for supplying input data and storing output data, and programs that control how the rendering is done called shaders. For more information, see Effects (Direct3D 10).</p><p><strong>Note</strong>??</p><p>If you call <strong>QueryInterface</strong> on an <strong><see cref="SharpDX.Direct3D10.Effect"/></strong> object to retrieve the <strong><see cref="SharpDX.ComObject"/></strong> interface, <strong>QueryInterface</strong> returns E_NOINTERFACE. To work around this issue, use the following code:</p><pre> <see cref="SharpDX.ComObject"/>* pIUnknown = (<see cref="SharpDX.ComObject"/>*)pEffect; pIUnknown-&gt;AddRef();	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Effect']/*"/>	
    /// <msdn-id>bb173630</msdn-id>	
    /// <unmanaged>ID3D10Effect</unmanaged>	
    /// <unmanaged-short>ID3D10Effect</unmanaged-short>	
    [Guid("51b0ca8b-ec0b-4519-870d-8ee1cb5017c7")]
    public partial class Effect : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.Effect"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Effect(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.Effect"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.Effect(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.Effect(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Test an effect to see if it contains valid syntax.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Effect::IsValid']/*"/>	
        /// <msdn-id>bb173772</msdn-id>	
        /// <unmanaged>IsValid</unmanaged>	
        /// <unmanaged-short>IsValid</unmanaged-short>	
        /// <unmanaged>BOOL ID3D10Effect::IsValid()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsValid {
                get { return IsValid_(); }
        }
        
        /// <summary>	
        /// <p>Test an effect to see if it is part of a memory pool.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Effect::IsPool']/*"/>	
        /// <msdn-id>bb173771</msdn-id>	
        /// <unmanaged>IsPool</unmanaged>	
        /// <unmanaged-short>IsPool</unmanaged-short>	
        /// <unmanaged>BOOL ID3D10Effect::IsPool()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsPool {
                get { return IsPool_(); }
        }
        
        /// <summary>	
        /// <p>Get the device that created the effect.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>An effect is created for a specific device, by calling a function such as <strong><see cref="SharpDX.Direct3D10.D3DX10.CreateEffectFromFile"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Effect::GetDevice']/*"/>	
        /// <msdn-id>bb173764</msdn-id>	
        /// <unmanaged>GetDevice</unmanaged>	
        /// <unmanaged-short>GetDevice</unmanaged-short>	
        /// <unmanaged>HRESULT ID3D10Effect::GetDevice([Out] ID3D10Device** ppDevice)</unmanaged>
        public SharpDX.Direct3D10.Device Device {
                get { SharpDX.Direct3D10.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Get an effect description.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>An effect description contains basic information about an effect such as the techniques it contains and the constant buffer resources it requires.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Effect::GetDesc']/*"/>	
        /// <msdn-id>bb173763</msdn-id>	
        /// <unmanaged>GetDesc</unmanaged>	
        /// <unmanaged-short>GetDesc</unmanaged-short>	
        /// <unmanaged>HRESULT ID3D10Effect::GetDesc([Out] D3D10_EFFECT_DESC* pDesc)</unmanaged>
        public SharpDX.Direct3D10.EffectDescription Description {
                get { SharpDX.Direct3D10.EffectDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Test an effect to see if the reflection metadata has been removed from memory.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>An effect uses memory space two different ways: to store the information required by the runtime to execute an effect, and to store the metadata required to reflect information back to an application using the API. You can minimize the amount of memory required by an effect by calling <strong><see cref="SharpDX.Direct3D10.Effect.Optimize"/></strong> which removes the reflection metadata from memory. Of course, API methods to read variables will no longer work once reflection data has been removed.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Effect::IsOptimized']/*"/>	
        /// <msdn-id>bb173770</msdn-id>	
        /// <unmanaged>IsOptimized</unmanaged>	
        /// <unmanaged-short>IsOptimized</unmanaged-short>	
        /// <unmanaged>BOOL ID3D10Effect::IsOptimized()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsOptimized {
                get { return IsOptimized_(); }
        }
        
        /// <summary>	
        /// <p>Test an effect to see if it contains valid syntax.</p>	
        /// </summary>	
        /// <returns><p><strong>TRUE</strong> if the code syntax is valid; otherwise <strong><see cref="SharpDX.Result.False"/></strong>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Effect::IsValid']/*"/>	
        /// <msdn-id>bb173772</msdn-id>	
        /// <unmanaged>BOOL ID3D10Effect::IsValid()</unmanaged>	
        /// <unmanaged-short>ID3D10Effect::IsValid</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool IsValid_() {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer,((void**)(*(void**)_nativePointer))[3]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Test an effect to see if it is part of a memory pool.</p>	
        /// </summary>	
        /// <returns><p><strong>TRUE</strong> if the effect is pooled; otherwise <strong><see cref="SharpDX.Result.False"/></strong>. See <strong><see cref="SharpDX.Direct3D10.EffectPool"/> Interface</strong>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Effect::IsPool']/*"/>	
        /// <msdn-id>bb173771</msdn-id>	
        /// <unmanaged>BOOL ID3D10Effect::IsPool()</unmanaged>	
        /// <unmanaged-short>ID3D10Effect::IsPool</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool IsPool_() {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get the device that created the effect.</p>	
        /// </summary>	
        /// <param name="deviceOut"><dd>  <p>A reference to an <strong><see cref="SharpDX.Direct3D10.Device"/> Interface</strong>.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>An effect is created for a specific device, by calling a function such as <strong><see cref="SharpDX.Direct3D10.D3DX10.CreateEffectFromFile"/></strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Effect::GetDevice']/*"/>	
        /// <msdn-id>bb173764</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Effect::GetDevice([Out] ID3D10Device** ppDevice)</unmanaged>	
        /// <unmanaged-short>ID3D10Effect::GetDevice</unmanaged-short>	
        internal void GetDevice(out SharpDX.Direct3D10.Device deviceOut) {
            unsafe {
                IntPtr deviceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &deviceOut_,((void**)(*(void**)_nativePointer))[5]);		
                deviceOut= (deviceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.Device(deviceOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get an effect description.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p>A reference to an effect description (see <strong><see cref="SharpDX.Direct3D10.EffectDescription"/></strong>).</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>An effect description contains basic information about an effect such as the techniques it contains and the constant buffer resources it requires.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Effect::GetDesc']/*"/>	
        /// <msdn-id>bb173763</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Effect::GetDesc([Out] D3D10_EFFECT_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3D10Effect::GetDesc</unmanaged-short>	
        internal void GetDescription(out SharpDX.Direct3D10.EffectDescription descRef) {
            unsafe {
                descRef = new SharpDX.Direct3D10.EffectDescription();
                SharpDX.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, descRef_,((void**)(*(void**)_nativePointer))[6]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get a constant buffer by index.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>A zero-based index.</p> </dd></param>	
        /// <returns><p>A reference to a <strong><see cref="SharpDX.Direct3D10.EffectConstantBuffer"/> Interface</strong>.</p></returns>	
        /// <remarks>	
        /// <p>An effect that contains a variable that will be read/written by an application requires at least one constant buffer. For best performance, an effect should organize variables into one or more constant buffers based on their frequency of update.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Effect::GetConstantBufferByIndex']/*"/>	
        /// <msdn-id>bb173761</msdn-id>	
        /// <unmanaged>ID3D10EffectConstantBuffer* ID3D10Effect::GetConstantBufferByIndex([In] unsigned int Index)</unmanaged>	
        /// <unmanaged-short>ID3D10Effect::GetConstantBufferByIndex</unmanaged-short>	
        public SharpDX.Direct3D10.EffectConstantBuffer GetConstantBufferByIndex(int index) {
            unsafe {
                SharpDX.Direct3D10.EffectConstantBuffer __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectConstantBuffer((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer, index,((void**)(*(void**)_nativePointer))[7]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a constant buffer by name.</p>	
        /// </summary>	
        /// <param name="name"><dd>  <p>The constant-buffer name.</p> </dd></param>	
        /// <returns><p>A reference to the constant buffer indicated by the Name. See <strong><see cref="SharpDX.Direct3D10.EffectConstantBuffer"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>An effect that contains a variable that will be read/written by an application requires at least one constant buffer. For best performance, an effect should organize variables into one or more constant buffers based on their frequency of update.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Effect::GetConstantBufferByName']/*"/>	
        /// <msdn-id>bb173762</msdn-id>	
        /// <unmanaged>ID3D10EffectConstantBuffer* ID3D10Effect::GetConstantBufferByName([In] const char* Name)</unmanaged>	
        /// <unmanaged-short>ID3D10Effect::GetConstantBufferByName</unmanaged-short>	
        public SharpDX.Direct3D10.EffectConstantBuffer GetConstantBufferByName(string name) {
            unsafe {
                IntPtr name_ = Utilities.StringToHGlobalAnsi(name);
                SharpDX.Direct3D10.EffectConstantBuffer __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectConstantBuffer((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer, (void*)name_,((void**)(*(void**)_nativePointer))[8]));		
                Marshal.FreeHGlobal(name_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a variable by index.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>A zero-based index.</p> </dd></param>	
        /// <returns><p>A reference to a <strong><see cref="SharpDX.Direct3D10.EffectVariable"/> Interface</strong>.</p></returns>	
        /// <remarks>	
        /// <p>An effect may contain one or more variables. Variables outside of a technique are considered global to all effects, those located inside of a technique are local to that technique. You can access any local non-static effect variable using its name or with an index.</p><p>The method returns a reference to an <strong>effect-variable interface</strong> if a variable is not found; you can call <strong><see cref="SharpDX.Direct3D10.Effect.IsValid_"/></strong> to verify whether or not the index exists.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Effect::GetVariableByIndex']/*"/>	
        /// <msdn-id>bb173767</msdn-id>	
        /// <unmanaged>ID3D10EffectVariable* ID3D10Effect::GetVariableByIndex([In] unsigned int Index)</unmanaged>	
        /// <unmanaged-short>ID3D10Effect::GetVariableByIndex</unmanaged-short>	
        public SharpDX.Direct3D10.EffectVariable GetVariableByIndex(int index) {
            unsafe {
                SharpDX.Direct3D10.EffectVariable __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectVariable((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer, index,((void**)(*(void**)_nativePointer))[9]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a variable by name.</p>	
        /// </summary>	
        /// <param name="name"><dd>  <p>The variable name.</p> </dd></param>	
        /// <returns><p>A reference to an <strong><see cref="SharpDX.Direct3D10.EffectVariable"/> Interface</strong>.</p></returns>	
        /// <remarks>	
        /// <p>An effect may contain one or more variables. Variables outside of a technique are considered global to all effects, those located inside of a technique are local to that technique. You can access an effect variable using its name or with an index.</p><p>The method returns a reference to an <strong>effect-variable interface</strong> if a variable is not found; you can call <strong><see cref="SharpDX.Direct3D10.Effect.IsValid_"/></strong> to verify whether or not the name exists.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Effect::GetVariableByName']/*"/>	
        /// <msdn-id>bb173768</msdn-id>	
        /// <unmanaged>ID3D10EffectVariable* ID3D10Effect::GetVariableByName([In] const char* Name)</unmanaged>	
        /// <unmanaged-short>ID3D10Effect::GetVariableByName</unmanaged-short>	
        public SharpDX.Direct3D10.EffectVariable GetVariableByName(string name) {
            unsafe {
                IntPtr name_ = Utilities.StringToHGlobalAnsi(name);
                SharpDX.Direct3D10.EffectVariable __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectVariable((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer, (void*)name_,((void**)(*(void**)_nativePointer))[10]));		
                Marshal.FreeHGlobal(name_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a variable by semantic.</p>	
        /// </summary>	
        /// <param name="semantic"><dd>  <p>The semantic name.</p> </dd></param>	
        /// <returns><p>A reference to the effect variable indicated by the Semantic. See <strong><see cref="SharpDX.Direct3D10.EffectVariable"/> Interface</strong>.</p></returns>	
        /// <remarks>	
        /// <p>Each effect variable can have a semantic attached, which is a user defined metadata string. Some system-value semantics are reserved words that trigger built in functionality by pipeline stages.</p><p>The method returns a reference to an <strong>effect-variable interface</strong> if a variable is not found; you can call <strong><see cref="SharpDX.Direct3D10.Effect.IsValid_"/></strong> to verify whether or not the semantic exists.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Effect::GetVariableBySemantic']/*"/>	
        /// <msdn-id>bb173769</msdn-id>	
        /// <unmanaged>ID3D10EffectVariable* ID3D10Effect::GetVariableBySemantic([In] const char* Semantic)</unmanaged>	
        /// <unmanaged-short>ID3D10Effect::GetVariableBySemantic</unmanaged-short>	
        public SharpDX.Direct3D10.EffectVariable GetVariableBySemantic(string semantic) {
            unsafe {
                IntPtr semantic_ = Utilities.StringToHGlobalAnsi(semantic);
                SharpDX.Direct3D10.EffectVariable __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectVariable((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer, (void*)semantic_,((void**)(*(void**)_nativePointer))[11]));		
                Marshal.FreeHGlobal(semantic_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a technique by index.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>A zero-based index.</p> </dd></param>	
        /// <returns><p>A reference to an <strong><see cref="SharpDX.Direct3D10.EffectTechnique"/> Interface</strong>.</p></returns>	
        /// <remarks>	
        /// <p>An effect contains one or more techniques; each technique contains one or more passes. You can access a technique using its name or with an index.  For more about techniques, see techniques and passes.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Effect::GetTechniqueByIndex']/*"/>	
        /// <msdn-id>bb173765</msdn-id>	
        /// <unmanaged>ID3D10EffectTechnique* ID3D10Effect::GetTechniqueByIndex([In] unsigned int Index)</unmanaged>	
        /// <unmanaged-short>ID3D10Effect::GetTechniqueByIndex</unmanaged-short>	
        public SharpDX.Direct3D10.EffectTechnique GetTechniqueByIndex(int index) {
            unsafe {
                SharpDX.Direct3D10.EffectTechnique __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectTechnique((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer, index,((void**)(*(void**)_nativePointer))[12]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a technique by name.</p>	
        /// </summary>	
        /// <param name="name"><dd>  <p>The name of the technique.</p> </dd></param>	
        /// <returns><p>A reference to an <strong><see cref="SharpDX.Direct3D10.EffectTechnique"/> Interface</strong>, or <strong><c>null</c></strong> if the technique is not found.</p></returns>	
        /// <remarks>	
        /// <p>An effect contains one or more techniques; each technique contains one or more passes. You can access a technique using its name or with an index. For more about techniques, see techniques and passes.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Effect::GetTechniqueByName']/*"/>	
        /// <msdn-id>bb173766</msdn-id>	
        /// <unmanaged>ID3D10EffectTechnique* ID3D10Effect::GetTechniqueByName([In] const char* Name)</unmanaged>	
        /// <unmanaged-short>ID3D10Effect::GetTechniqueByName</unmanaged-short>	
        public SharpDX.Direct3D10.EffectTechnique GetTechniqueByName(string name) {
            unsafe {
                IntPtr name_ = Utilities.StringToHGlobalAnsi(name);
                SharpDX.Direct3D10.EffectTechnique __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectTechnique((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer, (void*)name_,((void**)(*(void**)_nativePointer))[13]));		
                Marshal.FreeHGlobal(name_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Minimize the amount of memory required for an effect.</p>	
        /// </summary>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>An effect uses memory space two different ways: to store the information required by the runtime to execute an effect, and to store the metadata  required to reflect information back to an application using the API. You can minimize the amount of memory required by an effect by  calling <strong><see cref="SharpDX.Direct3D10.Effect.Optimize"/></strong> which removes the reflection metadata from memory. API methods to read variables will no  longer work once reflection data has been removed.</p><p>The following methods will fail after Optimize has been called on an effect.</p><ul> <li> <strong><see cref="SharpDX.Direct3D10.Effect.GetConstantBufferByIndex"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D10.Effect.GetConstantBufferByName"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D10.Effect.GetDescription"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D10.Effect.GetDevice"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D10.Effect.GetTechniqueByIndex"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D10.Effect.GetTechniqueByName"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D10.Effect.GetVariableByIndex"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D10.Effect.GetVariableByName"/></strong> </li> <li> <strong><see cref="SharpDX.Direct3D10.Effect.GetVariableBySemantic"/></strong> </li> </ul><p>Note that references retrieved with these methods before calling <strong><see cref="SharpDX.Direct3D10.Effect.Optimize"/></strong> are still valid  after <strong><see cref="SharpDX.Direct3D10.Effect.Optimize"/></strong> is called.  This allows the application to get all the variables, techniques, and passes it will use,  call Optimize, and then use the effect.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Effect::Optimize']/*"/>	
        /// <msdn-id>bb173773</msdn-id>	
        /// <unmanaged>HRESULT ID3D10Effect::Optimize()</unmanaged>	
        /// <unmanaged-short>ID3D10Effect::Optimize</unmanaged-short>	
        public void Optimize() {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[14]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Test an effect to see if the reflection metadata has been removed from memory.</p>	
        /// </summary>	
        /// <returns><p><strong>TRUE</strong> if the effect is optimized; otherwise <strong><see cref="SharpDX.Result.False"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>An effect uses memory space two different ways: to store the information required by the runtime to execute an effect, and to store the metadata required to reflect information back to an application using the API. You can minimize the amount of memory required by an effect by calling <strong><see cref="SharpDX.Direct3D10.Effect.Optimize"/></strong> which removes the reflection metadata from memory. Of course, API methods to read variables will no longer work once reflection data has been removed.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Effect::IsOptimized']/*"/>	
        /// <msdn-id>bb173770</msdn-id>	
        /// <unmanaged>BOOL ID3D10Effect::IsOptimized()</unmanaged>	
        /// <unmanaged-short>ID3D10Effect::IsOptimized</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool IsOptimized_() {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer,((void**)(*(void**)_nativePointer))[15]);		
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>The blend-variable interface accesses blend state.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>An <strong><see cref="SharpDX.Direct3D10.EffectBlendVariable"/> Interface</strong> is created when an effect is read into memory.</p><p>Effect variables are saved in memory in the backing store; when a technique is applied, the values in the backing store are copied to the device. You can use either of these methods to return state. For examples, see Two Ways to Get the State in an Effect Variable.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectBlendVariable']/*"/>	
    /// <msdn-id>bb173631</msdn-id>	
    /// <unmanaged>ID3D10EffectBlendVariable</unmanaged>	
    /// <unmanaged-short>ID3D10EffectBlendVariable</unmanaged-short>	
    [Guid("1fcd2294-df6d-4eae-86b3-0e9160cfb07b")]
    public partial class EffectBlendVariable : SharpDX.Direct3D10.EffectVariable {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.EffectBlendVariable"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EffectBlendVariable(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.EffectBlendVariable"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.EffectBlendVariable(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.EffectBlendVariable(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Get a reference to a blend-state interface.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>Index into an array of blend-state interfaces. If there is only one blend-state interface, use 0.</p> </dd></param>	
        /// <returns><dd>  <p>The address of a reference to a blend-state interface (see <strong><see cref="SharpDX.Direct3D10.BlendState"/> Interface</strong>).</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectBlendVariable::GetBlendState']/*"/>	
        /// <msdn-id>bb173633</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectBlendVariable::GetBlendState([In] unsigned int Index,[Out] ID3D10BlendState** ppBlendState)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectBlendVariable::GetBlendState</unmanaged-short>	
        public SharpDX.Direct3D10.BlendState GetBlendState(int index) {
            unsafe {
                SharpDX.Direct3D10.BlendState blendStateOut;
                IntPtr blendStateOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, index, &blendStateOut_,((void**)(*(void**)_nativePointer))[25]);		
                blendStateOut= (blendStateOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.BlendState(blendStateOut_);	
                __result__.CheckError();
                return blendStateOut;
            }
        }
        
        /// <summary>	
        /// <p>Get a reference to a blend-state variable.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>Index into an array of blend-state descriptions. If there is only one blend-state variable in the effect, use 0.</p> </dd></param>	
        /// <param name="blendDescRef"><dd>  <p>A reference to a blend-state description (see <strong><see cref="SharpDX.Direct3D10.BlendStateDescription"/></strong>).</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>Effect variables are saved in memory in the backing store; when a technique is applied, the values in the backing store are copied to the device. Backing store data can used to recreate the variable when necessary.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectBlendVariable::GetBackingStore']/*"/>	
        /// <msdn-id>bb173632</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectBlendVariable::GetBackingStore([In] unsigned int Index,[Out] D3D10_BLEND_DESC* pBlendDesc)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectBlendVariable::GetBackingStore</unmanaged-short>	
        public void GetBackingStore(int index, out SharpDX.Direct3D10.BlendStateDescription blendDescRef) {
            unsafe {
                var blendDescRef_ = new SharpDX.Direct3D10.BlendStateDescription.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, index, &blendDescRef_,((void**)(*(void**)_nativePointer))[26]);		
                blendDescRef = new SharpDX.Direct3D10.BlendStateDescription();
                blendDescRef.__MarshalFrom(ref blendDescRef_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>A constant-buffer interface accesses constant buffers or texture buffers.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>Use constant buffers to store many effect constants; grouping constants into buffers based on their frequency of update. This allows you to minimize the number of state changes as well as make the fewest API calls to change state. Both of these factors lead to better performance.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectConstantBuffer']/*"/>	
    /// <msdn-id>bb173634</msdn-id>	
    /// <unmanaged>ID3D10EffectConstantBuffer</unmanaged>	
    /// <unmanaged-short>ID3D10EffectConstantBuffer</unmanaged-short>	
    [Guid("56648f4d-cc8b-4444-a5ad-b5a3d76e91b3")]
    public partial class EffectConstantBuffer : SharpDX.Direct3D10.EffectVariable {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.EffectConstantBuffer"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EffectConstantBuffer(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.EffectConstantBuffer"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.EffectConstantBuffer(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.EffectConstantBuffer(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Set a constant-buffer.</p>	
        /// </summary>	
        /// <param name="constantBufferRef"><dd>  <p>A reference to a constant-buffer interface. See <strong><see cref="SharpDX.Direct3D10.Buffer"/> Interface</strong>.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectConstantBuffer::SetConstantBuffer']/*"/>	
        /// <msdn-id>bb173637</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectConstantBuffer::SetConstantBuffer([In, Optional] ID3D10Buffer* pConstantBuffer)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectConstantBuffer::SetConstantBuffer</unmanaged-short>	
        public void SetConstantBuffer(SharpDX.Direct3D10.Buffer constantBufferRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)((constantBufferRef == null)?IntPtr.Zero:constantBufferRef.NativePointer),((void**)(*(void**)_nativePointer))[25]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get a constant-buffer.</p>	
        /// </summary>	
        /// <returns><dd>  <p>The address of a reference to a constant-buffer interface. See <strong><see cref="SharpDX.Direct3D10.Buffer"/> Interface</strong>.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectConstantBuffer::GetConstantBuffer']/*"/>	
        /// <msdn-id>bb173635</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectConstantBuffer::GetConstantBuffer([Out] ID3D10Buffer** ppConstantBuffer)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectConstantBuffer::GetConstantBuffer</unmanaged-short>	
        public SharpDX.Direct3D10.Buffer GetConstantBuffer() {
            unsafe {
                SharpDX.Direct3D10.Buffer constantBufferOut;
                IntPtr constantBufferOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &constantBufferOut_,((void**)(*(void**)_nativePointer))[26]);		
                constantBufferOut= (constantBufferOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.Buffer(constantBufferOut_);	
                __result__.CheckError();
                return constantBufferOut;
            }
        }
        
        /// <summary>	
        /// <p>Set a texture-buffer.</p>	
        /// </summary>	
        /// <param name="textureBufferRef"><dd>  <p>A reference to a shader-resource-view interface for accessing a texture buffer.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectConstantBuffer::SetTextureBuffer']/*"/>	
        /// <msdn-id>bb173638</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectConstantBuffer::SetTextureBuffer([In, Optional] ID3D10ShaderResourceView* pTextureBuffer)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectConstantBuffer::SetTextureBuffer</unmanaged-short>	
        public void SetTextureBuffer(SharpDX.Direct3D10.ShaderResourceView textureBufferRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)((textureBufferRef == null)?IntPtr.Zero:textureBufferRef.NativePointer),((void**)(*(void**)_nativePointer))[27]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get a texture-buffer.</p>	
        /// </summary>	
        /// <returns><dd>  <p>The address of a reference to a shader-resource-view interface for accessing a texture buffer. See <strong><see cref="SharpDX.Direct3D10.ShaderResourceView"/> Interface</strong>.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectConstantBuffer::GetTextureBuffer']/*"/>	
        /// <msdn-id>bb173636</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectConstantBuffer::GetTextureBuffer([Out] ID3D10ShaderResourceView** ppTextureBuffer)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectConstantBuffer::GetTextureBuffer</unmanaged-short>	
        public SharpDX.Direct3D10.ShaderResourceView GetTextureBuffer() {
            unsafe {
                SharpDX.Direct3D10.ShaderResourceView textureBufferOut;
                IntPtr textureBufferOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &textureBufferOut_,((void**)(*(void**)_nativePointer))[28]);		
                textureBufferOut= (textureBufferOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.ShaderResourceView(textureBufferOut_);	
                __result__.CheckError();
                return textureBufferOut;
            }
        }
    }
    /// <summary>	
    /// <p>A depth-stencil-variable interface accesses depth-stencil state.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>An <strong><see cref="SharpDX.Direct3D10.EffectDepthStencilVariable"/> Interface</strong> is created when an effect is read into memory.</p><p>Effect variables are saved in memory in the backing store; when a technique is applied, the values in the backing store are copied to the device. You can use either of these methods to return state. For examples, see Two Ways to Get the State in an Effect Variable.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectDepthStencilVariable']/*"/>	
    /// <msdn-id>bb173639</msdn-id>	
    /// <unmanaged>ID3D10EffectDepthStencilVariable</unmanaged>	
    /// <unmanaged-short>ID3D10EffectDepthStencilVariable</unmanaged-short>	
    [Guid("af482368-330a-46a5-9a5c-01c71af24c8d")]
    public partial class EffectDepthStencilVariable : SharpDX.Direct3D10.EffectVariable {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.EffectDepthStencilVariable"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EffectDepthStencilVariable(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.EffectDepthStencilVariable"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.EffectDepthStencilVariable(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.EffectDepthStencilVariable(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Get a reference to a depth-stencil interface.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>Index into an array of depth-stencil interfaces. If there is only one depth-stencil interface, use 0.</p> </dd></param>	
        /// <returns><dd>  <p>The address of a reference to a blend-state interface (see <strong><see cref="SharpDX.Direct3D10.DepthStencilState"/> Interface</strong>).</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectDepthStencilVariable::GetDepthStencilState']/*"/>	
        /// <msdn-id>bb173641</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectDepthStencilVariable::GetDepthStencilState([In] unsigned int Index,[Out] ID3D10DepthStencilState** ppDepthStencilState)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectDepthStencilVariable::GetDepthStencilState</unmanaged-short>	
        public SharpDX.Direct3D10.DepthStencilState GetDepthStencilState(int index) {
            unsafe {
                SharpDX.Direct3D10.DepthStencilState depthStencilStateOut;
                IntPtr depthStencilStateOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, index, &depthStencilStateOut_,((void**)(*(void**)_nativePointer))[25]);		
                depthStencilStateOut= (depthStencilStateOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.DepthStencilState(depthStencilStateOut_);	
                __result__.CheckError();
                return depthStencilStateOut;
            }
        }
        
        /// <summary>	
        /// <p>Get a reference to a variable that contains depth-stencil state.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>Index into an array of depth-stencil-state descriptions. If there is only one depth-stencil variable in the effect, use 0.</p> </dd></param>	
        /// <returns><dd>  <p>A reference to a depth-stencil-state description (see <strong><see cref="SharpDX.Direct3D10.DepthStencilStateDescription"/></strong>).</p> </dd></returns>	
        /// <remarks>	
        /// <p>Effect variables are saved in memory in the backing store; when a technique is applied, the values in the backing store are copied to the device. Backing store data can used to recreate the variable when necessary.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectDepthStencilVariable::GetBackingStore']/*"/>	
        /// <msdn-id>bb173640</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectDepthStencilVariable::GetBackingStore([In] unsigned int Index,[Out] D3D10_DEPTH_STENCIL_DESC* pDepthStencilDesc)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectDepthStencilVariable::GetBackingStore</unmanaged-short>	
        public SharpDX.Direct3D10.DepthStencilStateDescription GetBackingStore(int index) {
            unsafe {
                SharpDX.Direct3D10.DepthStencilStateDescription depthStencilDescRef;
                depthStencilDescRef = new SharpDX.Direct3D10.DepthStencilStateDescription();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, index, &depthStencilDescRef,((void**)(*(void**)_nativePointer))[26]);		
                __result__.CheckError();
                return depthStencilDescRef;
            }
        }
    }
    /// <summary>	
    /// <p>A depth-stencil-view-variable interface accesses a depth-stencil view.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectDepthStencilViewVariable']/*"/>	
    /// <msdn-id>bb173642</msdn-id>	
    /// <unmanaged>ID3D10EffectDepthStencilViewVariable</unmanaged>	
    /// <unmanaged-short>ID3D10EffectDepthStencilViewVariable</unmanaged-short>	
    [Guid("3e02c918-cc79-4985-b622-2d92ad701623")]
    public partial class EffectDepthStencilViewVariable : SharpDX.Direct3D10.EffectVariable {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.EffectDepthStencilViewVariable"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EffectDepthStencilViewVariable(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.EffectDepthStencilViewVariable"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.EffectDepthStencilViewVariable(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.EffectDepthStencilViewVariable(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Set a depth-stencil-view resource.</p>	
        /// </summary>	
        /// <param name="resourceRef"><dd>  <p>A reference to a depth-stencil-view interface. See <strong><see cref="SharpDX.Direct3D10.DepthStencilView"/> Interface</strong>.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectDepthStencilViewVariable::SetDepthStencil']/*"/>	
        /// <msdn-id>bb173645</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectDepthStencilViewVariable::SetDepthStencil([In, Optional] ID3D10DepthStencilView* pResource)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectDepthStencilViewVariable::SetDepthStencil</unmanaged-short>	
        public void SetDepthStencil(SharpDX.Direct3D10.DepthStencilView resourceRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer),((void**)(*(void**)_nativePointer))[25]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get a depth-stencil-view resource.</p>	
        /// </summary>	
        /// <returns><dd>  <p>The address of a reference to a depth-stencil-view interface. See <strong><see cref="SharpDX.Direct3D10.DepthStencilView"/> Interface</strong>.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectDepthStencilViewVariable::GetDepthStencil']/*"/>	
        /// <msdn-id>bb173643</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectDepthStencilViewVariable::GetDepthStencil([Out] ID3D10DepthStencilView** ppResource)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectDepthStencilViewVariable::GetDepthStencil</unmanaged-short>	
        public SharpDX.Direct3D10.DepthStencilView GetDepthStencil() {
            unsafe {
                SharpDX.Direct3D10.DepthStencilView resourceOut;
                IntPtr resourceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &resourceOut_,((void**)(*(void**)_nativePointer))[26]);		
                resourceOut= (resourceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.DepthStencilView(resourceOut_);	
                __result__.CheckError();
                return resourceOut;
            }
        }
        
        /// <summary>	
        /// <p>Set an array of depth-stencil-view resources.</p>	
        /// </summary>	
        /// <param name="resourcesOut"><dd>  <p>A reference to an array of depth-stencil-view interfaces. See <strong><see cref="SharpDX.Direct3D10.DepthStencilView"/> Interface</strong>.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>The zero-based array index to set the first interface.</p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of elements in the array.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectDepthStencilViewVariable::SetDepthStencilArray']/*"/>	
        /// <msdn-id>bb173646</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectDepthStencilViewVariable::SetDepthStencilArray([In, Buffer] ID3D10DepthStencilView** ppResources,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectDepthStencilViewVariable::SetDepthStencilArray</unmanaged-short>	
        internal void SetDepthStencilArray(SharpDX.Direct3D10.DepthStencilView[] resourcesOut, int offset, int count) {
            unsafe {
                IntPtr* resourcesOut_ = (IntPtr*)0;
                if ( resourcesOut != null ) {
                    IntPtr* resourcesOut__ = stackalloc IntPtr[resourcesOut.Length];
                    resourcesOut_ = resourcesOut__;
                    for (int i = 0; i < resourcesOut.Length; i++)                        
                        resourcesOut_[i] =  (resourcesOut[i] == null)? IntPtr.Zero : resourcesOut[i].NativePointer;
                }
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, resourcesOut_, offset, count,((void**)(*(void**)_nativePointer))[27]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Set an array of depth-stencil-view resources.</p>	
        /// </summary>	
        /// <param name="resourcesOut"><dd>  <p>A reference to an array of depth-stencil-view interfaces. See <strong><see cref="SharpDX.Direct3D10.DepthStencilView"/> Interface</strong>.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>The zero-based array index to set the first interface.</p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of elements in the array.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectDepthStencilViewVariable::SetDepthStencilArray']/*"/>	
        /// <msdn-id>bb173646</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectDepthStencilViewVariable::SetDepthStencilArray([In, Buffer] ID3D10DepthStencilView** ppResources,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectDepthStencilViewVariable::SetDepthStencilArray</unmanaged-short>	
        internal void SetDepthStencilArray(SharpDX.ComArray<SharpDX.Direct3D10.DepthStencilView> resourcesOut, int offset, int count) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)((resourcesOut == null)?IntPtr.Zero:resourcesOut.NativePointer), offset, count,((void**)(*(void**)_nativePointer))[27]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Set an array of depth-stencil-view resources.</p>	
        /// </summary>	
        /// <param name="resourcesOut"><dd>  <p>A reference to an array of depth-stencil-view interfaces. See <strong><see cref="SharpDX.Direct3D10.DepthStencilView"/> Interface</strong>.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>The zero-based array index to set the first interface.</p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of elements in the array.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectDepthStencilViewVariable::SetDepthStencilArray']/*"/>	
        /// <msdn-id>bb173646</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectDepthStencilViewVariable::SetDepthStencilArray([In, Buffer] ID3D10DepthStencilView** ppResources,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectDepthStencilViewVariable::SetDepthStencilArray</unmanaged-short>	
        private void SetDepthStencilArray(System.IntPtr resourcesOut, int offset, int count) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)resourcesOut, offset, count,((void**)(*(void**)_nativePointer))[27]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get an array of depth-stencil-view resources.</p>	
        /// </summary>	
        /// <param name="resourcesOut"><dd>  <p>A reference to an array of depth-stencil-view interfaces. See <strong><see cref="SharpDX.Direct3D10.DepthStencilView"/> Interface</strong>.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>The zero-based array index to get the first interface.</p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of elements in the array.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectDepthStencilViewVariable::GetDepthStencilArray']/*"/>	
        /// <msdn-id>bb173644</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectDepthStencilViewVariable::GetDepthStencilArray([Out, Buffer] ID3D10DepthStencilView** ppResources,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectDepthStencilViewVariable::GetDepthStencilArray</unmanaged-short>	
        internal void GetDepthStencilArray(SharpDX.Direct3D10.DepthStencilView[] resourcesOut, int offset, int count) {
            unsafe {
                IntPtr* resourcesOut_ = stackalloc IntPtr[resourcesOut.Length];
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, resourcesOut_, offset, count,((void**)(*(void**)_nativePointer))[28]);		
                for (int i = 0; i < resourcesOut.Length; i++)
                    resourcesOut[i] = (resourcesOut_[i] == IntPtr.Zero)?null:new SharpDX.Direct3D10.DepthStencilView(resourcesOut_[i]);	
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>A matrix-variable interface accesses a matrix.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectMatrixVariable']/*"/>	
    /// <msdn-id>bb173647</msdn-id>	
    /// <unmanaged>ID3D10EffectMatrixVariable</unmanaged>	
    /// <unmanaged-short>ID3D10EffectMatrixVariable</unmanaged-short>	
    [Guid("50666c24-b82f-4eed-a172-5b6e7e8522e0")]
    public partial class EffectMatrixVariable : SharpDX.Direct3D10.EffectVariable {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.EffectMatrixVariable"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EffectMatrixVariable(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.EffectMatrixVariable"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.EffectMatrixVariable(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.EffectMatrixVariable(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Set a floating-point matrix.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the first element in the matrix.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectMatrixVariable::SetMatrix']/*"/>	
        /// <msdn-id>bb173652</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectMatrixVariable::SetMatrix([In] SHARPDX_MATRIX* pData)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectMatrixVariable::SetMatrix</unmanaged-short>	
        public void SetMatrix(ref SharpDX.Mathematics.Interop.RawMatrix dataRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dataRef_ = &dataRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, dataRef_,((void**)(*(void**)_nativePointer))[25]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get a matrix.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the first element in a matrix.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectMatrixVariable::GetMatrix']/*"/>	
        /// <msdn-id>bb173648</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectMatrixVariable::GetMatrix([Out] SHARPDX_MATRIX* pData)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectMatrixVariable::GetMatrix</unmanaged-short>	
        internal void GetMatrix(out SharpDX.Mathematics.Interop.RawMatrix dataRef) {
            unsafe {
                dataRef = new SharpDX.Mathematics.Interop.RawMatrix();
                SharpDX.Result __result__;
                fixed (void* dataRef_ = &dataRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, dataRef_,((void**)(*(void**)_nativePointer))[26]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Set an array of floating-point matrices.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the first matrix.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>The number of matrix elements to skip from the start of the array.</p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of elements to set.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectMatrixVariable::SetMatrixArray']/*"/>	
        /// <msdn-id>bb173653</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectMatrixVariable::SetMatrixArray([In, Buffer] SHARPDX_MATRIX* pData,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectMatrixVariable::SetMatrixArray</unmanaged-short>	
        internal void SetMatrixArray(SharpDX.Mathematics.Interop.RawMatrix[] dataRef, int offset, int count) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dataRef_ = dataRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, dataRef_, offset, count,((void**)(*(void**)_nativePointer))[27]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get an array of matrices.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the first element of the first matrix in an array of matrices.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>The offset (in number of matrices) between the start of the array and the first matrix returned.</p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of matrices in the returned array.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectMatrixVariable::GetMatrixArray']/*"/>	
        /// <msdn-id>bb173649</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectMatrixVariable::GetMatrixArray([Out, Buffer] SHARPDX_MATRIX* pData,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectMatrixVariable::GetMatrixArray</unmanaged-short>	
        internal void GetMatrixArray(SharpDX.Mathematics.Interop.RawMatrix[] dataRef, int offset, int count) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dataRef_ = dataRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, dataRef_, offset, count,((void**)(*(void**)_nativePointer))[28]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Transpose and set a floating-point matrix.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the first element of a matrix.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>Transposing a matrix will rearrange the data order from row-column order to column-row order (or vice versa).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectMatrixVariable::SetMatrixTranspose']/*"/>	
        /// <msdn-id>bb173654</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectMatrixVariable::SetMatrixTranspose([In] SHARPDX_MATRIX* pData)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectMatrixVariable::SetMatrixTranspose</unmanaged-short>	
        public void SetMatrixTranspose(ref SharpDX.Mathematics.Interop.RawMatrix dataRef) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dataRef_ = &dataRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, dataRef_,((void**)(*(void**)_nativePointer))[29]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Transpose and get a floating-point matrix.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the first element of a transposed matrix.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>Transposing a matrix will rearrange the data order from row-column order to column-row order (or vice versa).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectMatrixVariable::GetMatrixTranspose']/*"/>	
        /// <msdn-id>bb173650</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectMatrixVariable::GetMatrixTranspose([Out] SHARPDX_MATRIX* pData)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectMatrixVariable::GetMatrixTranspose</unmanaged-short>	
        internal void GetMatrixTranspose(out SharpDX.Mathematics.Interop.RawMatrix dataRef) {
            unsafe {
                dataRef = new SharpDX.Mathematics.Interop.RawMatrix();
                SharpDX.Result __result__;
                fixed (void* dataRef_ = &dataRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, dataRef_,((void**)(*(void**)_nativePointer))[30]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Transpose and set an array of floating-point matrices.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to an array of matrices.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>The offset (in number of matrices) between the start of the array and the first matrix to set.</p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of matrices in the array to set.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>Transposing a matrix will rearrange the data order from row-column order to column-row order (or vice versa).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectMatrixVariable::SetMatrixTransposeArray']/*"/>	
        /// <msdn-id>bb173655</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectMatrixVariable::SetMatrixTransposeArray([In, Buffer] SHARPDX_MATRIX* pData,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectMatrixVariable::SetMatrixTransposeArray</unmanaged-short>	
        internal void SetMatrixTransposeArray(SharpDX.Mathematics.Interop.RawMatrix[] dataRef, int offset, int count) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dataRef_ = dataRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, dataRef_, offset, count,((void**)(*(void**)_nativePointer))[31]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Transpose and get an array of floating-point matrices.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the first element of an array of tranposed matrices.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>The offset (in number of matrices) between the start of the array and the first matrix to get.</p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of matrices in the array to get.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>Transposing a matrix will rearrange the data order from row-column order to column-row order (or vice versa).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectMatrixVariable::GetMatrixTransposeArray']/*"/>	
        /// <msdn-id>bb173651</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectMatrixVariable::GetMatrixTransposeArray([Out, Buffer] SHARPDX_MATRIX* pData,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectMatrixVariable::GetMatrixTransposeArray</unmanaged-short>	
        internal void GetMatrixTransposeArray(SharpDX.Mathematics.Interop.RawMatrix[] dataRef, int offset, int count) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dataRef_ = dataRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, dataRef_, offset, count,((void**)(*(void**)_nativePointer))[32]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>A pass interface encapsulates state assignments within a technique.</p><p>The lifetime of an <strong><see cref="SharpDX.Direct3D10.EffectPass"/></strong> object is equal to the lifetime of its parent <strong><see cref="SharpDX.Direct3D10.Effect"/></strong> object.</p><ul> <li>Methods</li> </ul>	
    /// </summary>	
    /// <remarks>	
    /// <p>A pass is a block of code that sets render-state objects and shaders. A pass is declared within a technique; the syntax for a technique is shown in Effect Technique Syntax (Direct3D 10).</p><p>To get an effect-pass interface, call a method like <strong><see cref="SharpDX.Direct3D10.EffectTechnique.GetPassByName"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectPass']/*"/>	
    /// <msdn-id>bb173656</msdn-id>	
    /// <unmanaged>ID3D10EffectPass</unmanaged>	
    /// <unmanaged-short>ID3D10EffectPass</unmanaged-short>	
    [Guid("5cfbeb89-1a06-46e0-b282-e3f9bfa36a54")]
    public partial class EffectPass : SharpDX.CppObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.EffectPass"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EffectPass(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.EffectPass"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.EffectPass(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.EffectPass(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Test a pass to see if it contains valid syntax.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectPass::IsValid']/*"/>	
        /// <msdn-id>bb173665</msdn-id>	
        /// <unmanaged>IsValid</unmanaged>	
        /// <unmanaged-short>IsValid</unmanaged-short>	
        /// <unmanaged>BOOL ID3D10EffectPass::IsValid()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsValid {
                get { return IsValid_(); }
        }
        
        /// <summary>	
        /// <p>Get a pass description.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>A pass is a block of code that sets render state and shaders (which in turn sets constant buffers, samplers and textures). An effect technique contains one or more passes. See techniques and passes.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectPass::GetDesc']/*"/>	
        /// <msdn-id>bb173661</msdn-id>	
        /// <unmanaged>GetDesc</unmanaged>	
        /// <unmanaged-short>GetDesc</unmanaged-short>	
        /// <unmanaged>HRESULT ID3D10EffectPass::GetDesc([Out] D3D10_PASS_DESC* pDesc)</unmanaged>
        public SharpDX.Direct3D10.EffectPassDescription Description {
                get { SharpDX.Direct3D10.EffectPassDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Get a vertex-shader description.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>An effect pass can contain render state assignments and shader object assignments.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectPass::GetVertexShaderDesc']/*"/>	
        /// <msdn-id>bb173664</msdn-id>	
        /// <unmanaged>GetVertexShaderDesc</unmanaged>	
        /// <unmanaged-short>GetVertexShaderDesc</unmanaged-short>	
        /// <unmanaged>HRESULT ID3D10EffectPass::GetVertexShaderDesc([Out] D3D10_PASS_SHADER_DESC* pDesc)</unmanaged>
        public SharpDX.Direct3D10.EffectPassShaderDescription VertexShaderDescription {
                get { SharpDX.Direct3D10.EffectPassShaderDescription __output__; GetVertexShaderDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Get a geometry-shader description.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>An effect pass can contain render state assignments and shader object assignments.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectPass::GetGeometryShaderDesc']/*"/>	
        /// <msdn-id>bb173662</msdn-id>	
        /// <unmanaged>GetGeometryShaderDesc</unmanaged>	
        /// <unmanaged-short>GetGeometryShaderDesc</unmanaged-short>	
        /// <unmanaged>HRESULT ID3D10EffectPass::GetGeometryShaderDesc([Out] D3D10_PASS_SHADER_DESC* pDesc)</unmanaged>
        public SharpDX.Direct3D10.EffectPassShaderDescription GeometryShaderDescription {
                get { SharpDX.Direct3D10.EffectPassShaderDescription __output__; GetGeometryShaderDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Get a pixel-shader description.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>An effect pass can contain render state assignments and shader object assignments.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectPass::GetPixelShaderDesc']/*"/>	
        /// <msdn-id>bb173663</msdn-id>	
        /// <unmanaged>GetPixelShaderDesc</unmanaged>	
        /// <unmanaged-short>GetPixelShaderDesc</unmanaged-short>	
        /// <unmanaged>HRESULT ID3D10EffectPass::GetPixelShaderDesc([Out] D3D10_PASS_SHADER_DESC* pDesc)</unmanaged>
        public SharpDX.Direct3D10.EffectPassShaderDescription PixelShaderDescription {
                get { SharpDX.Direct3D10.EffectPassShaderDescription __output__; GetPixelShaderDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Test a pass to see if it contains valid syntax.</p>	
        /// </summary>	
        /// <returns><p><strong>TRUE</strong> if the code syntax is valid; otherwise <strong><see cref="SharpDX.Result.False"/></strong>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectPass::IsValid']/*"/>	
        /// <msdn-id>bb173665</msdn-id>	
        /// <unmanaged>BOOL ID3D10EffectPass::IsValid()</unmanaged>	
        /// <unmanaged-short>ID3D10EffectPass::IsValid</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool IsValid_() {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer,((void**)(*(void**)_nativePointer))[0]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a pass description.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p>A reference to a pass description (see <strong><see cref="SharpDX.Direct3D10.EffectPassDescription"/></strong>).</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>A pass is a block of code that sets render state and shaders (which in turn sets constant buffers, samplers and textures). An effect technique contains one or more passes. See techniques and passes.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectPass::GetDesc']/*"/>	
        /// <msdn-id>bb173661</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectPass::GetDesc([Out] D3D10_PASS_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectPass::GetDesc</unmanaged-short>	
        internal void GetDescription(out SharpDX.Direct3D10.EffectPassDescription descRef) {
            unsafe {
                var descRef_ = new SharpDX.Direct3D10.EffectPassDescription.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &descRef_,((void**)(*(void**)_nativePointer))[1]);		
                descRef = new SharpDX.Direct3D10.EffectPassDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get a vertex-shader description.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p>A reference to a vertex-shader description (see <strong><see cref="SharpDX.Direct3D10.EffectPassShaderDescription"/></strong>).</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>An effect pass can contain render state assignments and shader object assignments.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectPass::GetVertexShaderDesc']/*"/>	
        /// <msdn-id>bb173664</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectPass::GetVertexShaderDesc([Out] D3D10_PASS_SHADER_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectPass::GetVertexShaderDesc</unmanaged-short>	
        internal void GetVertexShaderDescription(out SharpDX.Direct3D10.EffectPassShaderDescription descRef) {
            unsafe {
                descRef = new SharpDX.Direct3D10.EffectPassShaderDescription();
                SharpDX.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, descRef_,((void**)(*(void**)_nativePointer))[2]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get a geometry-shader description.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p>A reference to a geometry-shader description (see <strong><see cref="SharpDX.Direct3D10.EffectPassShaderDescription"/></strong>).</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>An effect pass can contain render state assignments and shader object assignments.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectPass::GetGeometryShaderDesc']/*"/>	
        /// <msdn-id>bb173662</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectPass::GetGeometryShaderDesc([Out] D3D10_PASS_SHADER_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectPass::GetGeometryShaderDesc</unmanaged-short>	
        internal void GetGeometryShaderDescription(out SharpDX.Direct3D10.EffectPassShaderDescription descRef) {
            unsafe {
                descRef = new SharpDX.Direct3D10.EffectPassShaderDescription();
                SharpDX.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, descRef_,((void**)(*(void**)_nativePointer))[3]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get a pixel-shader description.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p>A reference to a pixel-shader description (see <strong><see cref="SharpDX.Direct3D10.EffectPassShaderDescription"/></strong>).</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>An effect pass can contain render state assignments and shader object assignments.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectPass::GetPixelShaderDesc']/*"/>	
        /// <msdn-id>bb173663</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectPass::GetPixelShaderDesc([Out] D3D10_PASS_SHADER_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectPass::GetPixelShaderDesc</unmanaged-short>	
        internal void GetPixelShaderDescription(out SharpDX.Direct3D10.EffectPassShaderDescription descRef) {
            unsafe {
                descRef = new SharpDX.Direct3D10.EffectPassShaderDescription();
                SharpDX.Result __result__;
                fixed (void* descRef_ = &descRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, descRef_,((void**)(*(void**)_nativePointer))[4]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get an annotation by index.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>A zero-based index.</p> </dd></param>	
        /// <returns><p>A reference to an <strong><see cref="SharpDX.Direct3D10.EffectVariable"/> Interface</strong>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectPass::GetAnnotationByIndex']/*"/>	
        /// <msdn-id>bb173659</msdn-id>	
        /// <unmanaged>ID3D10EffectVariable* ID3D10EffectPass::GetAnnotationByIndex([In] unsigned int Index)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectPass::GetAnnotationByIndex</unmanaged-short>	
        public SharpDX.Direct3D10.EffectVariable GetAnnotationByIndex(int index) {
            unsafe {
                SharpDX.Direct3D10.EffectVariable __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectVariable((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer, index,((void**)(*(void**)_nativePointer))[5]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get an annotation by name.</p>	
        /// </summary>	
        /// <param name="name"><dd>  <p>The name of the annotation.</p> </dd></param>	
        /// <returns><p>A reference to an <strong><see cref="SharpDX.Direct3D10.EffectVariable"/> Interface</strong>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectPass::GetAnnotationByName']/*"/>	
        /// <msdn-id>bb173660</msdn-id>	
        /// <unmanaged>ID3D10EffectVariable* ID3D10EffectPass::GetAnnotationByName([In] const char* Name)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectPass::GetAnnotationByName</unmanaged-short>	
        public SharpDX.Direct3D10.EffectVariable GetAnnotationByName(string name) {
            unsafe {
                IntPtr name_ = Utilities.StringToHGlobalAnsi(name);
                SharpDX.Direct3D10.EffectVariable __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectVariable((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer, (void*)name_,((void**)(*(void**)_nativePointer))[6]));		
                Marshal.FreeHGlobal(name_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Set the state contained in a pass to the device.</p>	
        /// </summary>	
        /// <param name="flags"><dd>  <p>Unused.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectPass::Apply']/*"/>	
        /// <msdn-id>bb173657</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectPass::Apply([In] unsigned int Flags)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectPass::Apply</unmanaged-short>	
        internal void Apply(int flags) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, flags,((void**)(*(void**)_nativePointer))[7]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Generate a mask for allowing/preventing state changes.</p>	
        /// </summary>	
        /// <param name="stateBlockMaskRef"><dd>  <p>A reference to a state-block mask (see <strong><see cref="SharpDX.Direct3D10.StateBlockMask"/></strong>).</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectPass::ComputeStateBlockMask']/*"/>	
        /// <msdn-id>bb173658</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectPass::ComputeStateBlockMask([Out] D3D10_STATE_BLOCK_MASK* pStateBlockMask)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectPass::ComputeStateBlockMask</unmanaged-short>	
        public void ComputeStateBlockMask(out SharpDX.Direct3D10.StateBlockMask stateBlockMaskRef) {
            unsafe {
                var stateBlockMaskRef_ = new SharpDX.Direct3D10.StateBlockMask.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &stateBlockMaskRef_,((void**)(*(void**)_nativePointer))[8]);		
                stateBlockMaskRef = new SharpDX.Direct3D10.StateBlockMask();
                stateBlockMaskRef.__MarshalFrom(ref stateBlockMaskRef_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>A pool interface represents a common memory space (or pool) for sharing variables between effects.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>To create an effect pool, call a function like <strong><see cref="SharpDX.Direct3D10.D3DX10.CreateEffectPoolFromFile"/></strong>. Effect pools can improve performance by reducing the number of API calls required to make state changes (see Using Effect Pools).</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectPool']/*"/>	
    /// <msdn-id>bb173667</msdn-id>	
    /// <unmanaged>ID3D10EffectPool</unmanaged>	
    /// <unmanaged-short>ID3D10EffectPool</unmanaged-short>	
    [Guid("9537ab04-3250-412e-8213-fcd2f8677933")]
    public partial class EffectPool : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.EffectPool"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EffectPool(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.EffectPool"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.EffectPool(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.EffectPool(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Get the effect that created the effect pool.</p>	
        /// </summary>	
        /// <returns><p>A reference to an <strong><see cref="SharpDX.Direct3D10.Effect"/> Interface</strong> interface.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectPool::AsEffect']/*"/>	
        /// <msdn-id>bb173668</msdn-id>	
        /// <unmanaged>ID3D10Effect* ID3D10EffectPool::AsEffect()</unmanaged>	
        /// <unmanaged-short>ID3D10EffectPool::AsEffect</unmanaged-short>	
        public SharpDX.Direct3D10.Effect AsEffect() {
            unsafe {
                SharpDX.Direct3D10.Effect __result__;
                __result__= 
				new SharpDX.Direct3D10.Effect((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer,((void**)(*(void**)_nativePointer))[3]));		
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>A rasterizer-variable interface accesses rasterizer state.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>An <strong><see cref="SharpDX.Direct3D10.EffectRasterizerVariable"/> Interface</strong> is created when an effect is read into memory.</p><p>Effect variables are saved in memory in the backing store; when a technique is applied, the values in the backing store are copied to the device. You can use either of these methods to return state. For examples, see Two Ways to Get the State in an Effect Variable.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectRasterizerVariable']/*"/>	
    /// <msdn-id>bb173669</msdn-id>	
    /// <unmanaged>ID3D10EffectRasterizerVariable</unmanaged>	
    /// <unmanaged-short>ID3D10EffectRasterizerVariable</unmanaged-short>	
    [Guid("21af9f0e-4d94-4ea9-9785-2cb76b8c0b34")]
    public partial class EffectRasterizerVariable : SharpDX.Direct3D10.EffectVariable {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.EffectRasterizerVariable"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EffectRasterizerVariable(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.EffectRasterizerVariable"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.EffectRasterizerVariable(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.EffectRasterizerVariable(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Get a reference to a rasterizer interface.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>Index into an array of rasterizer interfaces. If there is only one rasterizer interface, use 0.</p> </dd></param>	
        /// <returns><dd>  <p>The address of a reference to a rasterizer interface (see <strong><see cref="SharpDX.Direct3D10.RasterizerState"/> Interface</strong>).</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectRasterizerVariable::GetRasterizerState']/*"/>	
        /// <msdn-id>bb173671</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectRasterizerVariable::GetRasterizerState([In] unsigned int Index,[Out] ID3D10RasterizerState** ppRasterizerState)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectRasterizerVariable::GetRasterizerState</unmanaged-short>	
        public SharpDX.Direct3D10.RasterizerState GetRasterizerState(int index) {
            unsafe {
                SharpDX.Direct3D10.RasterizerState rasterizerStateOut;
                IntPtr rasterizerStateOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, index, &rasterizerStateOut_,((void**)(*(void**)_nativePointer))[25]);		
                rasterizerStateOut= (rasterizerStateOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.RasterizerState(rasterizerStateOut_);	
                __result__.CheckError();
                return rasterizerStateOut;
            }
        }
        
        /// <summary>	
        /// <p>Get a reference to a variable that contains rasteriser state.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>Index into an array of rasteriser-state descriptions. If there is only one rasteriser variable in the effect, use 0.</p> </dd></param>	
        /// <param name="rasterizerDescRef"><dd>  <p>A reference to a rasteriser-state description (see <strong><see cref="SharpDX.Direct3D10.RasterizerStateDescription"/></strong>).</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>Effect variables are saved in memory in the backing store; when a technique is applied, the values in the backing store are copied to the device. Backing store data can used to recreate the variable when necessary.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectRasterizerVariable::GetBackingStore']/*"/>	
        /// <msdn-id>bb173670</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectRasterizerVariable::GetBackingStore([In] unsigned int Index,[Out] D3D10_RASTERIZER_DESC* pRasterizerDesc)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectRasterizerVariable::GetBackingStore</unmanaged-short>	
        public void GetBackingStore(int index, out SharpDX.Direct3D10.RasterizerStateDescription rasterizerDescRef) {
            unsafe {
                rasterizerDescRef = new SharpDX.Direct3D10.RasterizerStateDescription();
                SharpDX.Result __result__;
                fixed (void* rasterizerDescRef_ = &rasterizerDescRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, index, rasterizerDescRef_,((void**)(*(void**)_nativePointer))[26]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>A render-target-view interface accesses a render target.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectRenderTargetViewVariable']/*"/>	
    /// <msdn-id>bb173672</msdn-id>	
    /// <unmanaged>ID3D10EffectRenderTargetViewVariable</unmanaged>	
    /// <unmanaged-short>ID3D10EffectRenderTargetViewVariable</unmanaged-short>	
    [Guid("28ca0cc3-c2c9-40bb-b57f-67b737122b17")]
    public partial class EffectRenderTargetViewVariable : SharpDX.Direct3D10.EffectVariable {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.EffectRenderTargetViewVariable"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EffectRenderTargetViewVariable(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.EffectRenderTargetViewVariable"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.EffectRenderTargetViewVariable(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.EffectRenderTargetViewVariable(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Set a render-target.</p>	
        /// </summary>	
        /// <param name="resourceRef"><dd>  <p>A reference to a render-target-view interface. See <strong><see cref="SharpDX.Direct3D10.RenderTargetView"/> Interface</strong>.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectRenderTargetViewVariable::SetRenderTarget']/*"/>	
        /// <msdn-id>bb173675</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectRenderTargetViewVariable::SetRenderTarget([In, Optional] ID3D10RenderTargetView* pResource)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectRenderTargetViewVariable::SetRenderTarget</unmanaged-short>	
        public void SetRenderTarget(SharpDX.Direct3D10.RenderTargetView resourceRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer),((void**)(*(void**)_nativePointer))[25]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get a render-target.</p>	
        /// </summary>	
        /// <returns><dd>  <p>The address of a reference to a render-target-view interface. See <strong><see cref="SharpDX.Direct3D10.RenderTargetView"/> Interface</strong>.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectRenderTargetViewVariable::GetRenderTarget']/*"/>	
        /// <msdn-id>bb173673</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectRenderTargetViewVariable::GetRenderTarget([Out] ID3D10RenderTargetView** ppResource)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectRenderTargetViewVariable::GetRenderTarget</unmanaged-short>	
        public SharpDX.Direct3D10.RenderTargetView GetRenderTarget() {
            unsafe {
                SharpDX.Direct3D10.RenderTargetView resourceOut;
                IntPtr resourceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &resourceOut_,((void**)(*(void**)_nativePointer))[26]);		
                resourceOut= (resourceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.RenderTargetView(resourceOut_);	
                __result__.CheckError();
                return resourceOut;
            }
        }
        
        /// <summary>	
        /// <p>Set an array of render-targets.</p>	
        /// </summary>	
        /// <param name="resourcesOut"><dd>  <p>Set an array of render-target-view interfaces. See <strong><see cref="SharpDX.Direct3D10.RenderTargetView"/> Interface</strong>.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>The zero-based array index to store the first interface.</p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of elements in the array.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectRenderTargetViewVariable::SetRenderTargetArray']/*"/>	
        /// <msdn-id>bb173676</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectRenderTargetViewVariable::SetRenderTargetArray([In, Buffer] ID3D10RenderTargetView** ppResources,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectRenderTargetViewVariable::SetRenderTargetArray</unmanaged-short>	
        internal void SetRenderTargetArray(SharpDX.Direct3D10.RenderTargetView[] resourcesOut, int offset, int count) {
            unsafe {
                IntPtr* resourcesOut_ = (IntPtr*)0;
                if ( resourcesOut != null ) {
                    IntPtr* resourcesOut__ = stackalloc IntPtr[resourcesOut.Length];
                    resourcesOut_ = resourcesOut__;
                    for (int i = 0; i < resourcesOut.Length; i++)                        
                        resourcesOut_[i] =  (resourcesOut[i] == null)? IntPtr.Zero : resourcesOut[i].NativePointer;
                }
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, resourcesOut_, offset, count,((void**)(*(void**)_nativePointer))[27]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Set an array of render-targets.</p>	
        /// </summary>	
        /// <param name="resourcesOut"><dd>  <p>Set an array of render-target-view interfaces. See <strong><see cref="SharpDX.Direct3D10.RenderTargetView"/> Interface</strong>.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>The zero-based array index to store the first interface.</p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of elements in the array.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectRenderTargetViewVariable::SetRenderTargetArray']/*"/>	
        /// <msdn-id>bb173676</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectRenderTargetViewVariable::SetRenderTargetArray([In, Buffer] ID3D10RenderTargetView** ppResources,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectRenderTargetViewVariable::SetRenderTargetArray</unmanaged-short>	
        internal void SetRenderTargetArray(SharpDX.ComArray<SharpDX.Direct3D10.RenderTargetView> resourcesOut, int offset, int count) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)((resourcesOut == null)?IntPtr.Zero:resourcesOut.NativePointer), offset, count,((void**)(*(void**)_nativePointer))[27]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Set an array of render-targets.</p>	
        /// </summary>	
        /// <param name="resourcesOut"><dd>  <p>Set an array of render-target-view interfaces. See <strong><see cref="SharpDX.Direct3D10.RenderTargetView"/> Interface</strong>.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>The zero-based array index to store the first interface.</p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of elements in the array.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectRenderTargetViewVariable::SetRenderTargetArray']/*"/>	
        /// <msdn-id>bb173676</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectRenderTargetViewVariable::SetRenderTargetArray([In, Buffer] ID3D10RenderTargetView** ppResources,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectRenderTargetViewVariable::SetRenderTargetArray</unmanaged-short>	
        private void SetRenderTargetArray(System.IntPtr resourcesOut, int offset, int count) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)resourcesOut, offset, count,((void**)(*(void**)_nativePointer))[27]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get an array of render-targets.</p>	
        /// </summary>	
        /// <param name="resourcesOut"><dd>  <p>A reference to an array of render-target-view interfaces. See <strong><see cref="SharpDX.Direct3D10.RenderTargetView"/> Interface</strong>.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>The zero-based array index to get the first interface.</p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of elements in the array.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectRenderTargetViewVariable::GetRenderTargetArray']/*"/>	
        /// <msdn-id>bb173674</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectRenderTargetViewVariable::GetRenderTargetArray([Out, Buffer] ID3D10RenderTargetView** ppResources,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectRenderTargetViewVariable::GetRenderTargetArray</unmanaged-short>	
        internal void GetRenderTargetArray(SharpDX.Direct3D10.RenderTargetView[] resourcesOut, int offset, int count) {
            unsafe {
                IntPtr* resourcesOut_ = stackalloc IntPtr[resourcesOut.Length];
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, resourcesOut_, offset, count,((void**)(*(void**)_nativePointer))[28]);		
                for (int i = 0; i < resourcesOut.Length; i++)
                    resourcesOut[i] = (resourcesOut_[i] == IntPtr.Zero)?null:new SharpDX.Direct3D10.RenderTargetView(resourcesOut_[i]);	
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>A sampler interface accesses sampler state.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>An <strong><see cref="SharpDX.Direct3D10.EffectSamplerVariable"/> Interface</strong> is created when an effect is read into memory.</p><p>Effect variables are saved in memory in the backing store; when a technique is applied, the values in the backing store are copied to the device. You can use either of these methods to return state. For examples, see Two Ways to Get the State in an Effect Variable.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectSamplerVariable']/*"/>	
    /// <msdn-id>bb173677</msdn-id>	
    /// <unmanaged>ID3D10EffectSamplerVariable</unmanaged>	
    /// <unmanaged-short>ID3D10EffectSamplerVariable</unmanaged-short>	
    [Guid("6530d5c7-07e9-4271-a418-e7ce4bd1e480")]
    public partial class EffectSamplerVariable : SharpDX.Direct3D10.EffectVariable {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.EffectSamplerVariable"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EffectSamplerVariable(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.EffectSamplerVariable"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.EffectSamplerVariable(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.EffectSamplerVariable(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Get a reference to a sampler interface.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>Index into an array of sampler interfaces. If there is only one sampler interface, use 0.</p> </dd></param>	
        /// <returns><dd>  <p>The address of a reference to a sampler interface (see <strong><see cref="SharpDX.Direct3D10.SamplerState"/> Interface</strong>).</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectSamplerVariable::GetSampler']/*"/>	
        /// <msdn-id>bb173679</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectSamplerVariable::GetSampler([In] unsigned int Index,[Out] ID3D10SamplerState** ppSampler)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectSamplerVariable::GetSampler</unmanaged-short>	
        public SharpDX.Direct3D10.SamplerState GetSampler(int index) {
            unsafe {
                SharpDX.Direct3D10.SamplerState samplerOut;
                IntPtr samplerOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, index, &samplerOut_,((void**)(*(void**)_nativePointer))[25]);		
                samplerOut= (samplerOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.SamplerState(samplerOut_);	
                __result__.CheckError();
                return samplerOut;
            }
        }
        
        /// <summary>	
        /// <p>Get a reference to a variable that contains sampler state.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>Index into an array of sampler descriptions. If there is only one sampler variable in the effect, use 0.</p> </dd></param>	
        /// <param name="samplerDescRef"><dd>  <p>A reference to a sampler description (see <strong><see cref="SharpDX.Direct3D10.SamplerStateDescription"/></strong>).</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectSamplerVariable::GetBackingStore']/*"/>	
        /// <msdn-id>bb173678</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectSamplerVariable::GetBackingStore([In] unsigned int Index,[Out] D3D10_SAMPLER_DESC* pSamplerDesc)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectSamplerVariable::GetBackingStore</unmanaged-short>	
        public void GetBackingStore(int index, out SharpDX.Direct3D10.SamplerStateDescription samplerDescRef) {
            unsafe {
                samplerDescRef = new SharpDX.Direct3D10.SamplerStateDescription();
                SharpDX.Result __result__;
                fixed (void* samplerDescRef_ = &samplerDescRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, index, samplerDescRef_,((void**)(*(void**)_nativePointer))[26]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>An effect-scalar-variable interface accesses scalar values.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectScalarVariable']/*"/>	
    /// <msdn-id>bb173680</msdn-id>	
    /// <unmanaged>ID3D10EffectScalarVariable</unmanaged>	
    /// <unmanaged-short>ID3D10EffectScalarVariable</unmanaged-short>	
    [Guid("00e48f7b-d2c8-49e8-a86c-022dee53431f")]
    public partial class EffectScalarVariable : SharpDX.Direct3D10.EffectVariable {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.EffectScalarVariable"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EffectScalarVariable(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.EffectScalarVariable"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.EffectScalarVariable(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.EffectScalarVariable(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Set a floating-point variable.</p>	
        /// </summary>	
        /// <param name="value"><dd>  <p>A reference to the variable.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectScalarVariable::SetFloat']/*"/>	
        /// <msdn-id>bb173689</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectScalarVariable::SetFloat([In] float Value)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectScalarVariable::SetFloat</unmanaged-short>	
        internal void SetFloat(float value) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, value,((void**)(*(void**)_nativePointer))[25]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get a floating-point variable.</p>	
        /// </summary>	
        /// <returns><dd>  <p>A reference to the variable.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectScalarVariable::GetFloat']/*"/>	
        /// <msdn-id>bb173683</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectScalarVariable::GetFloat([Out] float* pValue)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectScalarVariable::GetFloat</unmanaged-short>	
        public float GetFloat() {
            unsafe {
                float valueRef;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &valueRef,((void**)(*(void**)_nativePointer))[26]);		
                __result__.CheckError();
                return valueRef;
            }
        }
        
        /// <summary>	
        /// <p>Set an array of floating-point variables.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the start of the data to set.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>Must be set to 0; this is reserved for future use. </p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of array elements to set.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectScalarVariable::SetFloatArray']/*"/>	
        /// <msdn-id>bb173690</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectScalarVariable::SetFloatArray([In, Buffer] float* pData,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectScalarVariable::SetFloatArray</unmanaged-short>	
        internal void SetFloatArray(float[] dataRef, int offset, int count) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dataRef_ = dataRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, dataRef_, offset, count,((void**)(*(void**)_nativePointer))[27]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get an array of floating-point variables.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the start of the data to set.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>Must be set to 0; this is reserved for future use. </p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of array elements to set.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectScalarVariable::GetFloatArray']/*"/>	
        /// <msdn-id>bb173684</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectScalarVariable::GetFloatArray([Out, Buffer] float* pData,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectScalarVariable::GetFloatArray</unmanaged-short>	
        internal void GetFloatArray(float[] dataRef, int offset, int count) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dataRef_ = dataRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, dataRef_, offset, count,((void**)(*(void**)_nativePointer))[28]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Set an integer variable.</p>	
        /// </summary>	
        /// <param name="value"><dd>  <p>A reference to the variable.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectScalarVariable::SetInt']/*"/>	
        /// <msdn-id>bb173691</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectScalarVariable::SetInt([In] int Value)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectScalarVariable::SetInt</unmanaged-short>	
        internal void SetInt(int value) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, value,((void**)(*(void**)_nativePointer))[29]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get an integer variable.</p>	
        /// </summary>	
        /// <returns><dd>  <p>A reference to the variable.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectScalarVariable::GetInt']/*"/>	
        /// <msdn-id>bb173685</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectScalarVariable::GetInt([Out] int* pValue)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectScalarVariable::GetInt</unmanaged-short>	
        public int GetInt() {
            unsafe {
                int valueRef;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &valueRef,((void**)(*(void**)_nativePointer))[30]);		
                __result__.CheckError();
                return valueRef;
            }
        }
        
        /// <summary>	
        /// <p>Set an array of integer variables.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the start of the data to set.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>Must be set to 0; this is reserved for future use. </p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of array elements to set.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectScalarVariable::SetIntArray']/*"/>	
        /// <msdn-id>bb173692</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectScalarVariable::SetIntArray([In, Buffer] int* pData,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectScalarVariable::SetIntArray</unmanaged-short>	
        internal void SetIntArray(int[] dataRef, int offset, int count) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dataRef_ = dataRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, dataRef_, offset, count,((void**)(*(void**)_nativePointer))[31]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get an array of integer variables.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the start of the data to set.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>Must be set to 0; this is reserved for future use. </p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of array elements to set.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectScalarVariable::GetIntArray']/*"/>	
        /// <msdn-id>bb173686</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectScalarVariable::GetIntArray([Out, Buffer] int* pData,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectScalarVariable::GetIntArray</unmanaged-short>	
        internal void GetIntArray(int[] dataRef, int offset, int count) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dataRef_ = dataRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, dataRef_, offset, count,((void**)(*(void**)_nativePointer))[32]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Set a boolean variable.</p>	
        /// </summary>	
        /// <param name="value"><dd>  <p>A reference to the variable.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectScalarVariable::SetBool']/*"/>	
        /// <msdn-id>bb173687</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectScalarVariable::SetBool([In] BOOL Value)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectScalarVariable::SetBool</unmanaged-short>	
        internal void SetBool(SharpDX.Mathematics.Interop.RawBool value) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint48(_nativePointer, value,((void**)(*(void**)_nativePointer))[33]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get a boolean variable.</p>	
        /// </summary>	
        /// <param name="valueRef"><dd>  <p>A reference to the variable.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectScalarVariable::GetBool']/*"/>	
        /// <msdn-id>bb173681</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectScalarVariable::GetBool([Out] BOOL* pValue)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectScalarVariable::GetBool</unmanaged-short>	
        internal void GetBool(out SharpDX.Mathematics.Interop.RawBool valueRef) {
            unsafe {
                valueRef = new SharpDX.Mathematics.Interop.RawBool();
                SharpDX.Result __result__;
                fixed (void* valueRef_ = &valueRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, valueRef_,((void**)(*(void**)_nativePointer))[34]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Set an array of boolean variables.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the start of the data to set.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>Must be set to 0; this is reserved for future use. </p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of array elements to set.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectScalarVariable::SetBoolArray']/*"/>	
        /// <msdn-id>bb173688</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectScalarVariable::SetBoolArray([In, Buffer] BOOL* pData,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectScalarVariable::SetBoolArray</unmanaged-short>	
        internal void SetBoolArray(SharpDX.Mathematics.Interop.RawBool[] dataRef, int offset, int count) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dataRef_ = dataRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, dataRef_, offset, count,((void**)(*(void**)_nativePointer))[35]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get an array of boolean variables.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the start of the data to set.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>Must be set to 0; this is reserved for future use. </p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of array elements to set.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectScalarVariable::GetBoolArray']/*"/>	
        /// <msdn-id>bb173682</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectScalarVariable::GetBoolArray([Out, Buffer] BOOL* pData,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectScalarVariable::GetBoolArray</unmanaged-short>	
        internal void GetBoolArray(SharpDX.Mathematics.Interop.RawBool[] dataRef, int offset, int count) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dataRef_ = dataRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, dataRef_, offset, count,((void**)(*(void**)_nativePointer))[36]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>A shader-resource interface accesses a shader resource.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectShaderResourceVariable']/*"/>	
    /// <msdn-id>bb173693</msdn-id>	
    /// <unmanaged>ID3D10EffectShaderResourceVariable</unmanaged>	
    /// <unmanaged-short>ID3D10EffectShaderResourceVariable</unmanaged-short>	
    [Guid("c0a7157b-d872-4b1d-8073-efc2acd4b1fc")]
    public partial class EffectShaderResourceVariable : SharpDX.Direct3D10.EffectVariable {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.EffectShaderResourceVariable"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EffectShaderResourceVariable(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.EffectShaderResourceVariable"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.EffectShaderResourceVariable(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.EffectShaderResourceVariable(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Set a shader resource.</p>	
        /// </summary>	
        /// <param name="resourceRef"><dd>  <p>The address of a reference to a shader-resource-view interface. See <strong><see cref="SharpDX.Direct3D10.ShaderResourceView"/> Interface</strong>.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectShaderResourceVariable::SetResource']/*"/>	
        /// <msdn-id>bb173696</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectShaderResourceVariable::SetResource([In, Optional] ID3D10ShaderResourceView* pResource)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectShaderResourceVariable::SetResource</unmanaged-short>	
        public void SetResource(SharpDX.Direct3D10.ShaderResourceView resourceRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)((resourceRef == null)?IntPtr.Zero:resourceRef.NativePointer),((void**)(*(void**)_nativePointer))[25]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get a shader resource.</p>	
        /// </summary>	
        /// <returns><dd>  <p>The address of a reference to a shader-resource-view interface. See <strong><see cref="SharpDX.Direct3D10.ShaderResourceView"/> Interface</strong>.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectShaderResourceVariable::GetResource']/*"/>	
        /// <msdn-id>bb173694</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectShaderResourceVariable::GetResource([Out] ID3D10ShaderResourceView** ppResource)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectShaderResourceVariable::GetResource</unmanaged-short>	
        public SharpDX.Direct3D10.ShaderResourceView GetResource() {
            unsafe {
                SharpDX.Direct3D10.ShaderResourceView resourceOut;
                IntPtr resourceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &resourceOut_,((void**)(*(void**)_nativePointer))[26]);		
                resourceOut= (resourceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.ShaderResourceView(resourceOut_);	
                __result__.CheckError();
                return resourceOut;
            }
        }
        
        /// <summary>	
        /// <p>Set an array of shader resources.</p>	
        /// </summary>	
        /// <param name="resourcesOut"><dd>  <p>The address of an array of shader-resource-view interfaces. See <strong><see cref="SharpDX.Direct3D10.ShaderResourceView"/> Interface</strong>.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>The zero-based array index to get the first interface.</p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of elements in the array.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectShaderResourceVariable::SetResourceArray']/*"/>	
        /// <msdn-id>bb173697</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectShaderResourceVariable::SetResourceArray([In, Buffer] ID3D10ShaderResourceView** ppResources,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectShaderResourceVariable::SetResourceArray</unmanaged-short>	
        internal void SetResourceArray(SharpDX.Direct3D10.ShaderResourceView[] resourcesOut, int offset, int count) {
            unsafe {
                IntPtr* resourcesOut_ = (IntPtr*)0;
                if ( resourcesOut != null ) {
                    IntPtr* resourcesOut__ = stackalloc IntPtr[resourcesOut.Length];
                    resourcesOut_ = resourcesOut__;
                    for (int i = 0; i < resourcesOut.Length; i++)                        
                        resourcesOut_[i] =  (resourcesOut[i] == null)? IntPtr.Zero : resourcesOut[i].NativePointer;
                }
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, resourcesOut_, offset, count,((void**)(*(void**)_nativePointer))[27]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Set an array of shader resources.</p>	
        /// </summary>	
        /// <param name="resourcesOut"><dd>  <p>The address of an array of shader-resource-view interfaces. See <strong><see cref="SharpDX.Direct3D10.ShaderResourceView"/> Interface</strong>.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>The zero-based array index to get the first interface.</p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of elements in the array.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectShaderResourceVariable::SetResourceArray']/*"/>	
        /// <msdn-id>bb173697</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectShaderResourceVariable::SetResourceArray([In, Buffer] ID3D10ShaderResourceView** ppResources,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectShaderResourceVariable::SetResourceArray</unmanaged-short>	
        internal void SetResourceArray(SharpDX.ComArray<SharpDX.Direct3D10.ShaderResourceView> resourcesOut, int offset, int count) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)((resourcesOut == null)?IntPtr.Zero:resourcesOut.NativePointer), offset, count,((void**)(*(void**)_nativePointer))[27]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Set an array of shader resources.</p>	
        /// </summary>	
        /// <param name="resourcesOut"><dd>  <p>The address of an array of shader-resource-view interfaces. See <strong><see cref="SharpDX.Direct3D10.ShaderResourceView"/> Interface</strong>.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>The zero-based array index to get the first interface.</p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of elements in the array.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectShaderResourceVariable::SetResourceArray']/*"/>	
        /// <msdn-id>bb173697</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectShaderResourceVariable::SetResourceArray([In, Buffer] ID3D10ShaderResourceView** ppResources,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectShaderResourceVariable::SetResourceArray</unmanaged-short>	
        private void SetResourceArray(System.IntPtr resourcesOut, int offset, int count) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)resourcesOut, offset, count,((void**)(*(void**)_nativePointer))[27]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get an array of shader resources.</p>	
        /// </summary>	
        /// <param name="resourcesOut"><dd>  <p>The address of an array of shader-resource-view interfaces. See <strong><see cref="SharpDX.Direct3D10.ShaderResourceView"/> Interface</strong>.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>The zero-based array index to get the first interface.</p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of elements in the array.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectShaderResourceVariable::GetResourceArray']/*"/>	
        /// <msdn-id>bb173695</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectShaderResourceVariable::GetResourceArray([Out, Buffer] ID3D10ShaderResourceView** ppResources,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectShaderResourceVariable::GetResourceArray</unmanaged-short>	
        internal void GetResourceArray(SharpDX.Direct3D10.ShaderResourceView[] resourcesOut, int offset, int count) {
            unsafe {
                IntPtr* resourcesOut_ = stackalloc IntPtr[resourcesOut.Length];
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, resourcesOut_, offset, count,((void**)(*(void**)_nativePointer))[28]);		
                for (int i = 0; i < resourcesOut.Length; i++)
                    resourcesOut[i] = (resourcesOut_[i] == IntPtr.Zero)?null:new SharpDX.Direct3D10.ShaderResourceView(resourcesOut_[i]);	
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>A shader-variable interface accesses a shader variable.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectShaderVariable']/*"/>	
    /// <msdn-id>bb173698</msdn-id>	
    /// <unmanaged>ID3D10EffectShaderVariable</unmanaged>	
    /// <unmanaged-short>ID3D10EffectShaderVariable</unmanaged-short>	
    [Guid("80849279-c799-4797-8c33-0407a07d9e06")]
    public partial class EffectShaderVariable : SharpDX.Direct3D10.EffectVariable {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.EffectShaderVariable"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EffectShaderVariable(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.EffectShaderVariable"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.EffectShaderVariable(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.EffectShaderVariable(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Get a shader description.</p>	
        /// </summary>	
        /// <param name="shaderIndex"><dd>  <p>A zero-based index.</p> </dd></param>	
        /// <returns><dd>  <p>A reference to a shader description (see <strong><see cref="SharpDX.Direct3D10.EffectShaderDescription"/></strong>).</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectShaderVariable::GetShaderDesc']/*"/>	
        /// <msdn-id>bb173703</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectShaderVariable::GetShaderDesc([In] unsigned int ShaderIndex,[Out] D3D10_EFFECT_SHADER_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectShaderVariable::GetShaderDesc</unmanaged-short>	
        public SharpDX.Direct3D10.EffectShaderDescription GetShaderDescription(int shaderIndex) {
            unsafe {
                SharpDX.Direct3D10.EffectShaderDescription descRef;
                var descRef_ = new SharpDX.Direct3D10.EffectShaderDescription.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, shaderIndex, &descRef_,((void**)(*(void**)_nativePointer))[25]);		
                descRef = new SharpDX.Direct3D10.EffectShaderDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
                return descRef;
            }
        }
        
        /// <summary>	
        /// <p>Get a vertex shader.</p>	
        /// </summary>	
        /// <param name="shaderIndex"><dd>  <p>A zero-based index.</p> </dd></param>	
        /// <returns><dd>  <p>A reference to a <strong><see cref="SharpDX.Direct3D10.VertexShader"/> Interface</strong>.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectShaderVariable::GetVertexShader']/*"/>	
        /// <msdn-id>bb173704</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectShaderVariable::GetVertexShader([In] unsigned int ShaderIndex,[Out] ID3D10VertexShader** ppVS)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectShaderVariable::GetVertexShader</unmanaged-short>	
        public SharpDX.Direct3D10.VertexShader GetVertexShader(int shaderIndex) {
            unsafe {
                SharpDX.Direct3D10.VertexShader vSOut;
                IntPtr vSOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, shaderIndex, &vSOut_,((void**)(*(void**)_nativePointer))[26]);		
                vSOut= (vSOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.VertexShader(vSOut_);	
                __result__.CheckError();
                return vSOut;
            }
        }
        
        /// <summary>	
        /// <p>Get a geometry shader.</p>	
        /// </summary>	
        /// <param name="shaderIndex"><dd>  <p>A zero-based index.</p> </dd></param>	
        /// <returns><dd>  <p>A reference to a <strong><see cref="SharpDX.Direct3D10.GeometryShader"/> Interface</strong>.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectShaderVariable::GetGeometryShader']/*"/>	
        /// <msdn-id>bb173699</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectShaderVariable::GetGeometryShader([In] unsigned int ShaderIndex,[Out] ID3D10GeometryShader** ppGS)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectShaderVariable::GetGeometryShader</unmanaged-short>	
        public SharpDX.Direct3D10.GeometryShader GetGeometryShader(int shaderIndex) {
            unsafe {
                SharpDX.Direct3D10.GeometryShader gSOut;
                IntPtr gSOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, shaderIndex, &gSOut_,((void**)(*(void**)_nativePointer))[27]);		
                gSOut= (gSOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.GeometryShader(gSOut_);	
                __result__.CheckError();
                return gSOut;
            }
        }
        
        /// <summary>	
        /// <p>Get a pixel shader.</p>	
        /// </summary>	
        /// <param name="shaderIndex"><dd>  <p>A zero-based index.</p> </dd></param>	
        /// <returns><dd>  <p>A reference to a <strong><see cref="SharpDX.Direct3D10.PixelShader"/> Interface</strong>.</p> </dd></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectShaderVariable::GetPixelShader']/*"/>	
        /// <msdn-id>bb173702</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectShaderVariable::GetPixelShader([In] unsigned int ShaderIndex,[Out] ID3D10PixelShader** ppPS)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectShaderVariable::GetPixelShader</unmanaged-short>	
        public SharpDX.Direct3D10.PixelShader GetPixelShader(int shaderIndex) {
            unsafe {
                SharpDX.Direct3D10.PixelShader pSOut;
                IntPtr pSOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, shaderIndex, &pSOut_,((void**)(*(void**)_nativePointer))[28]);		
                pSOut= (pSOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.PixelShader(pSOut_);	
                __result__.CheckError();
                return pSOut;
            }
        }
        
        /// <summary>	
        /// <p>Get an input-signature description.</p>	
        /// </summary>	
        /// <param name="shaderIndex"><dd>  <p>A zero-based shader index.</p> </dd></param>	
        /// <param name="element"><dd>  <p>A zero-based shader-element index.</p> </dd></param>	
        /// <returns><dd>  <p>A reference to a parameter description (see <strong><see cref="SharpDX.Direct3D10.ShaderParameterDescription"/></strong>).</p> </dd></returns>	
        /// <remarks>	
        /// <p>An effect contains one or more shaders; each shader has an input and output signature; each signature contains one or more elements (or parameters). The shader index identifies the shader and the element index identifies the element (or parameter) in the shader signature.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectShaderVariable::GetInputSignatureElementDesc']/*"/>	
        /// <msdn-id>bb173700</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectShaderVariable::GetInputSignatureElementDesc([In] unsigned int ShaderIndex,[In] unsigned int Element,[Out] D3D10_SIGNATURE_PARAMETER_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectShaderVariable::GetInputSignatureElementDesc</unmanaged-short>	
        public SharpDX.Direct3D10.ShaderParameterDescription GetInputSignatureElementDescription(int shaderIndex, int element) {
            unsafe {
                SharpDX.Direct3D10.ShaderParameterDescription etInputParameterDescriptionRef;
                var etInputParameterDescriptionRef_ = new SharpDX.Direct3D10.ShaderParameterDescription.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, shaderIndex, element, &etInputParameterDescriptionRef_,((void**)(*(void**)_nativePointer))[29]);		
                etInputParameterDescriptionRef = new SharpDX.Direct3D10.ShaderParameterDescription();
                etInputParameterDescriptionRef.__MarshalFrom(ref etInputParameterDescriptionRef_);
                __result__.CheckError();
                return etInputParameterDescriptionRef;
            }
        }
        
        /// <summary>	
        /// <p>Get an output-signature description.</p>	
        /// </summary>	
        /// <param name="shaderIndex"><dd>  <p>A zero-based shader index.</p> </dd></param>	
        /// <param name="element"><dd>  <p>A zero-based element index.</p> </dd></param>	
        /// <returns><dd>  <p>A reference to a parameter description (see <strong><see cref="SharpDX.Direct3D10.ShaderParameterDescription"/></strong>).</p> </dd></returns>	
        /// <remarks>	
        /// <p>An effect contains one or more shaders; each shader has an input and output signature; each signature contains one or more elements (or parameters). The shader index identifies the shader and the element index identifies the element (or parameter) in the shader signature.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectShaderVariable::GetOutputSignatureElementDesc']/*"/>	
        /// <msdn-id>bb173701</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectShaderVariable::GetOutputSignatureElementDesc([In] unsigned int ShaderIndex,[In] unsigned int Element,[Out] D3D10_SIGNATURE_PARAMETER_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectShaderVariable::GetOutputSignatureElementDesc</unmanaged-short>	
        public SharpDX.Direct3D10.ShaderParameterDescription GetOutputSignatureElementDescription(int shaderIndex, int element) {
            unsafe {
                SharpDX.Direct3D10.ShaderParameterDescription etOutputParameterDescriptionRef;
                var etOutputParameterDescriptionRef_ = new SharpDX.Direct3D10.ShaderParameterDescription.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, shaderIndex, element, &etOutputParameterDescriptionRef_,((void**)(*(void**)_nativePointer))[30]);		
                etOutputParameterDescriptionRef = new SharpDX.Direct3D10.ShaderParameterDescription();
                etOutputParameterDescriptionRef.__MarshalFrom(ref etOutputParameterDescriptionRef_);
                __result__.CheckError();
                return etOutputParameterDescriptionRef;
            }
        }
    }
    /// <summary>	
    /// <p>A string-variable interface accesses a string variable.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectStringVariable']/*"/>	
    /// <msdn-id>bb173705</msdn-id>	
    /// <unmanaged>ID3D10EffectStringVariable</unmanaged>	
    /// <unmanaged-short>ID3D10EffectStringVariable</unmanaged-short>	
    [Guid("71417501-8df9-4e0a-a78a-255f9756baff")]
    public partial class EffectStringVariable : SharpDX.Direct3D10.EffectVariable {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.EffectStringVariable"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EffectStringVariable(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.EffectStringVariable"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.EffectStringVariable(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.EffectStringVariable(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Get the string.</p>	
        /// </summary>	
        /// <param name="stringOut"><dd>  <p>A reference to the string.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectStringVariable::GetString']/*"/>	
        /// <msdn-id>bb173706</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectStringVariable::GetString([Out] const void** ppString)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectStringVariable::GetString</unmanaged-short>	
        internal void GetString(out System.IntPtr stringOut) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* stringOut_ = &stringOut)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, stringOut_,((void**)(*(void**)_nativePointer))[25]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get an array of strings.</p>	
        /// </summary>	
        /// <param name="stringsOut"><dd>  <p>A reference to the first string in the array.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>The offset (in number of strings) between the start of the array and the first string to get.</p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of strings in the returned array.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectStringVariable::GetStringArray']/*"/>	
        /// <msdn-id>bb173707</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectStringVariable::GetStringArray([Out, Buffer] const void** ppStrings,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectStringVariable::GetStringArray</unmanaged-short>	
        internal void GetStringArray(System.IntPtr stringsOut, int offset, int count) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)stringsOut, offset, count,((void**)(*(void**)_nativePointer))[26]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>An <strong><see cref="SharpDX.Direct3D10.EffectTechnique"/></strong> interface is a collection of passes.</p><p>The lifetime of an <strong><see cref="SharpDX.Direct3D10.EffectTechnique"/></strong> object is equal to the lifetime of its parent <strong><see cref="SharpDX.Direct3D10.Effect"/></strong> object.</p><ul> <li>Methods</li> </ul>	
    /// </summary>	
    /// <remarks>	
    /// <p>An effect contains one or more techniques; each technique contains one or more passes; each pass contains state assignments (see Organizing State in an Effect (Direct3D 10)). The syntax for creating a technique is shown in Effect Technique Syntax (Direct3D 10).</p><p>To get an effect-technique interface, call a method like <strong><see cref="SharpDX.Direct3D10.Effect.GetTechniqueByName"/></strong>.</p>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectTechnique']/*"/>	
    /// <msdn-id>bb173708</msdn-id>	
    /// <unmanaged>ID3D10EffectTechnique</unmanaged>	
    /// <unmanaged-short>ID3D10EffectTechnique</unmanaged-short>	
    [Guid("db122ce8-d1c9-4292-b237-24ed3de8b175")]
    public partial class EffectTechnique : SharpDX.CppObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.EffectTechnique"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EffectTechnique(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.EffectTechnique"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.EffectTechnique(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.EffectTechnique(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Test a technique to see if it contains valid syntax.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectTechnique::IsValid']/*"/>	
        /// <msdn-id>bb173715</msdn-id>	
        /// <unmanaged>IsValid</unmanaged>	
        /// <unmanaged-short>IsValid</unmanaged-short>	
        /// <unmanaged>BOOL ID3D10EffectTechnique::IsValid()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsValid {
                get { return IsValid_(); }
        }
        
        /// <summary>	
        /// <p>Get a technique description.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectTechnique::GetDesc']/*"/>	
        /// <msdn-id>bb173712</msdn-id>	
        /// <unmanaged>GetDesc</unmanaged>	
        /// <unmanaged-short>GetDesc</unmanaged-short>	
        /// <unmanaged>HRESULT ID3D10EffectTechnique::GetDesc([Out] D3D10_TECHNIQUE_DESC* pDesc)</unmanaged>
        public SharpDX.Direct3D10.EffectTechniqueDescription Description {
                get { SharpDX.Direct3D10.EffectTechniqueDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Test a technique to see if it contains valid syntax.</p>	
        /// </summary>	
        /// <returns><p><strong>TRUE</strong> if the code syntax is valid; otherwise <strong><see cref="SharpDX.Result.False"/></strong>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectTechnique::IsValid']/*"/>	
        /// <msdn-id>bb173715</msdn-id>	
        /// <unmanaged>BOOL ID3D10EffectTechnique::IsValid()</unmanaged>	
        /// <unmanaged-short>ID3D10EffectTechnique::IsValid</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool IsValid_() {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer,((void**)(*(void**)_nativePointer))[0]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a technique description.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p>A reference to a technique description (see <strong><see cref="SharpDX.Direct3D10.EffectTechniqueDescription"/></strong>).</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectTechnique::GetDesc']/*"/>	
        /// <msdn-id>bb173712</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectTechnique::GetDesc([Out] D3D10_TECHNIQUE_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectTechnique::GetDesc</unmanaged-short>	
        internal void GetDescription(out SharpDX.Direct3D10.EffectTechniqueDescription descRef) {
            unsafe {
                var descRef_ = new SharpDX.Direct3D10.EffectTechniqueDescription.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &descRef_,((void**)(*(void**)_nativePointer))[1]);		
                descRef = new SharpDX.Direct3D10.EffectTechniqueDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get an annotation by index.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>The zero-based index of the interface reference.</p> </dd></param>	
        /// <returns><p>A reference to an <strong><see cref="SharpDX.Direct3D10.EffectVariable"/> Interface</strong>.</p></returns>	
        /// <remarks>	
        /// <p>Use an annotation to attach a piece of metadata to a technique.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectTechnique::GetAnnotationByIndex']/*"/>	
        /// <msdn-id>bb173710</msdn-id>	
        /// <unmanaged>ID3D10EffectVariable* ID3D10EffectTechnique::GetAnnotationByIndex([In] unsigned int Index)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectTechnique::GetAnnotationByIndex</unmanaged-short>	
        public SharpDX.Direct3D10.EffectVariable GetAnnotationByIndex(int index) {
            unsafe {
                SharpDX.Direct3D10.EffectVariable __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectVariable((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer, index,((void**)(*(void**)_nativePointer))[2]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get an annotation by name.</p>	
        /// </summary>	
        /// <param name="name"><dd>  <p>Name of the annotation.</p> </dd></param>	
        /// <returns><p>A reference to an <strong><see cref="SharpDX.Direct3D10.EffectVariable"/> Interface</strong>.</p></returns>	
        /// <remarks>	
        /// <p>Use an annotation to attach a piece of metadata to a technique.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectTechnique::GetAnnotationByName']/*"/>	
        /// <msdn-id>bb173711</msdn-id>	
        /// <unmanaged>ID3D10EffectVariable* ID3D10EffectTechnique::GetAnnotationByName([In] const char* Name)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectTechnique::GetAnnotationByName</unmanaged-short>	
        public SharpDX.Direct3D10.EffectVariable GetAnnotationByName(string name) {
            unsafe {
                IntPtr name_ = Utilities.StringToHGlobalAnsi(name);
                SharpDX.Direct3D10.EffectVariable __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectVariable((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer, (void*)name_,((void**)(*(void**)_nativePointer))[3]));		
                Marshal.FreeHGlobal(name_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a pass by index.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>A zero-based index.</p> </dd></param>	
        /// <returns><p>A reference to a <strong><see cref="SharpDX.Direct3D10.EffectPass"/> Interface</strong>.</p></returns>	
        /// <remarks>	
        /// <p>A technique contains one or more passes; get a pass using a name or an index.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectTechnique::GetPassByIndex']/*"/>	
        /// <msdn-id>bb173713</msdn-id>	
        /// <unmanaged>ID3D10EffectPass* ID3D10EffectTechnique::GetPassByIndex([In] unsigned int Index)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectTechnique::GetPassByIndex</unmanaged-short>	
        public SharpDX.Direct3D10.EffectPass GetPassByIndex(int index) {
            unsafe {
                SharpDX.Direct3D10.EffectPass __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectPass((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer, index,((void**)(*(void**)_nativePointer))[4]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a pass by name.</p>	
        /// </summary>	
        /// <param name="name"><dd>  <p>The name of the pass.</p> </dd></param>	
        /// <returns><p>A reference to an <strong><see cref="SharpDX.Direct3D10.EffectPass"/> Interface</strong>.</p></returns>	
        /// <remarks>	
        /// <p>A technique contains one or more passes; get a pass using a name or an index.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectTechnique::GetPassByName']/*"/>	
        /// <msdn-id>bb173714</msdn-id>	
        /// <unmanaged>ID3D10EffectPass* ID3D10EffectTechnique::GetPassByName([In] const char* Name)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectTechnique::GetPassByName</unmanaged-short>	
        public SharpDX.Direct3D10.EffectPass GetPassByName(string name) {
            unsafe {
                IntPtr name_ = Utilities.StringToHGlobalAnsi(name);
                SharpDX.Direct3D10.EffectPass __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectPass((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer, (void*)name_,((void**)(*(void**)_nativePointer))[5]));		
                Marshal.FreeHGlobal(name_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Compute a state-block mask to allow/prevent state changes.</p>	
        /// </summary>	
        /// <param name="stateBlockMaskRef"><dd>  <p>A reference to a state-block mask (see <strong><see cref="SharpDX.Direct3D10.StateBlockMask"/></strong>).</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectTechnique::ComputeStateBlockMask']/*"/>	
        /// <msdn-id>bb173709</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectTechnique::ComputeStateBlockMask([Out] D3D10_STATE_BLOCK_MASK* pStateBlockMask)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectTechnique::ComputeStateBlockMask</unmanaged-short>	
        public void ComputeStateBlockMask(out SharpDX.Direct3D10.StateBlockMask stateBlockMaskRef) {
            unsafe {
                var stateBlockMaskRef_ = new SharpDX.Direct3D10.StateBlockMask.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &stateBlockMaskRef_,((void**)(*(void**)_nativePointer))[6]);		
                stateBlockMaskRef = new SharpDX.Direct3D10.StateBlockMask();
                stateBlockMaskRef.__MarshalFrom(ref stateBlockMaskRef_);
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>Get an member type by name.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectType']/*"/>	
    /// <msdn-id>bb173721</msdn-id>	
    /// <unmanaged>ID3D10EffectType</unmanaged>	
    /// <unmanaged-short>ID3D10EffectType</unmanaged-short>	
    [Guid("4e9e1ddc-cd9d-4772-a837-00180b9b88fd")]
    public partial class EffectType : SharpDX.CppObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.EffectType"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EffectType(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.EffectType"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.EffectType(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.EffectType(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Tests that the effect type is valid.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectType::IsValid']/*"/>	
        /// <msdn-id>bb173723</msdn-id>	
        /// <unmanaged>IsValid</unmanaged>	
        /// <unmanaged-short>IsValid</unmanaged-short>	
        /// <unmanaged>BOOL ID3D10EffectType::IsValid()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsValid {
                get { return IsValid_(); }
        }
        
        /// <summary>	
        /// <p>Get an effect-type description.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>The effect-variable description contains data about the name, annotations, semantic, flags and buffer offset of the effect type.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectType::GetDesc']/*"/>	
        /// <msdn-id>bb173717</msdn-id>	
        /// <unmanaged>GetDesc</unmanaged>	
        /// <unmanaged-short>GetDesc</unmanaged-short>	
        /// <unmanaged>HRESULT ID3D10EffectType::GetDesc([Out] D3D10_EFFECT_TYPE_DESC* pDesc)</unmanaged>
        public SharpDX.Direct3D10.EffectTypeDescription Description {
                get { SharpDX.Direct3D10.EffectTypeDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Tests that the effect type is valid.</p>	
        /// </summary>	
        /// <returns><p><strong>TRUE</strong> if it is valid; otherwise <strong><see cref="SharpDX.Result.False"/></strong>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectType::IsValid']/*"/>	
        /// <msdn-id>bb173723</msdn-id>	
        /// <unmanaged>BOOL ID3D10EffectType::IsValid()</unmanaged>	
        /// <unmanaged-short>ID3D10EffectType::IsValid</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool IsValid_() {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer,((void**)(*(void**)_nativePointer))[0]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get an effect-type description.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p>A reference to an effect-type description. See <strong><see cref="SharpDX.Direct3D10.EffectTypeDescription"/></strong>.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>The effect-variable description contains data about the name, annotations, semantic, flags and buffer offset of the effect type.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectType::GetDesc']/*"/>	
        /// <msdn-id>bb173717</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectType::GetDesc([Out] D3D10_EFFECT_TYPE_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectType::GetDesc</unmanaged-short>	
        internal void GetDescription(out SharpDX.Direct3D10.EffectTypeDescription descRef) {
            unsafe {
                var descRef_ = new SharpDX.Direct3D10.EffectTypeDescription.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &descRef_,((void**)(*(void**)_nativePointer))[1]);		
                descRef = new SharpDX.Direct3D10.EffectTypeDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get a member type by index.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>A zero-based index.</p> </dd></param>	
        /// <returns><p>A reference to an <strong><see cref="SharpDX.Direct3D10.EffectType"/> Interface</strong>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectType::GetMemberTypeByIndex']/*"/>	
        /// <msdn-id>bb173720</msdn-id>	
        /// <unmanaged>ID3D10EffectType* ID3D10EffectType::GetMemberTypeByIndex([In] unsigned int Index)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectType::GetMemberTypeByIndex</unmanaged-short>	
        public SharpDX.Direct3D10.EffectType GetMemberTypeByIndex(int index) {
            unsafe {
                SharpDX.Direct3D10.EffectType __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectType((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer, index,((void**)(*(void**)_nativePointer))[2]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get an member type by name.</p>	
        /// </summary>	
        /// <param name="name"><dd>  <p>A member's name.</p> </dd></param>	
        /// <returns><p>A reference to an <strong><see cref="SharpDX.Direct3D10.EffectType"/> Interface</strong>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectType::GetMemberTypeByName']/*"/>	
        /// <msdn-id>bb173721</msdn-id>	
        /// <unmanaged>ID3D10EffectType* ID3D10EffectType::GetMemberTypeByName([In] const char* Name)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectType::GetMemberTypeByName</unmanaged-short>	
        public SharpDX.Direct3D10.EffectType GetMemberTypeByName(string name) {
            unsafe {
                IntPtr name_ = Utilities.StringToHGlobalAnsi(name);
                SharpDX.Direct3D10.EffectType __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectType((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer, (void*)name_,((void**)(*(void**)_nativePointer))[3]));		
                Marshal.FreeHGlobal(name_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a member type by semantic.</p>	
        /// </summary>	
        /// <param name="semantic"><dd>  <p>A semantic.</p> </dd></param>	
        /// <returns><p>A reference to an <strong><see cref="SharpDX.Direct3D10.EffectType"/> Interface</strong>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectType::GetMemberTypeBySemantic']/*"/>	
        /// <msdn-id>bb173722</msdn-id>	
        /// <unmanaged>ID3D10EffectType* ID3D10EffectType::GetMemberTypeBySemantic([In] const char* Semantic)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectType::GetMemberTypeBySemantic</unmanaged-short>	
        public SharpDX.Direct3D10.EffectType GetMemberTypeBySemantic(string semantic) {
            unsafe {
                IntPtr semantic_ = Utilities.StringToHGlobalAnsi(semantic);
                SharpDX.Direct3D10.EffectType __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectType((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer, (void*)semantic_,((void**)(*(void**)_nativePointer))[4]));		
                Marshal.FreeHGlobal(semantic_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get the name of a member.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>A zero-based index.</p> </dd></param>	
        /// <returns><p>The name of the member.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectType::GetMemberName']/*"/>	
        /// <msdn-id>bb173718</msdn-id>	
        /// <unmanaged>const char* ID3D10EffectType::GetMemberName([In] unsigned int Index)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectType::GetMemberName</unmanaged-short>	
        public string GetMemberName(int index) {
            unsafe {
                string __result__;
                __result__= 
				Marshal.PtrToStringAnsi(SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer, index,((void**)(*(void**)_nativePointer))[5]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get the semantic attached to a member.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>A zero-based index.</p> </dd></param>	
        /// <returns><p>A string that contains the semantic.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectType::GetMemberSemantic']/*"/>	
        /// <msdn-id>bb173719</msdn-id>	
        /// <unmanaged>const char* ID3D10EffectType::GetMemberSemantic([In] unsigned int Index)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectType::GetMemberSemantic</unmanaged-short>	
        public string GetMemberSemantic(int index) {
            unsafe {
                string __result__;
                __result__= 
				Marshal.PtrToStringAnsi(SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer, index,((void**)(*(void**)_nativePointer))[6]));		
                return __result__;
            }
        }
    }
    /// <summary>	
    /// <p>The <strong><see cref="SharpDX.Direct3D10.EffectVariable"/></strong> interface is the base class for all effect variables.</p><p>The lifetime of an <strong><see cref="SharpDX.Direct3D10.EffectVariable"/></strong> object is equal to the lifetime of its parent <strong><see cref="SharpDX.Direct3D10.Effect"/></strong> object.</p><ul> <li>Methods</li> </ul>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable']/*"/>	
    /// <msdn-id>bb173724</msdn-id>	
    /// <unmanaged>ID3D10EffectVariable</unmanaged>	
    /// <unmanaged-short>ID3D10EffectVariable</unmanaged-short>	
    [Guid("ae897105-00e6-45bf-bb8e-281dd6db8e1b")]
    public partial class EffectVariable : SharpDX.CppObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.EffectVariable"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EffectVariable(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.EffectVariable"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.EffectVariable(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.EffectVariable(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Compare the data type with the data stored.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method checks that the data type matches the data stored after casting one interface to another (using any of the As methods).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::IsValid']/*"/>	
        /// <msdn-id>bb173746</msdn-id>	
        /// <unmanaged>IsValid</unmanaged>	
        /// <unmanaged-short>IsValid</unmanaged-short>	
        /// <unmanaged>BOOL ID3D10EffectVariable::IsValid()</unmanaged>
        public SharpDX.Mathematics.Interop.RawBool IsValid {
                get { return IsValid_(); }
        }
        
        /// <summary>	
        /// <p>Get type information.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::GetType']/*"/>	
        /// <msdn-id>bb173745</msdn-id>	
        /// <unmanaged>GetType</unmanaged>	
        /// <unmanaged-short>GetType</unmanaged-short>	
        /// <unmanaged>ID3D10EffectType* ID3D10EffectVariable::GetType()</unmanaged>
        public SharpDX.Direct3D10.EffectType TypeInfo {
                get { return GetTypeInfo(); }
        }
        
        /// <summary>	
        /// <p>Get a description.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::GetDesc']/*"/>	
        /// <msdn-id>bb173738</msdn-id>	
        /// <unmanaged>GetDesc</unmanaged>	
        /// <unmanaged-short>GetDesc</unmanaged-short>	
        /// <unmanaged>HRESULT ID3D10EffectVariable::GetDesc([Out] D3D10_EFFECT_VARIABLE_DESC* pDesc)</unmanaged>
        public SharpDX.Direct3D10.EffectVariableDescription Description {
                get { SharpDX.Direct3D10.EffectVariableDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Get a constant buffer.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>Effect variables are read-from or written-to a constant buffer.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::GetParentConstantBuffer']/*"/>	
        /// <msdn-id>bb173743</msdn-id>	
        /// <unmanaged>GetParentConstantBuffer</unmanaged>	
        /// <unmanaged-short>GetParentConstantBuffer</unmanaged-short>	
        /// <unmanaged>ID3D10EffectConstantBuffer* ID3D10EffectVariable::GetParentConstantBuffer()</unmanaged>
        public SharpDX.Direct3D10.EffectConstantBuffer ParentConstantBuffer {
                get { return GetParentConstantBuffer(); }
        }
        
        /// <summary>	
        /// <p>Compare the data type with the data stored.</p>	
        /// </summary>	
        /// <returns><p><strong>TRUE</strong> if the syntax is valid; otherwise <strong><see cref="SharpDX.Result.False"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>This method checks that the data type matches the data stored after casting one interface to another (using any of the As methods).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::IsValid']/*"/>	
        /// <msdn-id>bb173746</msdn-id>	
        /// <unmanaged>BOOL ID3D10EffectVariable::IsValid()</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVariable::IsValid</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool IsValid_() {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer,((void**)(*(void**)_nativePointer))[0]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get type information.</p>	
        /// </summary>	
        /// <returns><p>A reference to an <strong><see cref="SharpDX.Direct3D10.EffectType"/> Interface</strong>.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::GetType']/*"/>	
        /// <msdn-id>bb173745</msdn-id>	
        /// <unmanaged>ID3D10EffectType* ID3D10EffectVariable::GetType()</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVariable::GetType</unmanaged-short>	
        internal SharpDX.Direct3D10.EffectType GetTypeInfo() {
            unsafe {
                SharpDX.Direct3D10.EffectType __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectType((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer,((void**)(*(void**)_nativePointer))[1]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a description.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p>A reference to an effect-variable description (see <strong><see cref="SharpDX.Direct3D10.EffectVariableDescription"/></strong>).</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::GetDesc']/*"/>	
        /// <msdn-id>bb173738</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectVariable::GetDesc([Out] D3D10_EFFECT_VARIABLE_DESC* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVariable::GetDesc</unmanaged-short>	
        internal void GetDescription(out SharpDX.Direct3D10.EffectVariableDescription descRef) {
            unsafe {
                var descRef_ = new SharpDX.Direct3D10.EffectVariableDescription.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &descRef_,((void**)(*(void**)_nativePointer))[2]);		
                descRef = new SharpDX.Direct3D10.EffectVariableDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get an annotation by index.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>A zero-based index.</p> </dd></param>	
        /// <returns><p>A reference to an <strong><see cref="SharpDX.Direct3D10.EffectVariable"/> Interface</strong>.</p></returns>	
        /// <remarks>	
        /// <p>Annonations can be attached to a technique, a pass or a gloval variable. For the syntax, see Annotation Syntax (Direct3D 10).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::GetAnnotationByIndex']/*"/>	
        /// <msdn-id>bb173736</msdn-id>	
        /// <unmanaged>ID3D10EffectVariable* ID3D10EffectVariable::GetAnnotationByIndex([In] unsigned int Index)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVariable::GetAnnotationByIndex</unmanaged-short>	
        public SharpDX.Direct3D10.EffectVariable GetAnnotationByIndex(int index) {
            unsafe {
                SharpDX.Direct3D10.EffectVariable __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectVariable((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer, index,((void**)(*(void**)_nativePointer))[3]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get an annotation by name.</p>	
        /// </summary>	
        /// <param name="name"><dd>  <p>The annotation name.</p> </dd></param>	
        /// <returns><p>A reference to an <strong><see cref="SharpDX.Direct3D10.EffectVariable"/> Interface</strong>.  Note that if the annotation is not found the <strong><see cref="SharpDX.Direct3D10.EffectVariable"/> Interface</strong> returned will be empty. The <strong><see cref="SharpDX.Direct3D10.EffectVariable.IsValid_"/></strong> method should be called to determine whether the annotation was found.</p></returns>	
        /// <remarks>	
        /// <p>Annonations can be attached to a technique, a pass or a gloval variable. For the syntax, see Annotation Syntax (Direct3D 10).</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::GetAnnotationByName']/*"/>	
        /// <msdn-id>bb173737</msdn-id>	
        /// <unmanaged>ID3D10EffectVariable* ID3D10EffectVariable::GetAnnotationByName([In] const char* Name)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVariable::GetAnnotationByName</unmanaged-short>	
        public SharpDX.Direct3D10.EffectVariable GetAnnotationByName(string name) {
            unsafe {
                IntPtr name_ = Utilities.StringToHGlobalAnsi(name);
                SharpDX.Direct3D10.EffectVariable __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectVariable((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer, (void*)name_,((void**)(*(void**)_nativePointer))[4]));		
                Marshal.FreeHGlobal(name_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a structure member by index.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>A zero-based index.</p> </dd></param>	
        /// <returns><p>A reference to an <strong><see cref="SharpDX.Direct3D10.EffectVariable"/> Interface</strong>.</p></returns>	
        /// <remarks>	
        /// <p>If the effect variable is an structure, use this method to look up a member by index.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::GetMemberByIndex']/*"/>	
        /// <msdn-id>bb173740</msdn-id>	
        /// <unmanaged>ID3D10EffectVariable* ID3D10EffectVariable::GetMemberByIndex([In] unsigned int Index)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVariable::GetMemberByIndex</unmanaged-short>	
        public SharpDX.Direct3D10.EffectVariable GetMemberByIndex(int index) {
            unsafe {
                SharpDX.Direct3D10.EffectVariable __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectVariable((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer, index,((void**)(*(void**)_nativePointer))[5]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a structure member by name.</p>	
        /// </summary>	
        /// <param name="name"><dd>  <p>Member name.</p> </dd></param>	
        /// <returns><p>A reference to an <strong><see cref="SharpDX.Direct3D10.EffectVariable"/> Interface</strong>.</p></returns>	
        /// <remarks>	
        /// <p>If the effect variable is an structure, use this method to look up a member by name.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::GetMemberByName']/*"/>	
        /// <msdn-id>bb173741</msdn-id>	
        /// <unmanaged>ID3D10EffectVariable* ID3D10EffectVariable::GetMemberByName([In] const char* Name)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVariable::GetMemberByName</unmanaged-short>	
        public SharpDX.Direct3D10.EffectVariable GetMemberByName(string name) {
            unsafe {
                IntPtr name_ = Utilities.StringToHGlobalAnsi(name);
                SharpDX.Direct3D10.EffectVariable __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectVariable((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer, (void*)name_,((void**)(*(void**)_nativePointer))[6]));		
                Marshal.FreeHGlobal(name_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a structure member by semantic.</p>	
        /// </summary>	
        /// <param name="semantic"><dd>  <p>The semantic.</p> </dd></param>	
        /// <returns><p>A reference to an <strong><see cref="SharpDX.Direct3D10.EffectVariable"/> Interface</strong>.</p></returns>	
        /// <remarks>	
        /// <p>If the effect variable is an structure, use this method to look up a member by attached semantic.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::GetMemberBySemantic']/*"/>	
        /// <msdn-id>bb173742</msdn-id>	
        /// <unmanaged>ID3D10EffectVariable* ID3D10EffectVariable::GetMemberBySemantic([In] const char* Semantic)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVariable::GetMemberBySemantic</unmanaged-short>	
        public SharpDX.Direct3D10.EffectVariable GetMemberBySemantic(string semantic) {
            unsafe {
                IntPtr semantic_ = Utilities.StringToHGlobalAnsi(semantic);
                SharpDX.Direct3D10.EffectVariable __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectVariable((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer, (void*)semantic_,((void**)(*(void**)_nativePointer))[7]));		
                Marshal.FreeHGlobal(semantic_ );
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get an array element.</p>	
        /// </summary>	
        /// <param name="index"><dd>  <p>A zero-based index; otherwise 0.</p> </dd></param>	
        /// <returns><p>A reference to an <strong><see cref="SharpDX.Direct3D10.EffectVariable"/> Interface</strong>.</p></returns>	
        /// <remarks>	
        /// <p>If the effect variable is an array, use this method to return one of the elements.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::GetElement']/*"/>	
        /// <msdn-id>bb173739</msdn-id>	
        /// <unmanaged>ID3D10EffectVariable* ID3D10EffectVariable::GetElement([In] unsigned int Index)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVariable::GetElement</unmanaged-short>	
        public SharpDX.Direct3D10.EffectVariable GetElement(int index) {
            unsafe {
                SharpDX.Direct3D10.EffectVariable __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectVariable((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer, index,((void**)(*(void**)_nativePointer))[8]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a constant buffer.</p>	
        /// </summary>	
        /// <returns><p>A reference to a <strong><see cref="SharpDX.Direct3D10.EffectConstantBuffer"/> Interface</strong>.</p></returns>	
        /// <remarks>	
        /// <p>Effect variables are read-from or written-to a constant buffer.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::GetParentConstantBuffer']/*"/>	
        /// <msdn-id>bb173743</msdn-id>	
        /// <unmanaged>ID3D10EffectConstantBuffer* ID3D10EffectVariable::GetParentConstantBuffer()</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVariable::GetParentConstantBuffer</unmanaged-short>	
        internal SharpDX.Direct3D10.EffectConstantBuffer GetParentConstantBuffer() {
            unsafe {
                SharpDX.Direct3D10.EffectConstantBuffer __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectConstantBuffer((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer,((void**)(*(void**)_nativePointer))[9]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a scalar variable.</p>	
        /// </summary>	
        /// <returns><p>A reference to a scalar variable. See <strong><see cref="SharpDX.Direct3D10.EffectScalarVariable"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>AsScalar returns a version of the effect variable that has been specialized to a scalar variable. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain scalar data.</p><p>Applications can test the returned object for validity by calling <strong>IsValid</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::AsScalar']/*"/>	
        /// <msdn-id>bb173731</msdn-id>	
        /// <unmanaged>ID3D10EffectScalarVariable* ID3D10EffectVariable::AsScalar()</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVariable::AsScalar</unmanaged-short>	
        internal SharpDX.Direct3D10.EffectScalarVariable AsScalar_() {
            unsafe {
                SharpDX.Direct3D10.EffectScalarVariable __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectScalarVariable((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer,((void**)(*(void**)_nativePointer))[10]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a vector variable.</p>	
        /// </summary>	
        /// <returns><p>A reference to a vector variable. See <strong><see cref="SharpDX.Direct3D10.EffectVectorVariable"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>AsVector returns a version of the effect variable that has been specialized to a vector variable. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain vector data.</p><p>Applications can test the returned object for validity by calling <strong>IsValid</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::AsVector']/*"/>	
        /// <msdn-id>bb173735</msdn-id>	
        /// <unmanaged>ID3D10EffectVectorVariable* ID3D10EffectVariable::AsVector()</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVariable::AsVector</unmanaged-short>	
        internal SharpDX.Direct3D10.EffectVectorVariable AsVector_() {
            unsafe {
                SharpDX.Direct3D10.EffectVectorVariable __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectVectorVariable((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer,((void**)(*(void**)_nativePointer))[11]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a matrix variable.</p>	
        /// </summary>	
        /// <returns><p>A reference to a matrix variable. See <strong><see cref="SharpDX.Direct3D10.EffectMatrixVariable"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>AsMatrix returns a version of the effect variable that has been specialized to a matrix variable. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain matrix data.</p><p>Applications can test the returned object for validity by calling <strong>IsValid</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::AsMatrix']/*"/>	
        /// <msdn-id>bb173728</msdn-id>	
        /// <unmanaged>ID3D10EffectMatrixVariable* ID3D10EffectVariable::AsMatrix()</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVariable::AsMatrix</unmanaged-short>	
        internal SharpDX.Direct3D10.EffectMatrixVariable AsMatrix_() {
            unsafe {
                SharpDX.Direct3D10.EffectMatrixVariable __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectMatrixVariable((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer,((void**)(*(void**)_nativePointer))[12]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a string variable.</p>	
        /// </summary>	
        /// <returns><p>A reference to a string variable. See <strong><see cref="SharpDX.Direct3D10.EffectStringVariable"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>AsString returns a version of the effect variable that has been specialized to a string variable. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain string data.</p><p>Applications can test the returned object for validity by calling <strong>IsValid</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::AsString']/*"/>	
        /// <msdn-id>bb173734</msdn-id>	
        /// <unmanaged>ID3D10EffectStringVariable* ID3D10EffectVariable::AsString()</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVariable::AsString</unmanaged-short>	
        internal SharpDX.Direct3D10.EffectStringVariable AsString_() {
            unsafe {
                SharpDX.Direct3D10.EffectStringVariable __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectStringVariable((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer,((void**)(*(void**)_nativePointer))[13]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a shader-resource variable.</p>	
        /// </summary>	
        /// <returns><p>A reference to a shader-resource variable. See <strong><see cref="SharpDX.Direct3D10.EffectShaderResourceVariable"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>AsShaderResource returns a version of the effect variable that has been specialized to a shader-resource variable. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain shader-resource data.</p><p>Applications can test the returned object for validity by calling <strong>IsValid</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::AsShaderResource']/*"/>	
        /// <msdn-id>bb173733</msdn-id>	
        /// <unmanaged>ID3D10EffectShaderResourceVariable* ID3D10EffectVariable::AsShaderResource()</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVariable::AsShaderResource</unmanaged-short>	
        internal SharpDX.Direct3D10.EffectShaderResourceVariable AsShaderResource_() {
            unsafe {
                SharpDX.Direct3D10.EffectShaderResourceVariable __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectShaderResourceVariable((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer,((void**)(*(void**)_nativePointer))[14]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a render-target-view variable.</p>	
        /// </summary>	
        /// <returns><p>A reference to a render-target-view variable. See <strong><see cref="SharpDX.Direct3D10.EffectRenderTargetViewVariable"/> Interface</strong>.</p></returns>	
        /// <remarks>	
        /// <p>This method returns a version of the effect variable that has been specialized to a render-target-view variable. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain render-target-view data.</p><p>Applications can test the returned object for validity by calling <strong>IsValid</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::AsRenderTargetView']/*"/>	
        /// <msdn-id>bb944008</msdn-id>	
        /// <unmanaged>ID3D10EffectRenderTargetViewVariable* ID3D10EffectVariable::AsRenderTargetView()</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVariable::AsRenderTargetView</unmanaged-short>	
        internal SharpDX.Direct3D10.EffectRenderTargetViewVariable AsRenderTargetView_() {
            unsafe {
                SharpDX.Direct3D10.EffectRenderTargetViewVariable __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectRenderTargetViewVariable((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer,((void**)(*(void**)_nativePointer))[15]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a depth-stencil-view variable.</p>	
        /// </summary>	
        /// <returns><p>A reference to a depth-stencil-view variable. See <strong><see cref="SharpDX.Direct3D10.EffectDepthStencilViewVariable"/> Interface</strong>.</p></returns>	
        /// <remarks>	
        /// <p>This method returns a version of the effect variable that has been specialized to a depth-stencil-view variable. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain depth-stencil-view data.</p><p>Applications can test the returned object for validity by calling <strong>IsValid</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::AsDepthStencilView']/*"/>	
        /// <msdn-id>bb944007</msdn-id>	
        /// <unmanaged>ID3D10EffectDepthStencilViewVariable* ID3D10EffectVariable::AsDepthStencilView()</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVariable::AsDepthStencilView</unmanaged-short>	
        internal SharpDX.Direct3D10.EffectDepthStencilViewVariable AsDepthStencilView_() {
            unsafe {
                SharpDX.Direct3D10.EffectDepthStencilViewVariable __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectDepthStencilViewVariable((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer,((void**)(*(void**)_nativePointer))[16]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a constant buffer.</p>	
        /// </summary>	
        /// <returns><p>A reference to a constant buffer. See <strong><see cref="SharpDX.Direct3D10.EffectConstantBuffer"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>AsConstantBuffer returns a version of the effect variable that has been specialized to a constant buffer. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain constant buffer data.</p><p>Applications can test the returned object for validity by calling <strong>IsValid</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::AsConstantBuffer']/*"/>	
        /// <msdn-id>bb173726</msdn-id>	
        /// <unmanaged>ID3D10EffectConstantBuffer* ID3D10EffectVariable::AsConstantBuffer()</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVariable::AsConstantBuffer</unmanaged-short>	
        internal SharpDX.Direct3D10.EffectConstantBuffer AsConstantBuffer_() {
            unsafe {
                SharpDX.Direct3D10.EffectConstantBuffer __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectConstantBuffer((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer,((void**)(*(void**)_nativePointer))[17]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a shader variable.</p>	
        /// </summary>	
        /// <returns><p>A reference to a shader variable. See <strong><see cref="SharpDX.Direct3D10.EffectShaderVariable"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>AsShader returns a version of the effect variable that has been specialized to a shader variable. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain shader data.</p><p>Applications can test the returned object for validity by calling <strong>IsValid</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::AsShader']/*"/>	
        /// <msdn-id>bb173732</msdn-id>	
        /// <unmanaged>ID3D10EffectShaderVariable* ID3D10EffectVariable::AsShader()</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVariable::AsShader</unmanaged-short>	
        internal SharpDX.Direct3D10.EffectShaderVariable AsShader_() {
            unsafe {
                SharpDX.Direct3D10.EffectShaderVariable __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectShaderVariable((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer,((void**)(*(void**)_nativePointer))[18]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a effect-blend variable.</p>	
        /// </summary>	
        /// <returns><p>A reference to an effect blend variable. See <strong><see cref="SharpDX.Direct3D10.EffectBlendVariable"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>AsBlend returns a version of the effect variable that has been specialized to an effect-blend variable. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain effect-blend data.</p><p>Applications can test the returned object for validity by calling <strong>IsValid</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::AsBlend']/*"/>	
        /// <msdn-id>bb173725</msdn-id>	
        /// <unmanaged>ID3D10EffectBlendVariable* ID3D10EffectVariable::AsBlend()</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVariable::AsBlend</unmanaged-short>	
        internal SharpDX.Direct3D10.EffectBlendVariable AsBlend_() {
            unsafe {
                SharpDX.Direct3D10.EffectBlendVariable __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectBlendVariable((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer,((void**)(*(void**)_nativePointer))[19]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a depth-stencil variable.</p>	
        /// </summary>	
        /// <returns><p>A reference to a depth-stencil variable. See <strong><see cref="SharpDX.Direct3D10.EffectDepthStencilVariable"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>AsDepthStencil returns a version of the effect variable that has been specialized to a depth-stencil variable. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain depth-stencil data.</p><p>Applications can test the returned object for validity by calling <strong>IsValid</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::AsDepthStencil']/*"/>	
        /// <msdn-id>bb173727</msdn-id>	
        /// <unmanaged>ID3D10EffectDepthStencilVariable* ID3D10EffectVariable::AsDepthStencil()</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVariable::AsDepthStencil</unmanaged-short>	
        internal SharpDX.Direct3D10.EffectDepthStencilVariable AsDepthStencil_() {
            unsafe {
                SharpDX.Direct3D10.EffectDepthStencilVariable __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectDepthStencilVariable((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer,((void**)(*(void**)_nativePointer))[20]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a rasterizer variable.</p>	
        /// </summary>	
        /// <returns><p>A reference to a rasterizer variable. See <strong><see cref="SharpDX.Direct3D10.EffectRasterizerVariable"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>AsRasterizer returns a version of the effect variable that has been specialized to a rasterizer variable. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain rasterizer data.</p><p>Applications can test the returned object for validity by calling <strong>IsValid</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::AsRasterizer']/*"/>	
        /// <msdn-id>bb173729</msdn-id>	
        /// <unmanaged>ID3D10EffectRasterizerVariable* ID3D10EffectVariable::AsRasterizer()</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVariable::AsRasterizer</unmanaged-short>	
        internal SharpDX.Direct3D10.EffectRasterizerVariable AsRasterizer_() {
            unsafe {
                SharpDX.Direct3D10.EffectRasterizerVariable __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectRasterizerVariable((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer,((void**)(*(void**)_nativePointer))[21]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Get a sampler variable.</p>	
        /// </summary>	
        /// <returns><p>A reference to a sampler variable. See <strong><see cref="SharpDX.Direct3D10.EffectSamplerVariable"/></strong>.</p></returns>	
        /// <remarks>	
        /// <p>AsSampler returns a version of the effect variable that has been specialized to a sampler variable. Similar to a cast, this specialization will return an invalid object if the effect variable does not contain sampler data.</p><p>Applications can test the returned object for validity by calling <strong>IsValid</strong>.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::AsSampler']/*"/>	
        /// <msdn-id>bb173730</msdn-id>	
        /// <unmanaged>ID3D10EffectSamplerVariable* ID3D10EffectVariable::AsSampler()</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVariable::AsSampler</unmanaged-short>	
        internal SharpDX.Direct3D10.EffectSamplerVariable AsSampler_() {
            unsafe {
                SharpDX.Direct3D10.EffectSamplerVariable __result__;
                __result__= 
				new SharpDX.Direct3D10.EffectSamplerVariable((IntPtr)SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer,((void**)(*(void**)_nativePointer))[22]));		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Set data.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the variable.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>The offset (in bytes) from the beginning of the reference to the data.</p> </dd></param>	
        /// <param name="byteCount"><dd>  <p>The number of bytes to set.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>This method does no conversion or type checking; it is therefore a very quick way to access array items.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::SetRawValue']/*"/>	
        /// <msdn-id>bb173747</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectVariable::SetRawValue([In, Buffer] void* pData,[In] unsigned int Offset,[In] unsigned int ByteCount)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVariable::SetRawValue</unmanaged-short>	
        public void SetRawValue(System.IntPtr dataRef, int offset, int byteCount) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)dataRef, offset, byteCount,((void**)(*(void**)_nativePointer))[23]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get data.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the variable.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>The offset (in bytes) from the beginning of the reference to the data.</p> </dd></param>	
        /// <param name="byteCount"><dd>  <p>The number of bytes to get.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <remarks>	
        /// <p>This method does no conversion or type checking; it is therefore a very quick way to access array items.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVariable::GetRawValue']/*"/>	
        /// <msdn-id>bb173744</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectVariable::GetRawValue([Out, Buffer] void* pData,[In] unsigned int Offset,[In] unsigned int ByteCount)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVariable::GetRawValue</unmanaged-short>	
        public void GetRawValue(System.IntPtr dataRef, int offset, int byteCount) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)dataRef, offset, byteCount,((void**)(*(void**)_nativePointer))[24]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>A vector-variable interface accesses a four-component vector.</p>	
    /// </summary>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVectorVariable']/*"/>	
    /// <msdn-id>bb173748</msdn-id>	
    /// <unmanaged>ID3D10EffectVectorVariable</unmanaged>	
    /// <unmanaged-short>ID3D10EffectVectorVariable</unmanaged-short>	
    [Guid("62b98c44-1f82-4c67-bcd0-72cf8f217e81")]
    public partial class EffectVectorVariable : SharpDX.Direct3D10.EffectVariable {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.EffectVectorVariable"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public EffectVectorVariable(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.EffectVectorVariable"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.EffectVectorVariable(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.EffectVectorVariable(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Set a four-component vector that contains boolean data.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the first component.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVectorVariable::SetBoolVector']/*"/>	
        /// <msdn-id>bb173755</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectVectorVariable::SetBoolVector([In] SHARPDX_BOOL4* pData)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVectorVariable::SetBoolVector</unmanaged-short>	
        public void Set(SharpDX.Mathematics.Interop.RawBool4 dataRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &dataRef,((void**)(*(void**)_nativePointer))[25]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Set a four-component vector that contains integer data.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the first component.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVectorVariable::SetIntVector']/*"/>	
        /// <msdn-id>bb173759</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectVectorVariable::SetIntVector([In] SHARPDX_INT4* pData)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVectorVariable::SetIntVector</unmanaged-short>	
        public void Set(SharpDX.Mathematics.Interop.RawInt4 dataRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &dataRef,((void**)(*(void**)_nativePointer))[26]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Set a four-component vector that contains floating-point data.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the first component.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVectorVariable::SetFloatVector']/*"/>	
        /// <msdn-id>bb173757</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectVectorVariable::SetFloatVector([In] float* pData)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVectorVariable::SetFloatVector</unmanaged-short>	
        public void Set(float dataRef) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &dataRef,((void**)(*(void**)_nativePointer))[27]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get a four-component vector that contains boolean data.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the first component.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVectorVariable::GetBoolVector']/*"/>	
        /// <msdn-id>bb173749</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectVectorVariable::GetBoolVector([Out] SHARPDX_BOOL4* pData)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVectorVariable::GetBoolVector</unmanaged-short>	
        internal void GetBoolVector(out SharpDX.Mathematics.Interop.RawBool4 dataRef) {
            unsafe {
                dataRef = new SharpDX.Mathematics.Interop.RawBool4();
                SharpDX.Result __result__;
                fixed (void* dataRef_ = &dataRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, dataRef_,((void**)(*(void**)_nativePointer))[28]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get a four-component vector that contains integer data.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the first component.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVectorVariable::GetIntVector']/*"/>	
        /// <msdn-id>bb173753</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectVectorVariable::GetIntVector([Out] SHARPDX_INT4* pData)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVectorVariable::GetIntVector</unmanaged-short>	
        internal void GetIntVector(out SharpDX.Mathematics.Interop.RawInt4 dataRef) {
            unsafe {
                dataRef = new SharpDX.Mathematics.Interop.RawInt4();
                SharpDX.Result __result__;
                fixed (void* dataRef_ = &dataRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, dataRef_,((void**)(*(void**)_nativePointer))[29]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get a four-component vector that contains floating-point data.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the first component.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVectorVariable::GetFloatVector']/*"/>	
        /// <msdn-id>bb173751</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectVectorVariable::GetFloatVector([Out] SHARPDX_VECTOR4* pData)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVectorVariable::GetFloatVector</unmanaged-short>	
        internal void GetFloatVector(out SharpDX.Mathematics.Interop.RawVector4 dataRef) {
            unsafe {
                dataRef = new SharpDX.Mathematics.Interop.RawVector4();
                SharpDX.Result __result__;
                fixed (void* dataRef_ = &dataRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, dataRef_,((void**)(*(void**)_nativePointer))[30]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Set an array of four-component vectors that contain boolean data.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the start of the data to set.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>Must be set to 0; this is reserved for future use. </p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of array elements to set.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVectorVariable::SetBoolVectorArray']/*"/>	
        /// <msdn-id>bb173756</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectVectorVariable::SetBoolVectorArray([In, Buffer] SHARPDX_BOOL4* pData,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVectorVariable::SetBoolVectorArray</unmanaged-short>	
        internal void Set(SharpDX.Mathematics.Interop.RawBool4[] dataRef, int offset, int count) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dataRef_ = dataRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, dataRef_, offset, count,((void**)(*(void**)_nativePointer))[31]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Set an array of four-component vectors that contain integer data.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the start of the data to set.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>Must be set to 0; this is reserved for future use. </p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of array elements to set.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVectorVariable::SetIntVectorArray']/*"/>	
        /// <msdn-id>bb173760</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectVectorVariable::SetIntVectorArray([In, Buffer] SHARPDX_INT4* pData,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVectorVariable::SetIntVectorArray</unmanaged-short>	
        internal void Set(SharpDX.Mathematics.Interop.RawInt4[] dataRef, int offset, int count) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dataRef_ = dataRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, dataRef_, offset, count,((void**)(*(void**)_nativePointer))[32]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Set an array of four-component vectors that contain floating-point data.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the start of the data to set.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>Must be set to 0; this is reserved for future use. </p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of array elements to set.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVectorVariable::SetFloatVectorArray']/*"/>	
        /// <msdn-id>bb173758</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectVectorVariable::SetFloatVectorArray([In, Buffer] SHARPDX_VECTOR4* pData,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVectorVariable::SetFloatVectorArray</unmanaged-short>	
        internal void Set(SharpDX.Mathematics.Interop.RawVector4[] dataRef, int offset, int count) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dataRef_ = dataRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, dataRef_, offset, count,((void**)(*(void**)_nativePointer))[33]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get an array of four-component vectors that contain boolean data.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the start of the data to set.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>Must be set to 0; this is reserved for future use. </p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of array elements to set.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVectorVariable::GetBoolVectorArray']/*"/>	
        /// <msdn-id>bb173750</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectVectorVariable::GetBoolVectorArray([Out, Buffer] SHARPDX_BOOL4* pData,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVectorVariable::GetBoolVectorArray</unmanaged-short>	
        internal void GetBoolVectorArray(SharpDX.Mathematics.Interop.RawBool4[] dataRef, int offset, int count) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dataRef_ = dataRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, dataRef_, offset, count,((void**)(*(void**)_nativePointer))[34]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get an array of four-component vectors that contain integer data.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the start of the data to set.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>Must be set to 0; this is reserved for future use. </p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of array elements to set.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVectorVariable::GetIntVectorArray']/*"/>	
        /// <msdn-id>bb173754</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectVectorVariable::GetIntVectorArray([Out, Buffer] SHARPDX_INT4* pData,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVectorVariable::GetIntVectorArray</unmanaged-short>	
        internal void GetIntVectorArray(SharpDX.Mathematics.Interop.RawInt4[] dataRef, int offset, int count) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dataRef_ = dataRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, dataRef_, offset, count,((void**)(*(void**)_nativePointer))[35]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get an array of four-component vectors that contain floating-point data.</p>	
        /// </summary>	
        /// <param name="dataRef"><dd>  <p>A reference to the start of the data to set.</p> </dd></param>	
        /// <param name="offset"><dd>  <p>Must be set to 0; this is reserved for future use. </p> </dd></param>	
        /// <param name="count"><dd>  <p>The number of array elements to set.</p> </dd></param>	
        /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10EffectVectorVariable::GetFloatVectorArray']/*"/>	
        /// <msdn-id>bb173752</msdn-id>	
        /// <unmanaged>HRESULT ID3D10EffectVectorVariable::GetFloatVectorArray([Out, Buffer] SHARPDX_VECTOR4* pData,[In] unsigned int Offset,[In] unsigned int Count)</unmanaged>	
        /// <unmanaged-short>ID3D10EffectVectorVariable::GetFloatVectorArray</unmanaged-short>	
        internal void GetFloatVectorArray(SharpDX.Mathematics.Interop.RawVector4[] dataRef, int offset, int count) {
            unsafe {
                SharpDX.Result __result__;
                fixed (void* dataRef_ = dataRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, dataRef_, offset, count,((void**)(*(void**)_nativePointer))[36]);		
                __result__.CheckError();
            }
        }
    }
    /// <summary>	
    /// <p>The <see cref="SharpDX.Direct3D10.Font"/> interface encapsulates the textures and resources needed to render a specific font on a specific device.</p>	
    /// </summary>	
    /// <remarks>	
    /// <p>The <see cref="SharpDX.Direct3D10.Font"/> interface is obtained by calling <strong><see cref="SharpDX.Direct3D10.D3DX10.CreateFont"/></strong> or <strong><see cref="SharpDX.Direct3D10.D3DX10.CreateFontIndirect"/></strong>.</p><p>The LPD3DX10FONT type is defined as a reference to the <see cref="SharpDX.Direct3D10.Font"/> interface.</p><pre> typedef interface <see cref="SharpDX.Direct3D10.Font"/> <see cref="SharpDX.Direct3D10.Font"/>;	
    /// typedef interface <see cref="SharpDX.Direct3D10.Font"/> *LPD3DX10FONT;	
    /// </pre>	
    /// </remarks>	
    /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Font']/*"/>	
    /// <msdn-id>bb173886</msdn-id>	
    /// <unmanaged>ID3DX10Font</unmanaged>	
    /// <unmanaged-short>ID3DX10Font</unmanaged-short>	
    [Guid("d79dbb70-5f21-4d36-bbc2-ff525c213cdc")]
    public partial class Font : SharpDX.ComObject {
        /// <summary>
        /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.Font"/> class.
        /// </summary>
        /// <param name="nativePtr">The native pointer.</param>	
        public Font(IntPtr nativePtr) : base(nativePtr) {
        }

		/// <summary>
		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.Font"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
		/// </summary>
		/// <param name="nativePointer">The native pointer.</param>
		/// <returns>
		/// The result of the conversion.
		/// </returns>
		public static explicit operator SharpDX.Direct3D10.Font(IntPtr nativePointer)
		{
			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.Font(nativePointer);
		}
        
        
        /// <summary>	
        /// <p>Retrieve the Direct3D device associated with the font object.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p><strong>Note</strong>??Calling this method will increase the internal reference count on the <see cref="SharpDX.Direct3D10.Device"/> interface. Be sure to call <see cref="SharpDX.ComObject"/> when you are done using this <see cref="SharpDX.Direct3D10.Device"/> interface or you will have a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Font::GetDevice']/*"/>	
        /// <msdn-id>bb173891</msdn-id>	
        /// <unmanaged>GetDevice</unmanaged>	
        /// <unmanaged-short>GetDevice</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DX10Font::GetDevice([Out] ID3D10Device** ppDevice)</unmanaged>
        public SharpDX.Direct3D10.Device Device {
                get { SharpDX.Direct3D10.Device __output__; GetDevice(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Get a description of the current font object.</p>	
        /// </summary>	
        /// <remarks>	
        /// <p>This method describes Unicode font objects if UNICODE is defined. Otherwise GetDescA is called, which returns a reference to the D3DX10FONT_DESCA structure.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Font::GetDescW']/*"/>	
        /// <msdn-id>bb173890</msdn-id>	
        /// <unmanaged>GetDescW</unmanaged>	
        /// <unmanaged-short>GetDescW</unmanaged-short>	
        /// <unmanaged>HRESULT ID3DX10Font::GetDescW([Out] D3DX10_FONT_DESCW* pDesc)</unmanaged>
        public SharpDX.Direct3D10.FontDescription Description {
                get { SharpDX.Direct3D10.FontDescription __output__; GetDescription(out __output__); return __output__; }
        }
        
        /// <summary>	
        /// <p>Return a handle to a display device context (DC) that has the font set onto it.</p>	
        /// </summary>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Font::GetDC']/*"/>	
        /// <msdn-id>bb173889</msdn-id>	
        /// <unmanaged>GetDC</unmanaged>	
        /// <unmanaged-short>GetDC</unmanaged-short>	
        /// <unmanaged>HDC ID3DX10Font::GetDC()</unmanaged>
        public System.IntPtr DeviceContext {
                get { return GetDeviceContext(); }
        }
        
        /// <summary>	
        /// <p>Retrieve the Direct3D device associated with the font object.</p>	
        /// </summary>	
        /// <param name="deviceOut"><dd>  <p>Address of a reference to an <see cref="SharpDX.Direct3D10.Device"/> interface, representing the Direct3D device object associated with the font object.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p><strong>Note</strong>??Calling this method will increase the internal reference count on the <see cref="SharpDX.Direct3D10.Device"/> interface. Be sure to call <see cref="SharpDX.ComObject"/> when you are done using this <see cref="SharpDX.Direct3D10.Device"/> interface or you will have a memory leak.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Font::GetDevice']/*"/>	
        /// <msdn-id>bb173891</msdn-id>	
        /// <unmanaged>HRESULT ID3DX10Font::GetDevice([Out] ID3D10Device** ppDevice)</unmanaged>	
        /// <unmanaged-short>ID3DX10Font::GetDevice</unmanaged-short>	
        internal void GetDevice(out SharpDX.Direct3D10.Device deviceOut) {
            unsafe {
                IntPtr deviceOut_ = IntPtr.Zero;
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &deviceOut_,((void**)(*(void**)_nativePointer))[3]);		
                deviceOut= (deviceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.Device(deviceOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Get a description of the current font object.</p>	
        /// </summary>	
        /// <param name="descRef"><dd>  <p>Pointer to a <strong><see cref="SharpDX.Direct3D10.FontDescription"/></strong> structure that describes the font object. If UNICODE is defined, a reference to a D3DX10FONT_DESCW is returned; otherwise a reference to a D3DX10FONT_DESCA is returned.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: D3DERR_INVALIDCALL.</p></returns>	
        /// <remarks>	
        /// <p>This method describes Unicode font objects if UNICODE is defined. Otherwise GetDescA is called, which returns a reference to the D3DX10FONT_DESCA structure.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Font::GetDescW']/*"/>	
        /// <msdn-id>bb173890</msdn-id>	
        /// <unmanaged>HRESULT ID3DX10Font::GetDescW([Out] D3DX10_FONT_DESCW* pDesc)</unmanaged>	
        /// <unmanaged-short>ID3DX10Font::GetDescW</unmanaged-short>	
        internal void GetDescription(out SharpDX.Direct3D10.FontDescription descRef) {
            unsafe {
                var descRef_ = new SharpDX.Direct3D10.FontDescription.__Native();
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &descRef_,((void**)(*(void**)_nativePointer))[5]);		
                descRef = new SharpDX.Direct3D10.FontDescription();
                descRef.__MarshalFrom(ref descRef_);
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Retrieve font characteristics.</p>	
        /// </summary>	
        /// <param name="textMetricsRef"><dd>  <p>Pointer to a <see cref="SharpDX.Win32Native.TextMetric"/> structure, which contains font properties. If Unicode is defined, the function returns a <see cref="SharpDX.Win32Native.TextMetric"/> structure. Otherwise, the function returns a <see cref="SharpDX.Win32Native.TextMetricA"/> structure.</p> </dd></param>	
        /// <returns><p>Nonzero if the function is successful; otherwise 0.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Font::GetTextMetricsW']/*"/>	
        /// <msdn-id>bb173893</msdn-id>	
        /// <unmanaged>BOOL ID3DX10Font::GetTextMetricsW([In] void* pTextMetrics)</unmanaged>	
        /// <unmanaged-short>ID3DX10Font::GetTextMetricsW</unmanaged-short>	
        internal SharpDX.Mathematics.Interop.RawBool GetTextMetrics(System.IntPtr textMetricsRef) {
            unsafe {
                SharpDX.Mathematics.Interop.RawBool __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, (void*)textMetricsRef,((void**)(*(void**)_nativePointer))[7]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Return a handle to a display device context (DC) that has the font set onto it.</p>	
        /// </summary>	
        /// <returns><p>Handle to a display DC.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Font::GetDC']/*"/>	
        /// <msdn-id>bb173889</msdn-id>	
        /// <unmanaged>HDC ID3DX10Font::GetDC()</unmanaged>	
        /// <unmanaged-short>ID3DX10Font::GetDC</unmanaged-short>	
        internal System.IntPtr GetDeviceContext() {
            unsafe {
                System.IntPtr __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.CalliSystemIntPtr(_nativePointer,((void**)(*(void**)_nativePointer))[8]);		
                return __result__;
            }
        }
        
        /// <summary>	
        /// <p>Return information about the placement and orientation of a glyph in a character cell.</p>	
        /// </summary>	
        /// <param name="glyph"><dd>  <p>Glyph identifier.</p> </dd></param>	
        /// <param name="textureOut"><dd>  <p>Address of a reference to a ID3D10Texture object that contains the glyph.</p> </dd></param>	
        /// <param name="blackBoxRef"><dd>  <p>Pointer to the smallest rectangle object that completely encloses the glyph. See <see cref="SharpDX.Mathematics.Interop.RawRectangle"/>.</p> </dd></param>	
        /// <param name="cellIncRef"><dd>  <p>Pointer to the two-dimensional vector that connects the origin of the current character cell to the origin of the next character cell. See <see cref="SharpDX.Mathematics.Interop.RawPoint"/>.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA.</p></returns>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Font::GetGlyphData']/*"/>	
        /// <msdn-id>bb173892</msdn-id>	
        /// <unmanaged>HRESULT ID3DX10Font::GetGlyphData([In] unsigned int Glyph,[Out] ID3D10ShaderResourceView** ppTexture,[Out] RECT* pBlackBox,[Out] POINT* pCellInc)</unmanaged>	
        /// <unmanaged-short>ID3DX10Font::GetGlyphData</unmanaged-short>	
        public void GetGlyphData(int glyph, out SharpDX.Direct3D10.ShaderResourceView textureOut, out SharpDX.Mathematics.Interop.RawRectangle blackBoxRef, out SharpDX.Mathematics.Interop.RawPoint cellIncRef) {
            unsafe {
                IntPtr textureOut_ = IntPtr.Zero;
                blackBoxRef = new SharpDX.Mathematics.Interop.RawRectangle();
                cellIncRef = new SharpDX.Mathematics.Interop.RawPoint();
                SharpDX.Result __result__;
                fixed (void* blackBoxRef_ = &blackBoxRef)
                    fixed (void* cellIncRef_ = &cellIncRef)
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, glyph, &textureOut_, blackBoxRef_, cellIncRef_,((void**)(*(void**)_nativePointer))[9]);		
                textureOut= (textureOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.ShaderResourceView(textureOut_);	
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Load a series of characters into video memory to improve the efficiency of rendering to the device.</p>	
        /// </summary>	
        /// <param name="first"><dd>  <p>ID of the first character to be loaded into video memory.</p> </dd></param>	
        /// <param name="last"><dd>  <p>ID of the last character to be loaded into video memory.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p>This method generates textures containing glyphs that represent the input characters. The glyphs are drawn as a series of triangles.</p><p>Characters will not be rendered to the device; <see cref="SharpDX.Direct3D10.Font.DrawText"/> must still be called to render the characters. However, by pre-loading characters into video memory, <see cref="SharpDX.Direct3D10.Font.DrawText"/> will use substantially fewer CPU resources.</p><p>This method internally converts characters to glyphs using the GDI function GetCharacterPlacement.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Font::PreloadCharacters']/*"/>	
        /// <msdn-id>bb173894</msdn-id>	
        /// <unmanaged>HRESULT ID3DX10Font::PreloadCharacters([In] unsigned int First,[In] unsigned int Last)</unmanaged>	
        /// <unmanaged-short>ID3DX10Font::PreloadCharacters</unmanaged-short>	
        public void PreloadCharacters(int first, int last) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, first, last,((void**)(*(void**)_nativePointer))[10]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Load a series of glyphs into video memory to improve the efficiency of rendering to the device.</p>	
        /// </summary>	
        /// <param name="first"><dd>  <p>ID of the first glyph to be loaded into video memory.</p> </dd></param>	
        /// <param name="last"><dd>  <p>ID of the last glyph to be loaded into video memory.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p>This method generates textures that contain the input glyphs. The glyphs are drawn as a series of triangles.</p><p>Glyphs will not be rendered to the device; <see cref="SharpDX.Direct3D10.Font.DrawText"/> must still be called to render the glyphs. However, by pre-loading glyphs into video memory, <see cref="SharpDX.Direct3D10.Font.DrawText"/> will use substantially fewer CPU resources.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Font::PreloadGlyphs']/*"/>	
        /// <msdn-id>bb173895</msdn-id>	
        /// <unmanaged>HRESULT ID3DX10Font::PreloadGlyphs([In] unsigned int First,[In] unsigned int Last)</unmanaged>	
        /// <unmanaged-short>ID3DX10Font::PreloadGlyphs</unmanaged-short>	
        public void PreloadGlyphs(int first, int last) {
            unsafe {
                SharpDX.Result __result__;
                __result__= 
				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, first, last,((void**)(*(void**)_nativePointer))[11]);		
                __result__.CheckError();
            }
        }
        
        /// <summary>	
        /// <p>Load formatted text into video memory to improve the efficiency of rendering to the device. This method supports ANSI and Unicode strings.</p>	
        /// </summary>	
        /// <param name="stringRef"><dd>  <p>Pointer to a string of characters to be loaded into video memory. If the compiler settings require Unicode, the data type LPCTSTR resolves to LPCWSTR; otherwise, the data type resolves to LPCSTR. See Remarks.</p> </dd></param>	
        /// <param name="count"><dd>  <p>Number of characters in the text string.</p> </dd></param>	
        /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA.</p></returns>	
        /// <remarks>	
        /// <p>The compiler setting also determines the function version. If Unicode is defined, the function call resolves to PreloadTextW. Otherwise, the function call resolves to PreloadTextA because ANSI strings are being used.</p><p>This method generates textures that contain glyphs that represent the input text. The glyphs are drawn as a series of triangles.</p><p>Text will not be rendered to the device; <see cref="SharpDX.Direct3D10.Font.DrawText"/> must still be called to render the text. However, by preloading text into video memory, <see cref="SharpDX.Direct3D10.Font.DrawText"/> will use substantially fewer CPU resources.</p><p>This method internally converts characters to glyphs using the GDI function GetCharacterPlacement.</p>	
        /// </remarks>	
        /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Font::PreloadTextW']/*"/>	
        /// <msdn-id>bb173896</msdn-id>	
        /// <unmanaged>HRESULT ID3DX10Font::PreloadTextW([In] const wchar_t* pString,[In] int Count)</unmanaged>	
        /// <unmanaged-short>ID3DX10Font::PreloadTextW</unmanaged-short>	
        internal void PreloadText(string stringRef, int count) {
            unsafe {
                SharpDX.Result __result__;
                fixed (char* stringRef_ = stringRef)
                    __result__= 
    				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)stringRef_, count,((void**)(*(void**)_nativePointer))[13]);		
                    __result__.CheckError();
                }
            }
            
            /// <summary>	
            /// <p>Draw formatted text. This method supports ANSI and Unicode strings.</p>	
            /// </summary>	
            /// <param name="spriteRef"><dd>  <p>Pointer to an <see cref="SharpDX.Direct3D10.Sprite"/> object that contains the string you wish to draw. Can be <strong><c>null</c></strong>, in which case Direct3D will render the string with its own sprite object. To improve efficiency, a sprite object should be specified if <see cref="SharpDX.Direct3D10.Font.DrawText"/> is to be called more than once in a row.</p> </dd></param>	
            /// <param name="stringRef"><dd>  <p>Pointer to a string to draw. If UNICODE is defined, this parameter type resolves to an LPCWSTR, otherwise, the type resolves to an LPCSTR. If the Count parameter is -1, the string must be <strong><c>null</c></strong> terminated.</p> </dd></param>	
            /// <param name="count"><dd>  <p>The number of characters in the string. If Count is -1, then the pString parameter is assumed to be a reference to a sprite containing a <c>null</c>-terminated string and <see cref="SharpDX.Direct3D10.Font.DrawText"/> computes the character count automatically.</p> </dd></param>	
            /// <param name="rectRef"><dd>  <p>Pointer to a <see cref="SharpDX.Mathematics.Interop.RawRectangle"/> structure that contains the rectangle, in logical coordinates, in which the text is to be formatted. As with any <see cref="SharpDX.Mathematics.Interop.RawRectangle"/> object, the coordinate value of the rectangle's right side must be greater than that of its left side. Likewise, the coordinate value of the bottom must be greater than that of the top.</p> </dd></param>	
            /// <param name="format"><dd>  <p>Specify the method of formatting the text. It can be any combination of the following values: </p> <p></p> <table> <tr><th>Item</th><th>Description</th></tr> <tr><td> <p>DT_BOTTOM</p> </td><td> <p>Justify the text to the bottom of the rectangle. This value must be combined with DT_SINGLELINE.</p> </td></tr> <tr><td> <p>DT_CALCRECT</p> </td><td> <p>Tell DrawText to automatically calculate the width and height of the rectangle based on the length of the string you tell it to draw. If there are multiple lines of text, <see cref="SharpDX.Direct3D10.Font.DrawText"/> uses the width of the rectangle pointed to by the pRect parameter and extends the base of the rectangle to bound the last line of text. If there is only one line of text, <see cref="SharpDX.Direct3D10.Font.DrawText"/> modifies the right side of the rectangle so that it bounds the last character in the line. In either case, <see cref="SharpDX.Direct3D10.Font.DrawText"/> returns the height of the formatted text but does not draw the text.</p> </td></tr> <tr><td> <p>DT_CENTER</p> </td><td> <p>Center text horizontally in the rectangle.</p> </td></tr> <tr><td> <p>DT_EXPANDTABS</p> </td><td> <p>Expand tab characters. The default number of characters per tab is eight.</p> </td></tr> <tr><td> <p>DT_LEFT</p> </td><td> <p>Align text to the left.</p> </td></tr> <tr><td> <p>DT_NOCLIP</p> </td><td> <p>Draw without clipping. <see cref="SharpDX.Direct3D10.Font.DrawText"/> is somewhat faster when DT_NOCLIP is used.</p> </td></tr> <tr><td> <p>DT_RIGHT</p> </td><td> <p>Align text to the right.</p> </td></tr> <tr><td> <p>DT_RTLREADING</p> </td><td> <p>Display text in right-to-left reading order for bidirectional text when a Hebrew or Arabic font is selected. The default reading order for all text is left-to-right.</p> </td></tr> <tr><td> <p>DT_SINGLELINE</p> </td><td> <p>Display text on a single line only. Carriage returns and line feeds do not break the line.</p> </td></tr> <tr><td> <p>DT_TOP</p> </td><td> <p>Top-justify text.</p> </td></tr> <tr><td> <p>DT_VCENTER</p> </td><td> <p>Center text vertically (single line only).</p> </td></tr> <tr><td> <p>DT_WORDBREAK</p> </td><td> <p>Break words. Lines are automatically broken between words if a word would extend past the edge of the rectangle specified by the pRect parameter. A carriage return/line feed sequence also breaks the line.</p> </td></tr> </table> <p>?</p> </dd></param>	
            /// <param name="color"><dd>  <p>Color of the text. See <strong><see cref="SharpDX.Mathematics.Interop.RawColor4"/></strong>.</p> </dd></param>	
            /// <returns><p>If the function succeeds, the return value is the height of the text in logical units. If DT_VCENTER or DT_BOTTOM is specified, the return value is the offset from pRect (top to the bottom) of the drawn text. If the function fails, the return value is zero.</p></returns>	
            /// <remarks>	
            /// <p>The parameters of this method are very similar to those of the GDI DrawText function.</p><p>This method supports both ANSI and Unicode strings.</p><p>Unless the DT_NOCLIP format is used, this method clips the text so that it does not appear outside the specified rectangle. All formatting is assumed to have multiple lines unless the DT_SINGLELINE format is specified.</p><p>If the selected font is too large for the rectangle, this method does not attempt to substitute a smaller font.</p><p>This method supports only fonts whose escapement and orientation are both zero.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Font::DrawTextW']/*"/>	
            /// <msdn-id>bb173887</msdn-id>	
            /// <unmanaged>int ID3DX10Font::DrawTextW([In] ID3DX10Sprite* pSprite,[In] const wchar_t* pString,[In] int Count,[In] void* pRect,[In] unsigned int Format,[In] D3DXCOLOR Color)</unmanaged>	
            /// <unmanaged-short>ID3DX10Font::DrawTextW</unmanaged-short>	
            internal int DrawText(SharpDX.Direct3D10.Sprite spriteRef, string stringRef, int count, System.IntPtr rectRef, int format, SharpDX.Mathematics.Interop.RawColor4 color) {
                unsafe {
                    int __result__;
                    fixed (char* stringRef_ = stringRef)
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint53(_nativePointer, (void*)((spriteRef == null)?IntPtr.Zero:spriteRef.NativePointer), (void*)stringRef_, count, (void*)rectRef, format, color,((void**)(*(void**)_nativePointer))[15]);		
                        return __result__;
                    }
                }
            }
            /// <summary>	
            /// <p>A geometry-shader interface manages an executable program (a geometry shader) that controls the geometry-shader stage.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>The geometry-shader interface has no methods; use HLSL to implement your shader functionality. All shaders in Direct3D 10 are implemented from a common set of features referred to as the common shader core.</p><p>To create a geometry shader interface, call either <strong><see cref="SharpDX.Direct3D10.Device.CreateGeometryShader"/></strong> or <strong><see cref="SharpDX.Direct3D10.Device.CreateGeometryShaderWithStreamOutput"/></strong>. Before using a geometry shader you must bind it to the device by calling <strong><see cref="SharpDX.Direct3D10.GeometryShaderStage.Set"/></strong>.</p><p>This interface is defined in D3D10.h.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10GeometryShader']/*"/>	
            /// <msdn-id>bb173774</msdn-id>	
            /// <unmanaged>ID3D10GeometryShader</unmanaged>	
            /// <unmanaged-short>ID3D10GeometryShader</unmanaged-short>	
            [Guid("6316BE88-54CD-4040-AB44-20461BC81F68")]
            public partial class GeometryShader : SharpDX.Direct3D10.DeviceChild {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.GeometryShader"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public GeometryShader(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.GeometryShader"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.GeometryShader(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.GeometryShader(nativePointer);
        		}
                
            }
            /// <summary>	
            /// <p>The device interface represents a virtual adapter for Direct3D 10.0; it is used to perform rendering and create Direct3D resources.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>A device is created using <strong><see cref="SharpDX.Direct3D10.D3D10.CreateDevice"/></strong>.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device']/*"/>	
            /// <msdn-id>bb173528</msdn-id>	
            /// <unmanaged>ID3D10Device</unmanaged>	
            /// <unmanaged-short>ID3D10Device</unmanaged-short>	
            [Guid("9B7E4C0F-342C-4106-A19F-4F2704F689F0")]
            public partial class GeometryShaderStage : CommonShaderStage<GeometryShader> {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.GeometryShaderStage"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public GeometryShaderStage(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.GeometryShaderStage"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.GeometryShaderStage(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.GeometryShaderStage(nativePointer);
        		}
                
                
                /// <summary>	
                /// <p>Set the constant buffers used by the geometry shader pipeline stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numBuffers">No documentation.</param>	
                /// <param name="constantBuffersOut">No documentation.</param>	
                /// <remarks>	
                /// <p>The method will not hold references to the interfaces passed in. For that reason, applications should be careful not to release interfaces currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::GSSetConstantBuffers']/*"/>	
                /// <msdn-id>bb173580</msdn-id>	
                /// <unmanaged>void ID3D10Device::GSSetConstantBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D10Buffer** ppConstantBuffers)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::GSSetConstantBuffers</unmanaged-short>	
                public override void SetConstantBuffers(int startSlot, int numBuffers, SharpDX.Direct3D10.Buffer[] constantBuffersOut) {
                    unsafe {
                        IntPtr* constantBuffersOut_ = (IntPtr*)0;
                        if ( constantBuffersOut != null ) {
                            IntPtr* constantBuffersOut__ = stackalloc IntPtr[constantBuffersOut.Length];
                            constantBuffersOut_ = constantBuffersOut__;
                            for (int i = 0; i < constantBuffersOut.Length; i++)                        
                                constantBuffersOut_[i] =  (constantBuffersOut[i] == null)? IntPtr.Zero : constantBuffersOut[i].NativePointer;
                        }
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numBuffers, constantBuffersOut_,((void**)(*(void**)_nativePointer))[16]);		
                    }
                }
                
                /// <summary>	
                /// <p>Set the constant buffers used by the geometry shader pipeline stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numBuffers">No documentation.</param>	
                /// <param name="constantBuffersOut">No documentation.</param>	
                /// <remarks>	
                /// <p>The method will not hold references to the interfaces passed in. For that reason, applications should be careful not to release interfaces currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::GSSetConstantBuffers']/*"/>	
                /// <msdn-id>bb173580</msdn-id>	
                /// <unmanaged>void ID3D10Device::GSSetConstantBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D10Buffer** ppConstantBuffers)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::GSSetConstantBuffers</unmanaged-short>	
                public override void SetConstantBuffers(int startSlot, int numBuffers, SharpDX.ComArray<SharpDX.Direct3D10.Buffer> constantBuffersOut) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numBuffers, (void*)((constantBuffersOut == null)?IntPtr.Zero:constantBuffersOut.NativePointer),((void**)(*(void**)_nativePointer))[16]);		
                    }
                }
                
                /// <summary>	
                /// <p>Set the constant buffers used by the geometry shader pipeline stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numBuffers">No documentation.</param>	
                /// <param name="constantBuffersOut">No documentation.</param>	
                /// <remarks>	
                /// <p>The method will not hold references to the interfaces passed in. For that reason, applications should be careful not to release interfaces currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::GSSetConstantBuffers']/*"/>	
                /// <msdn-id>bb173580</msdn-id>	
                /// <unmanaged>void ID3D10Device::GSSetConstantBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D10Buffer** ppConstantBuffers)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::GSSetConstantBuffers</unmanaged-short>	
                private void SetConstantBuffers(int startSlot, int numBuffers, System.IntPtr constantBuffersOut) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numBuffers, (void*)constantBuffersOut,((void**)(*(void**)_nativePointer))[16]);		
                    }
                }
                
                /// <summary>	
                /// <p>Set a geometry shader to the device.</p>	
                /// </summary>	
                /// <param name="shaderRef"><dd>  <p>Pointer to a geometry shader (see <strong><see cref="SharpDX.Direct3D10.GeometryShader"/></strong>). Passing in <strong><c>null</c></strong> disables the shader for this pipeline stage.</p> </dd></param>	
                /// <remarks>	
                /// <p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::GSSetShader']/*"/>	
                /// <msdn-id>bb173582</msdn-id>	
                /// <unmanaged>void ID3D10Device::GSSetShader([In, Optional] ID3D10GeometryShader* pShader)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::GSSetShader</unmanaged-short>	
                public void Set(SharpDX.Direct3D10.GeometryShader shaderRef) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, (void*)((shaderRef == null)?IntPtr.Zero:shaderRef.NativePointer),((void**)(*(void**)_nativePointer))[17]);		
                    }
                }
                
                /// <summary>	
                /// <p>Bind an array of shader resources to the geometry shader stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numViews">No documentation.</param>	
                /// <param name="shaderResourceViewsOut">No documentation.</param>	
                /// <remarks>	
                /// <p>If you bind a subresource as an input and an output, this API will fill the destination shader resource slot with <strong><c>null</c></strong>. The debug layer (when active) will alert you if this is true.</p><p>For information about creating shader-resource views, see <strong><see cref="SharpDX.Direct3D10.Device.CreateShaderResourceView"/></strong>.</p><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::GSSetShaderResources']/*"/>	
                /// <msdn-id>bb173583</msdn-id>	
                /// <unmanaged>void ID3D10Device::GSSetShaderResources([In] unsigned int StartSlot,[In] unsigned int NumViews,[In, Buffer, Optional] const ID3D10ShaderResourceView** ppShaderResourceViews)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::GSSetShaderResources</unmanaged-short>	
                public override void SetShaderResources(int startSlot, int numViews, SharpDX.Direct3D10.ShaderResourceView[] shaderResourceViewsOut) {
                    unsafe {
                        IntPtr* shaderResourceViewsOut_ = (IntPtr*)0;
                        if ( shaderResourceViewsOut != null ) {
                            IntPtr* shaderResourceViewsOut__ = stackalloc IntPtr[shaderResourceViewsOut.Length];
                            shaderResourceViewsOut_ = shaderResourceViewsOut__;
                            for (int i = 0; i < shaderResourceViewsOut.Length; i++)                        
                                shaderResourceViewsOut_[i] =  (shaderResourceViewsOut[i] == null)? IntPtr.Zero : shaderResourceViewsOut[i].NativePointer;
                        }
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numViews, shaderResourceViewsOut_,((void**)(*(void**)_nativePointer))[22]);		
                    }
                }
                
                /// <summary>	
                /// <p>Bind an array of shader resources to the geometry shader stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numViews">No documentation.</param>	
                /// <param name="shaderResourceViewsOut">No documentation.</param>	
                /// <remarks>	
                /// <p>If you bind a subresource as an input and an output, this API will fill the destination shader resource slot with <strong><c>null</c></strong>. The debug layer (when active) will alert you if this is true.</p><p>For information about creating shader-resource views, see <strong><see cref="SharpDX.Direct3D10.Device.CreateShaderResourceView"/></strong>.</p><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::GSSetShaderResources']/*"/>	
                /// <msdn-id>bb173583</msdn-id>	
                /// <unmanaged>void ID3D10Device::GSSetShaderResources([In] unsigned int StartSlot,[In] unsigned int NumViews,[In, Buffer, Optional] const ID3D10ShaderResourceView** ppShaderResourceViews)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::GSSetShaderResources</unmanaged-short>	
                public override void SetShaderResources(int startSlot, int numViews, SharpDX.ComArray<SharpDX.Direct3D10.ShaderResourceView> shaderResourceViewsOut) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numViews, (void*)((shaderResourceViewsOut == null)?IntPtr.Zero:shaderResourceViewsOut.NativePointer),((void**)(*(void**)_nativePointer))[22]);		
                    }
                }
                
                /// <summary>	
                /// <p>Bind an array of shader resources to the geometry shader stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numViews">No documentation.</param>	
                /// <param name="shaderResourceViewsOut">No documentation.</param>	
                /// <remarks>	
                /// <p>If you bind a subresource as an input and an output, this API will fill the destination shader resource slot with <strong><c>null</c></strong>. The debug layer (when active) will alert you if this is true.</p><p>For information about creating shader-resource views, see <strong><see cref="SharpDX.Direct3D10.Device.CreateShaderResourceView"/></strong>.</p><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::GSSetShaderResources']/*"/>	
                /// <msdn-id>bb173583</msdn-id>	
                /// <unmanaged>void ID3D10Device::GSSetShaderResources([In] unsigned int StartSlot,[In] unsigned int NumViews,[In, Buffer, Optional] const ID3D10ShaderResourceView** ppShaderResourceViews)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::GSSetShaderResources</unmanaged-short>	
                private void SetShaderResources(int startSlot, int numViews, System.IntPtr shaderResourceViewsOut) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numViews, (void*)shaderResourceViewsOut,((void**)(*(void**)_nativePointer))[22]);		
                    }
                }
                
                /// <summary>	
                /// <p>Set an array of sampler states to the geometry shader pipeline stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numSamplers">No documentation.</param>	
                /// <param name="samplersOut">No documentation.</param>	
                /// <remarks>	
                /// <p>Any sampler may be set to <strong><c>null</c></strong>; this invokes the default state, which is defined to be the following.</p><pre> //Default sampler state:	
                /// <see cref="SharpDX.Direct3D10.SamplerStateDescription"/> SamplerDesc;	
                /// SamplerDesc.Filter = <see cref="SharpDX.Direct3D10.Filter.MinMagMipLinear"/>;	
                /// SamplerDesc.AddressU = <see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/>;	
                /// SamplerDesc.AddressV = <see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/>;	
                /// SamplerDesc.AddressW = <see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/>;	
                /// SamplerDesc.MipLODBias = 0;	
                /// SamplerDesc.MaxAnisotropy = 1;	
                /// SamplerDesc.ComparisonFunc = <see cref="SharpDX.Direct3D10.Comparison.Never"/>;	
                /// SamplerDesc.BorderColor[0] = 1.0f;	
                /// SamplerDesc.BorderColor[1] = 1.0f;	
                /// SamplerDesc.BorderColor[2] = 1.0f;	
                /// SamplerDesc.BorderColor[3] = 1.0f;	
                /// SamplerDesc.MinLOD = -FLT_MAX;	
                /// SamplerDesc.MaxLOD = FLT_MAX; </pre><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::GSSetSamplers']/*"/>	
                /// <msdn-id>bb173581</msdn-id>	
                /// <unmanaged>void ID3D10Device::GSSetSamplers([In] unsigned int StartSlot,[In] unsigned int NumSamplers,[In, Buffer, Optional] const ID3D10SamplerState** ppSamplers)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::GSSetSamplers</unmanaged-short>	
                public override void SetSamplers(int startSlot, int numSamplers, SharpDX.Direct3D10.SamplerState[] samplersOut) {
                    unsafe {
                        IntPtr* samplersOut_ = (IntPtr*)0;
                        if ( samplersOut != null ) {
                            IntPtr* samplersOut__ = stackalloc IntPtr[samplersOut.Length];
                            samplersOut_ = samplersOut__;
                            for (int i = 0; i < samplersOut.Length; i++)                        
                                samplersOut_[i] =  (samplersOut[i] == null)? IntPtr.Zero : samplersOut[i].NativePointer;
                        }
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numSamplers, samplersOut_,((void**)(*(void**)_nativePointer))[23]);		
                    }
                }
                
                /// <summary>	
                /// <p>Set an array of sampler states to the geometry shader pipeline stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numSamplers">No documentation.</param>	
                /// <param name="samplersOut">No documentation.</param>	
                /// <remarks>	
                /// <p>Any sampler may be set to <strong><c>null</c></strong>; this invokes the default state, which is defined to be the following.</p><pre> //Default sampler state:	
                /// <see cref="SharpDX.Direct3D10.SamplerStateDescription"/> SamplerDesc;	
                /// SamplerDesc.Filter = <see cref="SharpDX.Direct3D10.Filter.MinMagMipLinear"/>;	
                /// SamplerDesc.AddressU = <see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/>;	
                /// SamplerDesc.AddressV = <see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/>;	
                /// SamplerDesc.AddressW = <see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/>;	
                /// SamplerDesc.MipLODBias = 0;	
                /// SamplerDesc.MaxAnisotropy = 1;	
                /// SamplerDesc.ComparisonFunc = <see cref="SharpDX.Direct3D10.Comparison.Never"/>;	
                /// SamplerDesc.BorderColor[0] = 1.0f;	
                /// SamplerDesc.BorderColor[1] = 1.0f;	
                /// SamplerDesc.BorderColor[2] = 1.0f;	
                /// SamplerDesc.BorderColor[3] = 1.0f;	
                /// SamplerDesc.MinLOD = -FLT_MAX;	
                /// SamplerDesc.MaxLOD = FLT_MAX; </pre><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::GSSetSamplers']/*"/>	
                /// <msdn-id>bb173581</msdn-id>	
                /// <unmanaged>void ID3D10Device::GSSetSamplers([In] unsigned int StartSlot,[In] unsigned int NumSamplers,[In, Buffer, Optional] const ID3D10SamplerState** ppSamplers)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::GSSetSamplers</unmanaged-short>	
                public override void SetSamplers(int startSlot, int numSamplers, SharpDX.ComArray<SharpDX.Direct3D10.SamplerState> samplersOut) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numSamplers, (void*)((samplersOut == null)?IntPtr.Zero:samplersOut.NativePointer),((void**)(*(void**)_nativePointer))[23]);		
                    }
                }
                
                /// <summary>	
                /// <p>Set an array of sampler states to the geometry shader pipeline stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numSamplers">No documentation.</param>	
                /// <param name="samplersOut">No documentation.</param>	
                /// <remarks>	
                /// <p>Any sampler may be set to <strong><c>null</c></strong>; this invokes the default state, which is defined to be the following.</p><pre> //Default sampler state:	
                /// <see cref="SharpDX.Direct3D10.SamplerStateDescription"/> SamplerDesc;	
                /// SamplerDesc.Filter = <see cref="SharpDX.Direct3D10.Filter.MinMagMipLinear"/>;	
                /// SamplerDesc.AddressU = <see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/>;	
                /// SamplerDesc.AddressV = <see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/>;	
                /// SamplerDesc.AddressW = <see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/>;	
                /// SamplerDesc.MipLODBias = 0;	
                /// SamplerDesc.MaxAnisotropy = 1;	
                /// SamplerDesc.ComparisonFunc = <see cref="SharpDX.Direct3D10.Comparison.Never"/>;	
                /// SamplerDesc.BorderColor[0] = 1.0f;	
                /// SamplerDesc.BorderColor[1] = 1.0f;	
                /// SamplerDesc.BorderColor[2] = 1.0f;	
                /// SamplerDesc.BorderColor[3] = 1.0f;	
                /// SamplerDesc.MinLOD = -FLT_MAX;	
                /// SamplerDesc.MaxLOD = FLT_MAX; </pre><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::GSSetSamplers']/*"/>	
                /// <msdn-id>bb173581</msdn-id>	
                /// <unmanaged>void ID3D10Device::GSSetSamplers([In] unsigned int StartSlot,[In] unsigned int NumSamplers,[In, Buffer, Optional] const ID3D10SamplerState** ppSamplers)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::GSSetSamplers</unmanaged-short>	
                private void SetSamplers(int startSlot, int numSamplers, System.IntPtr samplersOut) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numSamplers, (void*)samplersOut,((void**)(*(void**)_nativePointer))[23]);		
                    }
                }
                
                /// <summary>	
                /// <p>Get the constant buffers used by the geometry shader pipeline stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numBuffers">No documentation.</param>	
                /// <param name="constantBuffersOut">No documentation.</param>	
                /// <remarks>	
                /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::GSGetConstantBuffers']/*"/>	
                /// <msdn-id>bb173576</msdn-id>	
                /// <unmanaged>void ID3D10Device::GSGetConstantBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[Out, Buffer, Optional] ID3D10Buffer** ppConstantBuffers)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::GSGetConstantBuffers</unmanaged-short>	
                internal override void GetConstantBuffers(int startSlot, int numBuffers, SharpDX.Direct3D10.Buffer[] constantBuffersOut) {
                    unsafe {
                        IntPtr* constantBuffersOut_ = stackalloc IntPtr[constantBuffersOut == null ? 0 : constantBuffersOut.Length];
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numBuffers, constantBuffersOut==null?(void*)0:constantBuffersOut_,((void**)(*(void**)_nativePointer))[48]);		
                        if (constantBuffersOut != null)
                        for (int i = 0; i < constantBuffersOut.Length; i++)
                            constantBuffersOut[i] = (constantBuffersOut_[i] == IntPtr.Zero)?null:new SharpDX.Direct3D10.Buffer(constantBuffersOut_[i]);	
                    }
                }
                
                /// <summary>	
                /// <p>Get the geometry shader currently set on the device.</p>	
                /// </summary>	
                /// <param name="geometryShaderOut"><dd>  <p>Address of a reference to a geometry shader (see <strong><see cref="SharpDX.Direct3D10.GeometryShader"/></strong>) to be returned by the method.</p> </dd></param>	
                /// <remarks>	
                /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::GSGetShader']/*"/>	
                /// <msdn-id>bb173578</msdn-id>	
                /// <unmanaged>void ID3D10Device::GSGetShader([Out] ID3D10GeometryShader** ppGeometryShader)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::GSGetShader</unmanaged-short>	
                public void Get(out SharpDX.Direct3D10.GeometryShader geometryShaderOut) {
                    unsafe {
                        IntPtr geometryShaderOut_ = IntPtr.Zero;
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, &geometryShaderOut_,((void**)(*(void**)_nativePointer))[49]);		
                        geometryShaderOut= (geometryShaderOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.GeometryShader(geometryShaderOut_);	
                    }
                }
                
                /// <summary>	
                /// <p>Get the geometry shader resources.</p>	
                /// </summary>	
                /// <param name="startSlot"><dd>  <p>Index into the device's zero-based array to begin getting shader resources from.</p> </dd></param>	
                /// <param name="numViews"><dd>  <p>The number of resources to get from the device. Up to a maximum of 128 slots are available for shader resources.</p> </dd></param>	
                /// <param name="shaderResourceViewsOut"><dd>  <p>Array of <strong>shader resource view</strong> interfaces to be returned by the device.</p> </dd></param>	
                /// <remarks>	
                /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::GSGetShaderResources']/*"/>	
                /// <msdn-id>bb173579</msdn-id>	
                /// <unmanaged>void ID3D10Device::GSGetShaderResources([In] unsigned int StartSlot,[In] unsigned int NumViews,[Out, Buffer, Optional] ID3D10ShaderResourceView** ppShaderResourceViews)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::GSGetShaderResources</unmanaged-short>	
                internal override void GetShaderResources(int startSlot, int numViews, SharpDX.Direct3D10.ShaderResourceView[] shaderResourceViewsOut) {
                    unsafe {
                        IntPtr* shaderResourceViewsOut_ = stackalloc IntPtr[shaderResourceViewsOut == null ? 0 : shaderResourceViewsOut.Length];
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numViews, shaderResourceViewsOut==null?(void*)0:shaderResourceViewsOut_,((void**)(*(void**)_nativePointer))[54]);		
                        if (shaderResourceViewsOut != null)
                        for (int i = 0; i < shaderResourceViewsOut.Length; i++)
                            shaderResourceViewsOut[i] = (shaderResourceViewsOut_[i] == IntPtr.Zero)?null:new SharpDX.Direct3D10.ShaderResourceView(shaderResourceViewsOut_[i]);	
                    }
                }
                
                /// <summary>	
                /// <p>Get an array of sampler states from the geometry shader pipeline stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numSamplers">No documentation.</param>	
                /// <param name="samplersOut">No documentation.</param>	
                /// <remarks>	
                /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::GSGetSamplers']/*"/>	
                /// <msdn-id>bb173577</msdn-id>	
                /// <unmanaged>void ID3D10Device::GSGetSamplers([In] unsigned int StartSlot,[In] unsigned int NumSamplers,[Out, Buffer, Optional] ID3D10SamplerState** ppSamplers)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::GSGetSamplers</unmanaged-short>	
                internal override void GetSamplers(int startSlot, int numSamplers, SharpDX.Direct3D10.SamplerState[] samplersOut) {
                    unsafe {
                        IntPtr* samplersOut_ = stackalloc IntPtr[samplersOut == null ? 0 : samplersOut.Length];
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numSamplers, samplersOut==null?(void*)0:samplersOut_,((void**)(*(void**)_nativePointer))[55]);		
                        if (samplersOut != null)
                        for (int i = 0; i < samplersOut.Length; i++)
                            samplersOut[i] = (samplersOut_[i] == IntPtr.Zero)?null:new SharpDX.Direct3D10.SamplerState(samplersOut_[i]);	
                    }
                }
            }
            /// <summary>	
            /// <p>An information-queue interface stores, retrieves, and filters debug messages. The queue consists of a message queue, an optional storage filter stack, and a optional retrieval filter stack.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>This interface is obtained by turning on the debug layer and querying it from the <strong><see cref="SharpDX.Direct3D10.Device"/> Interface</strong> using IUnknown::QueryInterface.</p><pre>hr = <see cref="SharpDX.Direct3D10.D3D10.CreateDeviceAndSwapChain"/>( <c>null</c>, g_driverType, <c>null</c>, <see cref="SharpDX.Direct3D10.DeviceCreationFlags.Debug"/>, <see cref="SharpDX.Direct3D10.D3D10.SdkVersion"/>, &amp;sd, &amp;g_pSwapChain, &amp;g_pd3dDevice );	
            /// ...	
            /// <see cref="SharpDX.Direct3D10.InfoQueue"/> * infoQueue;	
            /// g_pd3dDevice-&gt;QueryInterface(__uuidof(<see cref="SharpDX.Direct3D10.InfoQueue"/>),  (void **)&amp;infoQueue); 	
            /// </pre>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue']/*"/>	
            /// <msdn-id>bb173779</msdn-id>	
            /// <unmanaged>ID3D10InfoQueue</unmanaged>	
            /// <unmanaged-short>ID3D10InfoQueue</unmanaged-short>	
            [Guid("1b940b17-2642-4d1f-ab1f-b99bad0c395f")]
            public partial class InfoQueue : SharpDX.ComObject {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.InfoQueue"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public InfoQueue(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.InfoQueue"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.InfoQueue(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.InfoQueue(nativePointer);
        		}
                
                
                /// <summary>	
                /// <p>Get or sets the maximum number of messages that can be added to the message queue.</p>	
                /// </summary>	
                /// <remarks>	
                /// <p>When the number of messages in the message queue has reached the maximum limit, new messages coming in will push old messages out.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::GetMessageCountLimit']/*"/>	
                /// <msdn-id>bb173791</msdn-id>	
                /// <unmanaged>GetMessageCountLimit / SetMessageCountLimit</unmanaged>	
                /// <unmanaged-short>GetMessageCountLimit</unmanaged-short>	
                /// <unmanaged>unsigned longlong ID3D10InfoQueue::GetMessageCountLimit()</unmanaged>
                public long MessageCountLimit {
                        get { return GetMessageCountLimit(); }
                        set { SetMessageCountLimit(value); }
                }
                
                /// <summary>	
                /// <p>Get the number of messages that were allowed to pass through a storage filter.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::GetNumMessagesAllowedByStorageFilter']/*"/>	
                /// <msdn-id>bb173793</msdn-id>	
                /// <unmanaged>GetNumMessagesAllowedByStorageFilter</unmanaged>	
                /// <unmanaged-short>GetNumMessagesAllowedByStorageFilter</unmanaged-short>	
                /// <unmanaged>unsigned longlong ID3D10InfoQueue::GetNumMessagesAllowedByStorageFilter()</unmanaged>
                public long NumMessagesAllowedByStorageFilter {
                        get { return GetNumMessagesAllowedByStorageFilter(); }
                }
                
                /// <summary>	
                /// <p>Get the number of messages that were denied passage through a storage filter.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::GetNumMessagesDeniedByStorageFilter']/*"/>	
                /// <msdn-id>bb173794</msdn-id>	
                /// <unmanaged>GetNumMessagesDeniedByStorageFilter</unmanaged>	
                /// <unmanaged-short>GetNumMessagesDeniedByStorageFilter</unmanaged-short>	
                /// <unmanaged>unsigned longlong ID3D10InfoQueue::GetNumMessagesDeniedByStorageFilter()</unmanaged>
                public long NumMessagesDeniedByStorageFilter {
                        get { return GetNumMessagesDeniedByStorageFilter(); }
                }
                
                /// <summary>	
                /// <p>Get the number of messages currently stored in the message queue.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::GetNumStoredMessages']/*"/>	
                /// <msdn-id>bb173796</msdn-id>	
                /// <unmanaged>GetNumStoredMessages</unmanaged>	
                /// <unmanaged-short>GetNumStoredMessages</unmanaged-short>	
                /// <unmanaged>unsigned longlong ID3D10InfoQueue::GetNumStoredMessages()</unmanaged>
                public long NumStoredMessages {
                        get { return GetNumStoredMessages(); }
                }
                
                /// <summary>	
                /// <p>Get the number of messages that are able to pass through a retrieval filter.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::GetNumStoredMessagesAllowedByRetrievalFilter']/*"/>	
                /// <msdn-id>bb173797</msdn-id>	
                /// <unmanaged>GetNumStoredMessagesAllowedByRetrievalFilter</unmanaged>	
                /// <unmanaged-short>GetNumStoredMessagesAllowedByRetrievalFilter</unmanaged-short>	
                /// <unmanaged>unsigned longlong ID3D10InfoQueue::GetNumStoredMessagesAllowedByRetrievalFilter()</unmanaged>
                public long NumStoredMessagesAllowedByRetrievalFilter {
                        get { return GetNumStoredMessagesAllowedByRetrievalFilter(); }
                }
                
                /// <summary>	
                /// <p>Get the number of messages that were discarded due to the message count limit.</p>	
                /// </summary>	
                /// <remarks>	
                /// <p>Get and set the message count limit with <strong><see cref="SharpDX.Direct3D10.InfoQueue.GetMessageCountLimit"/></strong> and <strong><see cref="SharpDX.Direct3D10.InfoQueue.SetMessageCountLimit"/></strong>, respectively.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::GetNumMessagesDiscardedByMessageCountLimit']/*"/>	
                /// <msdn-id>bb173795</msdn-id>	
                /// <unmanaged>GetNumMessagesDiscardedByMessageCountLimit</unmanaged>	
                /// <unmanaged-short>GetNumMessagesDiscardedByMessageCountLimit</unmanaged-short>	
                /// <unmanaged>unsigned longlong ID3D10InfoQueue::GetNumMessagesDiscardedByMessageCountLimit()</unmanaged>
                public long NumMessagesDiscardedByMessageCountLimit {
                        get { return GetNumMessagesDiscardedByMessageCountLimit(); }
                }
                
                /// <summary>	
                /// <p>Get the size of the storage-filter stack in bytes.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::GetStorageFilterStackSize']/*"/>	
                /// <msdn-id>bb173801</msdn-id>	
                /// <unmanaged>GetStorageFilterStackSize</unmanaged>	
                /// <unmanaged-short>GetStorageFilterStackSize</unmanaged-short>	
                /// <unmanaged>unsigned int ID3D10InfoQueue::GetStorageFilterStackSize()</unmanaged>
                public int StorageFilterStackSize {
                        get { return GetStorageFilterStackSize(); }
                }
                
                /// <summary>	
                /// <p>Get the size of the retrieval-filter stack in bytes.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::GetRetrievalFilterStackSize']/*"/>	
                /// <msdn-id>bb173799</msdn-id>	
                /// <unmanaged>GetRetrievalFilterStackSize</unmanaged>	
                /// <unmanaged-short>GetRetrievalFilterStackSize</unmanaged-short>	
                /// <unmanaged>unsigned int ID3D10InfoQueue::GetRetrievalFilterStackSize()</unmanaged>
                public int RetrievalFilterStackSize {
                        get { return GetRetrievalFilterStackSize(); }
                }
                
                /// <summary>	
                /// <p>Get or sets a boolean that turns the debug output on or off.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::GetMuteDebugOutput']/*"/>	
                /// <msdn-id>bb173792</msdn-id>	
                /// <unmanaged>GetMuteDebugOutput / SetMuteDebugOutput</unmanaged>	
                /// <unmanaged-short>GetMuteDebugOutput</unmanaged-short>	
                /// <unmanaged>BOOL ID3D10InfoQueue::GetMuteDebugOutput()</unmanaged>
                public SharpDX.Mathematics.Interop.RawBool MuteDebugOutput {
                        get { return GetMuteDebugOutput(); }
                        set { SetMuteDebugOutput(value); }
                }
                
                /// <summary>	
                /// <p>Set the maximum number of messages that can be added to the message queue.</p>	
                /// </summary>	
                /// <param name="messageCountLimit"><dd>  <p>Maximum number of messages that can be added to the message queue. -1 means no limit.</p> </dd></param>	
                /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
                /// <remarks>	
                /// <p>When the number of messages in the message queue has reached the maximum limit, new messages coming in will push old messages out.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::SetMessageCountLimit']/*"/>	
                /// <msdn-id>bb173813</msdn-id>	
                /// <unmanaged>HRESULT ID3D10InfoQueue::SetMessageCountLimit([In] unsigned longlong MessageCountLimit)</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::SetMessageCountLimit</unmanaged-short>	
                internal void SetMessageCountLimit(long messageCountLimit) {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, messageCountLimit,((void**)(*(void**)_nativePointer))[3]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Clear all messages from the message queue.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::ClearStoredMessages']/*"/>	
                /// <msdn-id>bb173786</msdn-id>	
                /// <unmanaged>void ID3D10InfoQueue::ClearStoredMessages()</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::ClearStoredMessages</unmanaged-short>	
                public void ClearStoredMessages() {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                    }
                }
                
                /// <summary>	
                /// <p>Get a message from the message queue.</p>	
                /// </summary>	
                /// <param name="messageIndex"><dd>  <p>Index into message queue after an optional retrieval filter has been applied. This can be between 0 and the number of messages in the message queue that pass through the retrieval filter (which can be obtained with <strong><see cref="SharpDX.Direct3D10.InfoQueue.GetNumStoredMessagesAllowedByRetrievalFilter"/></strong>). 0 is the message at the front of the message queue.</p> </dd></param>	
                /// <param name="messageRef"><dd>  <p>Returned message (see <strong><see cref="SharpDX.Direct3D10.Message"/></strong>).</p> </dd></param>	
                /// <param name="messageByteLengthRef"><dd>  <p>Size of pMessage in bytes, including the size of the message string that the pMessage points to.</p> </dd></param>	
                /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
                /// <remarks>	
                /// <p>This method does not remove any messages from the message queue.</p><p>This method gets messages from the message queue after an optional retrieval filter has been applied.</p><p>Applications should call this method twice to retrieve a message - first to obtain the size of the message and second to get the message. Here is a typical example:</p><pre> // Get the size of the message	
                /// <see cref="SharpDX.PointerSize"/> messageLength = 0;	
                /// <see cref="SharpDX.Result"/> hr = pInfoQueue-&gt;GetMessage(0, <c>null</c>, &amp;messageLength); // Allocate space and get the message	
                /// <see cref="SharpDX.Direct3D10.Message"/> * pMessage = (<see cref="SharpDX.Direct3D10.Message"/>*)malloc(messageLength);	
                /// hr = pInfoQueue-&gt;GetMessage(0, pMessage, &amp;messageLength);	
                /// </pre><p>For an overview see <strong>Information Queue Overview</strong>.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::GetMessage']/*"/>	
                /// <msdn-id>bb173790</msdn-id>	
                /// <unmanaged>HRESULT ID3D10InfoQueue::GetMessage([In] unsigned longlong MessageIndex,[In] void* pMessage,[InOut] SIZE_T* pMessageByteLength)</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::GetMessage</unmanaged-short>	
                internal void GetMessage(long messageIndex, System.IntPtr messageRef, ref SharpDX.PointerSize messageByteLengthRef) {
                    unsafe {
                        SharpDX.Result __result__;
                        fixed (void* messageByteLengthRef_ = &messageByteLengthRef)
                            __result__= 
            				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, messageIndex, (void*)messageRef, messageByteLengthRef_,((void**)(*(void**)_nativePointer))[5]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Get the number of messages that were allowed to pass through a storage filter.</p>	
                /// </summary>	
                /// <returns><p>Number of messages allowed by a storage filter.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::GetNumMessagesAllowedByStorageFilter']/*"/>	
                /// <msdn-id>bb173793</msdn-id>	
                /// <unmanaged>unsigned longlong ID3D10InfoQueue::GetNumMessagesAllowedByStorageFilter()</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::GetNumMessagesAllowedByStorageFilter</unmanaged-short>	
                internal long GetNumMessagesAllowedByStorageFilter() {
                    unsafe {
                        long __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Callilong(_nativePointer,((void**)(*(void**)_nativePointer))[6]);		
                        return __result__;
                    }
                }
                
                /// <summary>	
                /// <p>Get the number of messages that were denied passage through a storage filter.</p>	
                /// </summary>	
                /// <returns><p>Number of messages denied by a storage filter.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::GetNumMessagesDeniedByStorageFilter']/*"/>	
                /// <msdn-id>bb173794</msdn-id>	
                /// <unmanaged>unsigned longlong ID3D10InfoQueue::GetNumMessagesDeniedByStorageFilter()</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::GetNumMessagesDeniedByStorageFilter</unmanaged-short>	
                internal long GetNumMessagesDeniedByStorageFilter() {
                    unsafe {
                        long __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Callilong(_nativePointer,((void**)(*(void**)_nativePointer))[7]);		
                        return __result__;
                    }
                }
                
                /// <summary>	
                /// <p>Get the number of messages currently stored in the message queue.</p>	
                /// </summary>	
                /// <returns><p>Number of messages currently stored in the message queue.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::GetNumStoredMessages']/*"/>	
                /// <msdn-id>bb173796</msdn-id>	
                /// <unmanaged>unsigned longlong ID3D10InfoQueue::GetNumStoredMessages()</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::GetNumStoredMessages</unmanaged-short>	
                internal long GetNumStoredMessages() {
                    unsafe {
                        long __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Callilong(_nativePointer,((void**)(*(void**)_nativePointer))[8]);		
                        return __result__;
                    }
                }
                
                /// <summary>	
                /// <p>Get the number of messages that are able to pass through a retrieval filter.</p>	
                /// </summary>	
                /// <returns><p>Number of messages allowed by a retrieval filter.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::GetNumStoredMessagesAllowedByRetrievalFilter']/*"/>	
                /// <msdn-id>bb173797</msdn-id>	
                /// <unmanaged>unsigned longlong ID3D10InfoQueue::GetNumStoredMessagesAllowedByRetrievalFilter()</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::GetNumStoredMessagesAllowedByRetrievalFilter</unmanaged-short>	
                internal long GetNumStoredMessagesAllowedByRetrievalFilter() {
                    unsafe {
                        long __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Callilong(_nativePointer,((void**)(*(void**)_nativePointer))[9]);		
                        return __result__;
                    }
                }
                
                /// <summary>	
                /// <p>Get the number of messages that were discarded due to the message count limit.</p>	
                /// </summary>	
                /// <returns><p>Number of messages discarded.</p></returns>	
                /// <remarks>	
                /// <p>Get and set the message count limit with <strong><see cref="SharpDX.Direct3D10.InfoQueue.GetMessageCountLimit"/></strong> and <strong><see cref="SharpDX.Direct3D10.InfoQueue.SetMessageCountLimit"/></strong>, respectively.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::GetNumMessagesDiscardedByMessageCountLimit']/*"/>	
                /// <msdn-id>bb173795</msdn-id>	
                /// <unmanaged>unsigned longlong ID3D10InfoQueue::GetNumMessagesDiscardedByMessageCountLimit()</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::GetNumMessagesDiscardedByMessageCountLimit</unmanaged-short>	
                internal long GetNumMessagesDiscardedByMessageCountLimit() {
                    unsafe {
                        long __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Callilong(_nativePointer,((void**)(*(void**)_nativePointer))[10]);		
                        return __result__;
                    }
                }
                
                /// <summary>	
                /// <p>Get the maximum number of messages that can be added to the message queue.</p>	
                /// </summary>	
                /// <returns><p>Maximum number of messages that can be added to the queue. -1 means no limit.</p></returns>	
                /// <remarks>	
                /// <p>When the number of messages in the message queue has reached the maximum limit, new messages coming in will push old messages out.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::GetMessageCountLimit']/*"/>	
                /// <msdn-id>bb173791</msdn-id>	
                /// <unmanaged>unsigned longlong ID3D10InfoQueue::GetMessageCountLimit()</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::GetMessageCountLimit</unmanaged-short>	
                internal long GetMessageCountLimit() {
                    unsafe {
                        long __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Callilong(_nativePointer,((void**)(*(void**)_nativePointer))[11]);		
                        return __result__;
                    }
                }
                
                /// <summary>	
                /// <p>Add storage filters to the top of the storage-filter stack.</p>	
                /// </summary>	
                /// <param name="filterRef"><dd>  <p>Array of storage filters (see <strong><see cref="SharpDX.Direct3D10.InfoQueueFilter"/></strong>).</p> </dd></param>	
                /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
                /// <remarks>	
                /// <p>A storage filter defines a grouping of debug messages that should be allowed into the info queue.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::AddStorageFilterEntries']/*"/>	
                /// <msdn-id>bb173783</msdn-id>	
                /// <unmanaged>HRESULT ID3D10InfoQueue::AddStorageFilterEntries([In] D3D10_INFO_QUEUE_FILTER* pFilter)</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::AddStorageFilterEntries</unmanaged-short>	
                public void AddStorageFilterEntries(SharpDX.Direct3D10.InfoQueueFilter filterRef) {
                    unsafe {
                        var filterRef_ = new SharpDX.Direct3D10.InfoQueueFilter.__Native();
                        filterRef.__MarshalTo(ref filterRef_);
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &filterRef_,((void**)(*(void**)_nativePointer))[12]);		
                        filterRef.__MarshalFree(ref filterRef_);
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Get the storage filter at the top of the storage-filter stack.</p>	
                /// </summary>	
                /// <param name="filterRef"><dd>  <p>Storage filter at the top of the storage-filter stack.</p> </dd></param>	
                /// <param name="filterByteLengthRef"><dd>  <p>Size of the storage filter in bytes. If pFilter is <strong><c>null</c></strong>, the size of the storage filter will be output to this parameter.</p> </dd></param>	
                /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::GetStorageFilter']/*"/>	
                /// <msdn-id>bb173800</msdn-id>	
                /// <unmanaged>HRESULT ID3D10InfoQueue::GetStorageFilter([In] void* pFilter,[InOut] SIZE_T* pFilterByteLength)</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::GetStorageFilter</unmanaged-short>	
                internal void GetStorageFilter(System.IntPtr filterRef, ref SharpDX.PointerSize filterByteLengthRef) {
                    unsafe {
                        SharpDX.Result __result__;
                        fixed (void* filterByteLengthRef_ = &filterByteLengthRef)
                            __result__= 
            				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)filterRef, filterByteLengthRef_,((void**)(*(void**)_nativePointer))[13]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Remove a storage filter from the top of the storage-filter stack.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::ClearStorageFilter']/*"/>	
                /// <msdn-id>bb173785</msdn-id>	
                /// <unmanaged>void ID3D10InfoQueue::ClearStorageFilter()</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::ClearStorageFilter</unmanaged-short>	
                public void ClearStorageFilter() {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer,((void**)(*(void**)_nativePointer))[14]);		
                    }
                }
                
                /// <summary>	
                /// <p>Push an empty storage filter onto the storage-filter stack.</p>	
                /// </summary>	
                /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
                /// <remarks>	
                /// <p>An empty storage filter allows all messages to pass through.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::PushEmptyStorageFilter']/*"/>	
                /// <msdn-id>bb173807</msdn-id>	
                /// <unmanaged>HRESULT ID3D10InfoQueue::PushEmptyStorageFilter()</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::PushEmptyStorageFilter</unmanaged-short>	
                public void PushEmptyStorageFilter() {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[15]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Push a copy of storage filter currently on the top of the storage-filter stack onto the storage-filter stack.</p>	
                /// </summary>	
                /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::PushCopyOfStorageFilter']/*"/>	
                /// <msdn-id>bb173805</msdn-id>	
                /// <unmanaged>HRESULT ID3D10InfoQueue::PushCopyOfStorageFilter()</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::PushCopyOfStorageFilter</unmanaged-short>	
                public void PushCopyOfStorageFilter() {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[16]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Push a storage filter onto the storage-filter stack.</p>	
                /// </summary>	
                /// <param name="filterRef"><dd>  <p>Pointer to a storage filter (see <strong><see cref="SharpDX.Direct3D10.InfoQueueFilter"/></strong>).</p> </dd></param>	
                /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::PushStorageFilter']/*"/>	
                /// <msdn-id>bb173809</msdn-id>	
                /// <unmanaged>HRESULT ID3D10InfoQueue::PushStorageFilter([In] D3D10_INFO_QUEUE_FILTER* pFilter)</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::PushStorageFilter</unmanaged-short>	
                public void PushStorageFilter(SharpDX.Direct3D10.InfoQueueFilter filterRef) {
                    unsafe {
                        var filterRef_ = new SharpDX.Direct3D10.InfoQueueFilter.__Native();
                        filterRef.__MarshalTo(ref filterRef_);
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &filterRef_,((void**)(*(void**)_nativePointer))[17]);		
                        filterRef.__MarshalFree(ref filterRef_);
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Pop a storage filter from the top of the storage-filter stack.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::PopStorageFilter']/*"/>	
                /// <msdn-id>bb173803</msdn-id>	
                /// <unmanaged>void ID3D10InfoQueue::PopStorageFilter()</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::PopStorageFilter</unmanaged-short>	
                public void PopStorageFilter() {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer,((void**)(*(void**)_nativePointer))[18]);		
                    }
                }
                
                /// <summary>	
                /// <p>Get the size of the storage-filter stack in bytes.</p>	
                /// </summary>	
                /// <returns><p>Size of the storage-filter stack in bytes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::GetStorageFilterStackSize']/*"/>	
                /// <msdn-id>bb173801</msdn-id>	
                /// <unmanaged>unsigned int ID3D10InfoQueue::GetStorageFilterStackSize()</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::GetStorageFilterStackSize</unmanaged-short>	
                internal int GetStorageFilterStackSize() {
                    unsafe {
                        int __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[19]);		
                        return __result__;
                    }
                }
                
                /// <summary>	
                /// <p>Add storage filters to the top of the retrieval-filter stack.</p>	
                /// </summary>	
                /// <param name="filterRef"><dd>  <p>Array of retrieval filters (see <strong><see cref="SharpDX.Direct3D10.InfoQueueFilter"/></strong>).</p> </dd></param>	
                /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
                /// <remarks>	
                /// <p>A retrieval filter is used to define a subgroup of the messages that are already in the info queue.   Retrieval filters affect the messages that will be returned by <strong><see cref="SharpDX.Direct3D10.InfoQueue.GetMessage"/></strong>.</p><p>The number of messages already in the info queue that will be allowed through the retrieval filter can be determined  by calling <strong><see cref="SharpDX.Direct3D10.InfoQueue.GetNumStoredMessagesAllowedByRetrievalFilter"/></strong>.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::AddRetrievalFilterEntries']/*"/>	
                /// <msdn-id>bb173782</msdn-id>	
                /// <unmanaged>HRESULT ID3D10InfoQueue::AddRetrievalFilterEntries([In] D3D10_INFO_QUEUE_FILTER* pFilter)</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::AddRetrievalFilterEntries</unmanaged-short>	
                public void AddRetrievalFilterEntries(SharpDX.Direct3D10.InfoQueueFilter filterRef) {
                    unsafe {
                        var filterRef_ = new SharpDX.Direct3D10.InfoQueueFilter.__Native();
                        filterRef.__MarshalTo(ref filterRef_);
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &filterRef_,((void**)(*(void**)_nativePointer))[20]);		
                        filterRef.__MarshalFree(ref filterRef_);
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Get the retrieval filter at the top of the retrieval-filter stack.</p>	
                /// </summary>	
                /// <param name="filterRef"><dd>  <p>Retrieval filter at the top of the retrieval-filter stack.</p> </dd></param>	
                /// <param name="filterByteLengthRef"><dd>  <p>Size of the retrieval filter in bytes. If pFilter is <strong><c>null</c></strong>, the size of the retrieval filter will be output to this parameter.</p> </dd></param>	
                /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::GetRetrievalFilter']/*"/>	
                /// <msdn-id>bb173798</msdn-id>	
                /// <unmanaged>HRESULT ID3D10InfoQueue::GetRetrievalFilter([In] void* pFilter,[InOut] SIZE_T* pFilterByteLength)</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::GetRetrievalFilter</unmanaged-short>	
                internal void GetRetrievalFilter(System.IntPtr filterRef, ref SharpDX.PointerSize filterByteLengthRef) {
                    unsafe {
                        SharpDX.Result __result__;
                        fixed (void* filterByteLengthRef_ = &filterByteLengthRef)
                            __result__= 
            				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)filterRef, filterByteLengthRef_,((void**)(*(void**)_nativePointer))[21]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Remove a retrieval filter from the top of the retrieval-filter stack.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::ClearRetrievalFilter']/*"/>	
                /// <msdn-id>bb173784</msdn-id>	
                /// <unmanaged>void ID3D10InfoQueue::ClearRetrievalFilter()</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::ClearRetrievalFilter</unmanaged-short>	
                public void ClearRetrievalFilter() {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer,((void**)(*(void**)_nativePointer))[22]);		
                    }
                }
                
                /// <summary>	
                /// <p>Push an empty retrieval filter onto the retrieval-filter stack.</p>	
                /// </summary>	
                /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
                /// <remarks>	
                /// <p>An empty retrieval filter allows all messages to pass through.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::PushEmptyRetrievalFilter']/*"/>	
                /// <msdn-id>bb173806</msdn-id>	
                /// <unmanaged>HRESULT ID3D10InfoQueue::PushEmptyRetrievalFilter()</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::PushEmptyRetrievalFilter</unmanaged-short>	
                public void PushEmptyRetrievalFilter() {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[23]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Push a copy of retrieval filter currently on the top of the retrieval-filter stack onto the retrieval-filter stack.</p>	
                /// </summary>	
                /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::PushCopyOfRetrievalFilter']/*"/>	
                /// <msdn-id>bb173804</msdn-id>	
                /// <unmanaged>HRESULT ID3D10InfoQueue::PushCopyOfRetrievalFilter()</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::PushCopyOfRetrievalFilter</unmanaged-short>	
                public void PushCopyOfRetrievalFilter() {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[24]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Push a retrieval filter onto the retrieval-filter stack.</p>	
                /// </summary>	
                /// <param name="filterRef"><dd>  <p>Pointer to a retrieval filter (see <strong><see cref="SharpDX.Direct3D10.InfoQueueFilter"/></strong>).</p> </dd></param>	
                /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::PushRetrievalFilter']/*"/>	
                /// <msdn-id>bb173808</msdn-id>	
                /// <unmanaged>HRESULT ID3D10InfoQueue::PushRetrievalFilter([In] D3D10_INFO_QUEUE_FILTER* pFilter)</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::PushRetrievalFilter</unmanaged-short>	
                public void PushRetrievalFilter(SharpDX.Direct3D10.InfoQueueFilter filterRef) {
                    unsafe {
                        var filterRef_ = new SharpDX.Direct3D10.InfoQueueFilter.__Native();
                        filterRef.__MarshalTo(ref filterRef_);
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &filterRef_,((void**)(*(void**)_nativePointer))[25]);		
                        filterRef.__MarshalFree(ref filterRef_);
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Pop a retrieval filter from the top of the retrieval-filter stack.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::PopRetrievalFilter']/*"/>	
                /// <msdn-id>bb173802</msdn-id>	
                /// <unmanaged>void ID3D10InfoQueue::PopRetrievalFilter()</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::PopRetrievalFilter</unmanaged-short>	
                public void PopRetrievalFilter() {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer,((void**)(*(void**)_nativePointer))[26]);		
                    }
                }
                
                /// <summary>	
                /// <p>Get the size of the retrieval-filter stack in bytes.</p>	
                /// </summary>	
                /// <returns><p>Size of the retrieval-filter stack in bytes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::GetRetrievalFilterStackSize']/*"/>	
                /// <msdn-id>bb173799</msdn-id>	
                /// <unmanaged>unsigned int ID3D10InfoQueue::GetRetrievalFilterStackSize()</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::GetRetrievalFilterStackSize</unmanaged-short>	
                internal int GetRetrievalFilterStackSize() {
                    unsafe {
                        int __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[27]);		
                        return __result__;
                    }
                }
                
                /// <summary>	
                /// <p>Add a Direct3D 10 debug message to the message queue and send that message to debug output.</p>	
                /// </summary>	
                /// <param name="category"><dd>  <p>Category of a message (see <strong><see cref="SharpDX.Direct3D10.MessageCategory"/></strong>).</p> </dd></param>	
                /// <param name="severity"><dd>  <p>Severity of a message (see <strong><see cref="SharpDX.Direct3D10.MessageSeverity"/></strong>).</p> </dd></param>	
                /// <param name="id"><dd>  <p>Unique identifier of a message (see <strong><see cref="SharpDX.Direct3D10.MessageId"/></strong>).</p> </dd></param>	
                /// <param name="descriptionRef"><dd>  <p>User-defined message.</p> </dd></param>	
                /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
                /// <remarks>	
                /// <p>This method is used by the runtime's internal mechanisms to add Direct3D 10 debug messages to the message queue and send them to debug output. For applications to add their own custom messages to the message queue and send them to debug output, call <strong><see cref="SharpDX.Direct3D10.InfoQueue.AddApplicationMessage"/></strong>.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::AddMessage']/*"/>	
                /// <msdn-id>bb173781</msdn-id>	
                /// <unmanaged>HRESULT ID3D10InfoQueue::AddMessage([In] D3D10_MESSAGE_CATEGORY Category,[In] D3D10_MESSAGE_SEVERITY Severity,[In] D3D10_MESSAGE_ID ID,[In] const char* pDescription)</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::AddMessage</unmanaged-short>	
                public void AddMessage(SharpDX.Direct3D10.MessageCategory category, SharpDX.Direct3D10.MessageSeverity severity, SharpDX.Direct3D10.MessageId id, string descriptionRef) {
                    unsafe {
                        IntPtr descriptionRef_ = Utilities.StringToHGlobalAnsi(descriptionRef);
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, unchecked((int)category), unchecked((int)severity), unchecked((int)id), (void*)descriptionRef_,((void**)(*(void**)_nativePointer))[28]);		
                        Marshal.FreeHGlobal(descriptionRef_ );
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Add a user-defined message to the message queue and send that message to debug output.</p>	
                /// </summary>	
                /// <param name="severity"><dd>  <p>Severity of a message (see <strong><see cref="SharpDX.Direct3D10.MessageSeverity"/></strong>).</p> </dd></param>	
                /// <param name="descriptionRef"><dd>  <p>Message string.</p> </dd></param>	
                /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::AddApplicationMessage']/*"/>	
                /// <msdn-id>bb173780</msdn-id>	
                /// <unmanaged>HRESULT ID3D10InfoQueue::AddApplicationMessage([In] D3D10_MESSAGE_SEVERITY Severity,[In] const char* pDescription)</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::AddApplicationMessage</unmanaged-short>	
                public void AddApplicationMessage(SharpDX.Direct3D10.MessageSeverity severity, string descriptionRef) {
                    unsafe {
                        IntPtr descriptionRef_ = Utilities.StringToHGlobalAnsi(descriptionRef);
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, unchecked((int)severity), (void*)descriptionRef_,((void**)(*(void**)_nativePointer))[29]);		
                        Marshal.FreeHGlobal(descriptionRef_ );
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Set a message category to break on when a message with that category passes through the storage filter.</p>	
                /// </summary>	
                /// <param name="category"><dd>  <p>Message category to break on (see <strong><see cref="SharpDX.Direct3D10.MessageCategory"/></strong>).</p> </dd></param>	
                /// <param name="bEnable"><dd>  <p>Turns this breaking condition on or off (true for on, false for off).</p> </dd></param>	
                /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::SetBreakOnCategory']/*"/>	
                /// <msdn-id>bb173810</msdn-id>	
                /// <unmanaged>HRESULT ID3D10InfoQueue::SetBreakOnCategory([In] D3D10_MESSAGE_CATEGORY Category,[In] BOOL bEnable)</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::SetBreakOnCategory</unmanaged-short>	
                public void SetBreakOnCategory(SharpDX.Direct3D10.MessageCategory category, SharpDX.Mathematics.Interop.RawBool bEnable) {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint41(_nativePointer, unchecked((int)category), bEnable,((void**)(*(void**)_nativePointer))[30]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Set a message severity level to break on when a message with that severity level passes through the storage filter.</p>	
                /// </summary>	
                /// <param name="severity"><dd>  <p>Message severity level to break on (see <strong><see cref="SharpDX.Direct3D10.MessageSeverity"/></strong>).</p> </dd></param>	
                /// <param name="bEnable"><dd>  <p>Turns this breaking condition on or off (true for on, false for off).</p> </dd></param>	
                /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::SetBreakOnSeverity']/*"/>	
                /// <msdn-id>bb173812</msdn-id>	
                /// <unmanaged>HRESULT ID3D10InfoQueue::SetBreakOnSeverity([In] D3D10_MESSAGE_SEVERITY Severity,[In] BOOL bEnable)</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::SetBreakOnSeverity</unmanaged-short>	
                public void SetBreakOnSeverity(SharpDX.Direct3D10.MessageSeverity severity, SharpDX.Mathematics.Interop.RawBool bEnable) {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint41(_nativePointer, unchecked((int)severity), bEnable,((void**)(*(void**)_nativePointer))[31]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Set a message identifier to break on when a message with that identifier passes through the storage filter.</p>	
                /// </summary>	
                /// <param name="id"><dd>  <p>Message identifier to break on (see <strong><see cref="SharpDX.Direct3D10.MessageId"/></strong>).</p> </dd></param>	
                /// <param name="bEnable"><dd>  <p>Turns this breaking condition on or off (true for on, false for off).</p> </dd></param>	
                /// <returns><p>This method returns one of the following Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::SetBreakOnID']/*"/>	
                /// <msdn-id>bb173811</msdn-id>	
                /// <unmanaged>HRESULT ID3D10InfoQueue::SetBreakOnID([In] D3D10_MESSAGE_ID ID,[In] BOOL bEnable)</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::SetBreakOnID</unmanaged-short>	
                public void SetBreakOnID(SharpDX.Direct3D10.MessageId id, SharpDX.Mathematics.Interop.RawBool bEnable) {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint41(_nativePointer, unchecked((int)id), bEnable,((void**)(*(void**)_nativePointer))[32]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Get a message category to break on when a message with that category passes through the storage filter.</p>	
                /// </summary>	
                /// <param name="category"><dd>  <p>Message category to break on (see <strong><see cref="SharpDX.Direct3D10.MessageCategory"/></strong>).</p> </dd></param>	
                /// <returns><p>Whether this breaking condition is turned on or off (true for on, false for off).</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::GetBreakOnCategory']/*"/>	
                /// <msdn-id>bb173787</msdn-id>	
                /// <unmanaged>BOOL ID3D10InfoQueue::GetBreakOnCategory([In] D3D10_MESSAGE_CATEGORY Category)</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::GetBreakOnCategory</unmanaged-short>	
                public SharpDX.Mathematics.Interop.RawBool GetBreakOnCategory(SharpDX.Direct3D10.MessageCategory category) {
                    unsafe {
                        SharpDX.Mathematics.Interop.RawBool __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, unchecked((int)category),((void**)(*(void**)_nativePointer))[33]);		
                        return __result__;
                    }
                }
                
                /// <summary>	
                /// <p>Get a message severity level to break on when a message with that severity level passes through the storage filter.</p>	
                /// </summary>	
                /// <param name="severity"><dd>  <p>Message severity level to break on (see <strong><see cref="SharpDX.Direct3D10.MessageSeverity"/></strong>).</p> </dd></param>	
                /// <returns><p>Whether this breaking condition is turned on or off (true for on, false for off).</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::GetBreakOnSeverity']/*"/>	
                /// <msdn-id>bb173789</msdn-id>	
                /// <unmanaged>BOOL ID3D10InfoQueue::GetBreakOnSeverity([In] D3D10_MESSAGE_SEVERITY Severity)</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::GetBreakOnSeverity</unmanaged-short>	
                public SharpDX.Mathematics.Interop.RawBool GetBreakOnSeverity(SharpDX.Direct3D10.MessageSeverity severity) {
                    unsafe {
                        SharpDX.Mathematics.Interop.RawBool __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, unchecked((int)severity),((void**)(*(void**)_nativePointer))[34]);		
                        return __result__;
                    }
                }
                
                /// <summary>	
                /// <p>Get a message identifier to break on when a message with that identifier passes through the storage filter.</p>	
                /// </summary>	
                /// <param name="id"><dd>  <p>Message identifier to break on (see <strong><see cref="SharpDX.Direct3D10.MessageId"/></strong>).</p> </dd></param>	
                /// <returns><p>Whether this breaking condition is turned on or off (true for on, false for off).</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::GetBreakOnID']/*"/>	
                /// <msdn-id>bb173788</msdn-id>	
                /// <unmanaged>BOOL ID3D10InfoQueue::GetBreakOnID([In] D3D10_MESSAGE_ID ID)</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::GetBreakOnID</unmanaged-short>	
                public SharpDX.Mathematics.Interop.RawBool GetBreakOnID(SharpDX.Direct3D10.MessageId id) {
                    unsafe {
                        SharpDX.Mathematics.Interop.RawBool __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer, unchecked((int)id),((void**)(*(void**)_nativePointer))[35]);		
                        return __result__;
                    }
                }
                
                /// <summary>	
                /// <p>Set a boolean that turns the debug output on or off.</p>	
                /// </summary>	
                /// <param name="bMute"><dd>  <p>Disable/Enable the debug output (<strong>TRUE</strong> to disable or mute the output, <strong><see cref="SharpDX.Result.False"/></strong> to enable the output).</p> </dd></param>	
                /// <remarks>	
                /// <p>This will stop messages that pass the storage filter from being printed out in the debug output, however those messages will still be added to the message queue.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::SetMuteDebugOutput']/*"/>	
                /// <msdn-id>bb173814</msdn-id>	
                /// <unmanaged>void ID3D10InfoQueue::SetMuteDebugOutput([In] BOOL bMute)</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::SetMuteDebugOutput</unmanaged-short>	
                internal void SetMuteDebugOutput(SharpDX.Mathematics.Interop.RawBool bMute) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid43(_nativePointer, bMute,((void**)(*(void**)_nativePointer))[36]);		
                    }
                }
                
                /// <summary>	
                /// <p>Get a boolean that turns the debug output on or off.</p>	
                /// </summary>	
                /// <returns><p>Whether the debug output is on or off (true for on, false for off).</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InfoQueue::GetMuteDebugOutput']/*"/>	
                /// <msdn-id>bb173792</msdn-id>	
                /// <unmanaged>BOOL ID3D10InfoQueue::GetMuteDebugOutput()</unmanaged>	
                /// <unmanaged-short>ID3D10InfoQueue::GetMuteDebugOutput</unmanaged-short>	
                internal SharpDX.Mathematics.Interop.RawBool GetMuteDebugOutput() {
                    unsafe {
                        SharpDX.Mathematics.Interop.RawBool __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer,((void**)(*(void**)_nativePointer))[37]);		
                        return __result__;
                    }
                }
            }
            /// <summary>	
            /// <p>The device interface represents a virtual adapter for Direct3D 10.0; it is used to perform rendering and create Direct3D resources.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>A device is created using <strong><see cref="SharpDX.Direct3D10.D3D10.CreateDevice"/></strong>.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device']/*"/>	
            /// <msdn-id>bb173528</msdn-id>	
            /// <unmanaged>ID3D10Device</unmanaged>	
            /// <unmanaged-short>ID3D10Device</unmanaged-short>	
            [Guid("9B7E4C0F-342C-4106-A19F-4F2704F689F0")]
            public partial class InputAssemblerStage : SharpDX.CppObject {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.InputAssemblerStage"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public InputAssemblerStage(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.InputAssemblerStage"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.InputAssemblerStage(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.InputAssemblerStage(nativePointer);
        		}
                
                
                /// <summary>	
                /// <p>Get or sets a reference to the input-layout object that is bound to the input-assembler stage.</p>	
                /// </summary>	
                /// <remarks>	
                /// <p>For information about creating an input-layout object, see Creating the Input-Layout Object.</p><p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::IAGetInputLayout']/*"/>	
                /// <msdn-id>bb173585</msdn-id>	
                /// <unmanaged>IAGetInputLayout / IASetInputLayout</unmanaged>	
                /// <unmanaged-short>IAGetInputLayout</unmanaged-short>	
                /// <unmanaged>void ID3D10Device::IAGetInputLayout([Out] ID3D10InputLayout** ppInputLayout)</unmanaged>
                public SharpDX.Direct3D10.InputLayout InputLayout {
                        get { SharpDX.Direct3D10.InputLayout __output__; GetInputLayout(out __output__); return __output__; }
                        set { SetInputLayout(value); }
                }
                
                /// <summary>	
                /// <p>Get or sets information about the primitive type, and data order that describes input data for the input assembler stage.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::IAGetPrimitiveTopology']/*"/>	
                /// <msdn-id>bb173586</msdn-id>	
                /// <unmanaged>IAGetPrimitiveTopology / IASetPrimitiveTopology</unmanaged>	
                /// <unmanaged-short>IAGetPrimitiveTopology</unmanaged-short>	
                /// <unmanaged>void ID3D10Device::IAGetPrimitiveTopology([Out] D3D_PRIMITIVE_TOPOLOGY* pTopology)</unmanaged>
                public SharpDX.Direct3D.PrimitiveTopology PrimitiveTopology {
                        get { SharpDX.Direct3D.PrimitiveTopology __output__; GetPrimitiveTopology(out __output__); return __output__; }
                        set { SetPrimitiveTopology(value); }
                }
                
                /// <summary>	
                /// <p>Bind an input-layout object to the input-assembler stage.</p>	
                /// </summary>	
                /// <param name="inputLayoutRef">No documentation.</param>	
                /// <remarks>	
                /// <p>Input-layout objects describe how vertex buffer data is streamed into the IA pipeline stage. To create an input-layout object, call <strong><see cref="SharpDX.Direct3D10.Device.CreateInputLayout"/></strong>.</p><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::IASetInputLayout']/*"/>	
                /// <msdn-id>bb173589</msdn-id>	
                /// <unmanaged>void ID3D10Device::IASetInputLayout([In, Optional] ID3D10InputLayout* pInputLayout)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::IASetInputLayout</unmanaged-short>	
                internal void SetInputLayout(SharpDX.Direct3D10.InputLayout inputLayoutRef) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, (void*)((inputLayoutRef == null)?IntPtr.Zero:inputLayoutRef.NativePointer),((void**)(*(void**)_nativePointer))[11]);		
                    }
                }
                
                /// <summary>	
                /// <p>Bind an array of vertex buffers to the input-assembler stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numBuffers">No documentation.</param>	
                /// <param name="vertexBuffersOut">No documentation.</param>	
                /// <param name="stridesRef">No documentation.</param>	
                /// <param name="offsetsRef">No documentation.</param>	
                /// <remarks>	
                /// <p>For information about creating vertex buffers, see Create a Vertex Buffer.</p><p>Calling this method using a buffer that is currently bound for writing (i.e. bound to the stream output pipeline stage) will effectively bind <strong><c>null</c></strong> instead because a buffer cannot be bound as both an input and an output at the same time.</p><p>The Debug Layer will generate a warning whenever a resource is prevented from being bound simultaneously as an input and an output, but this will not prevent invalid data from being used by the runtime.</p><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::IASetVertexBuffers']/*"/>	
                /// <msdn-id>bb173591</msdn-id>	
                /// <unmanaged>void ID3D10Device::IASetVertexBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D10Buffer** ppVertexBuffers,[In, Buffer, Optional] const unsigned int* pStrides,[In, Buffer, Optional] const unsigned int* pOffsets)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::IASetVertexBuffers</unmanaged-short>	
                internal void SetVertexBuffers(int startSlot, int numBuffers, SharpDX.Direct3D10.Buffer[] vertexBuffersOut, int[] stridesRef, int[] offsetsRef) {
                    unsafe {
                        IntPtr* vertexBuffersOut_ = (IntPtr*)0;
                        if ( vertexBuffersOut != null ) {
                            IntPtr* vertexBuffersOut__ = stackalloc IntPtr[vertexBuffersOut.Length];
                            vertexBuffersOut_ = vertexBuffersOut__;
                            for (int i = 0; i < vertexBuffersOut.Length; i++)                        
                                vertexBuffersOut_[i] =  (vertexBuffersOut[i] == null)? IntPtr.Zero : vertexBuffersOut[i].NativePointer;
                        }
                        int[] stridesRef__ = stridesRef;
                        int[] offsetsRef__ = offsetsRef;
                        fixed (void* stridesRef_ = stridesRef__)
                            fixed (void* offsetsRef_ = offsetsRef__)
                                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numBuffers, vertexBuffersOut_, stridesRef_, offsetsRef_,((void**)(*(void**)_nativePointer))[12]);		
                    }
                }
                
                /// <summary>	
                /// <p>Bind an array of vertex buffers to the input-assembler stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numBuffers">No documentation.</param>	
                /// <param name="vertexBuffersOut">No documentation.</param>	
                /// <param name="stridesRef">No documentation.</param>	
                /// <param name="offsetsRef">No documentation.</param>	
                /// <remarks>	
                /// <p>For information about creating vertex buffers, see Create a Vertex Buffer.</p><p>Calling this method using a buffer that is currently bound for writing (i.e. bound to the stream output pipeline stage) will effectively bind <strong><c>null</c></strong> instead because a buffer cannot be bound as both an input and an output at the same time.</p><p>The Debug Layer will generate a warning whenever a resource is prevented from being bound simultaneously as an input and an output, but this will not prevent invalid data from being used by the runtime.</p><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::IASetVertexBuffers']/*"/>	
                /// <msdn-id>bb173591</msdn-id>	
                /// <unmanaged>void ID3D10Device::IASetVertexBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D10Buffer** ppVertexBuffers,[In, Buffer, Optional] const unsigned int* pStrides,[In, Buffer, Optional] const unsigned int* pOffsets)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::IASetVertexBuffers</unmanaged-short>	
                internal void SetVertexBuffers(int startSlot, int numBuffers, SharpDX.ComArray<SharpDX.Direct3D10.Buffer> vertexBuffersOut, int[] stridesRef, int[] offsetsRef) {
                    unsafe {
                        int[] stridesRef__ = stridesRef;
                        int[] offsetsRef__ = offsetsRef;
                        fixed (void* stridesRef_ = stridesRef__)
                            fixed (void* offsetsRef_ = offsetsRef__)
                                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numBuffers, (void*)((vertexBuffersOut == null)?IntPtr.Zero:vertexBuffersOut.NativePointer), stridesRef_, offsetsRef_,((void**)(*(void**)_nativePointer))[12]);		
                    }
                }
                
                /// <summary>	
                /// <p>Bind an array of vertex buffers to the input-assembler stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numBuffers">No documentation.</param>	
                /// <param name="vertexBuffersOut">No documentation.</param>	
                /// <param name="stridesRef">No documentation.</param>	
                /// <param name="offsetsRef">No documentation.</param>	
                /// <remarks>	
                /// <p>For information about creating vertex buffers, see Create a Vertex Buffer.</p><p>Calling this method using a buffer that is currently bound for writing (i.e. bound to the stream output pipeline stage) will effectively bind <strong><c>null</c></strong> instead because a buffer cannot be bound as both an input and an output at the same time.</p><p>The Debug Layer will generate a warning whenever a resource is prevented from being bound simultaneously as an input and an output, but this will not prevent invalid data from being used by the runtime.</p><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::IASetVertexBuffers']/*"/>	
                /// <msdn-id>bb173591</msdn-id>	
                /// <unmanaged>void ID3D10Device::IASetVertexBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D10Buffer** ppVertexBuffers,[In, Buffer, Optional] const unsigned int* pStrides,[In, Buffer, Optional] const unsigned int* pOffsets)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::IASetVertexBuffers</unmanaged-short>	
                private void SetVertexBuffers(int startSlot, int numBuffers, System.IntPtr vertexBuffersOut, System.IntPtr stridesRef, System.IntPtr offsetsRef) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numBuffers, (void*)vertexBuffersOut, (void*)stridesRef, (void*)offsetsRef,((void**)(*(void**)_nativePointer))[12]);		
                    }
                }
                
                /// <summary>	
                /// <p>Bind an index buffer to the input-assembler stage.</p>	
                /// </summary>	
                /// <param name="indexBufferRef">No documentation.</param>	
                /// <param name="format">No documentation.</param>	
                /// <param name="offset">No documentation.</param>	
                /// <remarks>	
                /// <p>For information about creating index buffers, see Create an Index Buffer.</p><p>Calling this method using a buffer that is currently bound for writing (i.e. bound to the stream output pipeline stage) will effectively bind <strong><c>null</c></strong> instead because a buffer cannot be bound as both an input and an output at the same time.</p><p>The Debug Layer will generate a warning whenever a resource is prevented from being bound simultaneously as an input and an output, but this will not prevent invalid data from being used by the runtime.</p><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::IASetIndexBuffer']/*"/>	
                /// <msdn-id>bb173588</msdn-id>	
                /// <unmanaged>void ID3D10Device::IASetIndexBuffer([In, Optional] ID3D10Buffer* pIndexBuffer,[In] DXGI_FORMAT Format,[In] unsigned int Offset)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::IASetIndexBuffer</unmanaged-short>	
                public void SetIndexBuffer(SharpDX.Direct3D10.Buffer indexBufferRef, SharpDX.DXGI.Format format, int offset) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, (void*)((indexBufferRef == null)?IntPtr.Zero:indexBufferRef.NativePointer), unchecked((int)format), offset,((void**)(*(void**)_nativePointer))[13]);		
                    }
                }
                
                /// <summary>	
                /// <p>Bind information about the primitive type, and data order that describes input data for the input assembler stage.</p>	
                /// </summary>	
                /// <param name="topology">No documentation.</param>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::IASetPrimitiveTopology']/*"/>	
                /// <msdn-id>bb173590</msdn-id>	
                /// <unmanaged>void ID3D10Device::IASetPrimitiveTopology([In] D3D_PRIMITIVE_TOPOLOGY Topology)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::IASetPrimitiveTopology</unmanaged-short>	
                internal void SetPrimitiveTopology(SharpDX.Direct3D.PrimitiveTopology topology) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, unchecked((int)topology),((void**)(*(void**)_nativePointer))[18]);		
                    }
                }
                
                /// <summary>	
                /// <p>Get a reference to the input-layout object that is bound to the input-assembler stage.</p>	
                /// </summary>	
                /// <param name="inputLayoutOut">No documentation.</param>	
                /// <remarks>	
                /// <p>For information about creating an input-layout object, see Creating the Input-Layout Object.</p><p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::IAGetInputLayout']/*"/>	
                /// <msdn-id>bb173585</msdn-id>	
                /// <unmanaged>void ID3D10Device::IAGetInputLayout([Out] ID3D10InputLayout** ppInputLayout)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::IAGetInputLayout</unmanaged-short>	
                internal void GetInputLayout(out SharpDX.Direct3D10.InputLayout inputLayoutOut) {
                    unsafe {
                        IntPtr inputLayoutOut_ = IntPtr.Zero;
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, &inputLayoutOut_,((void**)(*(void**)_nativePointer))[45]);		
                        inputLayoutOut= (inputLayoutOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.InputLayout(inputLayoutOut_);	
                    }
                }
                
                /// <summary>	
                /// <p>Get the vertex buffers bound to the input-assembler stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numBuffers">No documentation.</param>	
                /// <param name="vertexBuffersOut">No documentation.</param>	
                /// <param name="stridesRef">No documentation.</param>	
                /// <param name="offsetsRef">No documentation.</param>	
                /// <remarks>	
                /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::IAGetVertexBuffers']/*"/>	
                /// <msdn-id>bb173587</msdn-id>	
                /// <unmanaged>void ID3D10Device::IAGetVertexBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[Out, Buffer, Optional] ID3D10Buffer** ppVertexBuffers,[Out, Buffer, Optional] unsigned int* pStrides,[Out, Buffer, Optional] unsigned int* pOffsets)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::IAGetVertexBuffers</unmanaged-short>	
                public void GetVertexBuffers(int startSlot, int numBuffers, SharpDX.Direct3D10.Buffer[] vertexBuffersOut, int[] stridesRef, int[] offsetsRef) {
                    unsafe {
                        IntPtr* vertexBuffersOut_ = stackalloc IntPtr[vertexBuffersOut == null ? 0 : vertexBuffersOut.Length];
                        int[] stridesRef__ = stridesRef;
                        int[] offsetsRef__ = offsetsRef;
                        fixed (void* stridesRef_ = stridesRef__)
                            fixed (void* offsetsRef_ = offsetsRef__)
                                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numBuffers, vertexBuffersOut==null?(void*)0:vertexBuffersOut_, stridesRef_, offsetsRef_,((void**)(*(void**)_nativePointer))[46]);		
                        if (vertexBuffersOut != null)
                        for (int i = 0; i < vertexBuffersOut.Length; i++)
                            vertexBuffersOut[i] = (vertexBuffersOut_[i] == IntPtr.Zero)?null:new SharpDX.Direct3D10.Buffer(vertexBuffersOut_[i]);	
                    }
                }
                
                /// <summary>	
                /// <p>Get a reference to the index buffer that is bound to the input-assembler stage.</p>	
                /// </summary>	
                /// <param name="indexBufferRef">No documentation.</param>	
                /// <param name="format">No documentation.</param>	
                /// <param name="offset">No documentation.</param>	
                /// <remarks>	
                /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::IAGetIndexBuffer']/*"/>	
                /// <msdn-id>bb173584</msdn-id>	
                /// <unmanaged>void ID3D10Device::IAGetIndexBuffer([Out, Optional] ID3D10Buffer** pIndexBuffer,[Out, Optional] DXGI_FORMAT* Format,[Out, Optional] unsigned int* Offset)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::IAGetIndexBuffer</unmanaged-short>	
                public void GetIndexBuffer(out SharpDX.Direct3D10.Buffer indexBufferRef, out SharpDX.DXGI.Format format, out int offset) {
                    unsafe {
                        IntPtr indexBufferRef_ = IntPtr.Zero;
                        fixed (void* format_ = &format)
                            fixed (void* offset_ = &offset)
                                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, &indexBufferRef_, format_, offset_,((void**)(*(void**)_nativePointer))[47]);		
                        indexBufferRef= (indexBufferRef_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.Buffer(indexBufferRef_);	
                    }
                }
                
                /// <summary>	
                /// <p>Get information about the primitive type, and data order that describes input data for the input assembler stage.</p>	
                /// </summary>	
                /// <param name="topologyRef">No documentation.</param>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::IAGetPrimitiveTopology']/*"/>	
                /// <msdn-id>bb173586</msdn-id>	
                /// <unmanaged>void ID3D10Device::IAGetPrimitiveTopology([Out] D3D_PRIMITIVE_TOPOLOGY* pTopology)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::IAGetPrimitiveTopology</unmanaged-short>	
                internal void GetPrimitiveTopology(out SharpDX.Direct3D.PrimitiveTopology topologyRef) {
                    unsafe {
                        fixed (void* topologyRef_ = &topologyRef)
                            SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, topologyRef_,((void**)(*(void**)_nativePointer))[50]);		
                    }
                }
            }
            /// <summary>	
            /// <p>An input-layout interface accesses the input data for the input-assembler stage.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>This interface is created by calling <strong><see cref="SharpDX.Direct3D10.Device.CreateInputLayout"/></strong>; use <strong><see cref="SharpDX.Direct3D10.InputAssemblerStage.SetInputLayout"/></strong> to bind it to the graphics pipeline.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10InputLayout']/*"/>	
            /// <msdn-id>bb173815</msdn-id>	
            /// <unmanaged>ID3D10InputLayout</unmanaged>	
            /// <unmanaged-short>ID3D10InputLayout</unmanaged-short>	
            [Guid("9B7E4C0B-342C-4106-A19F-4F2704F689F0")]
            public partial class InputLayout : SharpDX.Direct3D10.DeviceChild {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.InputLayout"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public InputLayout(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.InputLayout"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.InputLayout(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.InputLayout(nativePointer);
        		}
                
            }
            /// <summary>	
            /// <p>Applications use the methods of the <see cref="SharpDX.Direct3D10.Mesh"/> interface to manipulate mesh objects.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>To obtain the <see cref="SharpDX.Direct3D10.Mesh"/> interface, call <strong><see cref="SharpDX.Direct3D10.D3DX10.CreateMesh"/></strong>.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh']/*"/>	
            /// <msdn-id>bb173897</msdn-id>	
            /// <unmanaged>ID3DX10Mesh</unmanaged>	
            /// <unmanaged-short>ID3DX10Mesh</unmanaged-short>	
            [Guid("4020e5c2-1403-4929-883f-e2e849fac195")]
            public partial class Mesh : SharpDX.ComObject {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.Mesh"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public Mesh(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.Mesh"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.Mesh(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.Mesh(nativePointer);
        		}
                
                
                /// <summary>	
                /// <p>Retrieves the number of faces in the mesh.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::GetFaceCount']/*"/>	
                /// <msdn-id>bb173915</msdn-id>	
                /// <unmanaged>GetFaceCount</unmanaged>	
                /// <unmanaged-short>GetFaceCount</unmanaged-short>	
                /// <unmanaged>unsigned int ID3DX10Mesh::GetFaceCount()</unmanaged>
                public int FaceCount {
                        get { return GetFaceCount(); }
                }
                
                /// <summary>	
                /// <p>Get the number of vertices in the mesh. A mesh may contain multiple vertex buffers (i.e. one vertex buffer may contain all position data, another may contains all texture coordinate data, etc.), however each vertex buffer will contain the same number of elements.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::GetVertexCount']/*"/>	
                /// <msdn-id>bb173921</msdn-id>	
                /// <unmanaged>GetVertexCount</unmanaged>	
                /// <unmanaged-short>GetVertexCount</unmanaged-short>	
                /// <unmanaged>unsigned int ID3DX10Mesh::GetVertexCount()</unmanaged>
                public int VertexCount {
                        get { return GetVertexCount(); }
                }
                
                /// <summary>	
                /// <p>Get the number of vertex buffers in the mesh.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::GetVertexBufferCount']/*"/>	
                /// <msdn-id>bb173920</msdn-id>	
                /// <unmanaged>GetVertexBufferCount</unmanaged>	
                /// <unmanaged-short>GetVertexBufferCount</unmanaged-short>	
                /// <unmanaged>unsigned int ID3DX10Mesh::GetVertexBufferCount()</unmanaged>
                public int VertexBufferCount {
                        get { return GetVertexBufferCount(); }
                }
                
                /// <summary>	
                /// <p>Retrieves the number of faces in the mesh.</p>	
                /// </summary>	
                /// <returns><p>Returns the number of faces in the mesh.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::GetFaceCount']/*"/>	
                /// <msdn-id>bb173915</msdn-id>	
                /// <unmanaged>unsigned int ID3DX10Mesh::GetFaceCount()</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::GetFaceCount</unmanaged-short>	
                internal int GetFaceCount() {
                    unsafe {
                        int __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[3]);		
                        return __result__;
                    }
                }
                
                /// <summary>	
                /// <p>Get the number of vertices in the mesh. A mesh may contain multiple vertex buffers (i.e. one vertex buffer may contain all position data, another may contains all texture coordinate data, etc.), however each vertex buffer will contain the same number of elements.</p>	
                /// </summary>	
                /// <returns><p>The number of vertices in the mesh.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::GetVertexCount']/*"/>	
                /// <msdn-id>bb173921</msdn-id>	
                /// <unmanaged>unsigned int ID3DX10Mesh::GetVertexCount()</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::GetVertexCount</unmanaged-short>	
                internal int GetVertexCount() {
                    unsafe {
                        int __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                        return __result__;
                    }
                }
                
                /// <summary>	
                /// <p>Get the number of vertex buffers in the mesh.</p>	
                /// </summary>	
                /// <returns><p>The number of vertex buffers in the mesh.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::GetVertexBufferCount']/*"/>	
                /// <msdn-id>bb173920</msdn-id>	
                /// <unmanaged>unsigned int ID3DX10Mesh::GetVertexBufferCount()</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::GetVertexBufferCount</unmanaged-short>	
                internal int GetVertexBufferCount() {
                    unsafe {
                        int __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[5]);		
                        return __result__;
                    }
                }
                
                /// <summary>	
                /// <p>Access the mesh's creation flags.</p>	
                /// </summary>	
                /// <returns><p>The creation flags passed into the <em>options</em> parameter of <strong><see cref="SharpDX.Direct3D10.D3DX10.CreateMesh"/></strong> when the mesh was created. See <strong>D3DX10_MESH</strong>.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::GetFlags']/*"/>	
                /// <msdn-id>bb173916</msdn-id>	
                /// <unmanaged>unsigned int ID3DX10Mesh::GetFlags()</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::GetFlags</unmanaged-short>	
                internal int GetFlags() {
                    unsafe {
                        int __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[6]);		
                        return __result__;
                    }
                }
                
                /// <summary>	
                /// <p>Access the vertex description passed into <strong><see cref="SharpDX.Direct3D10.D3DX10.CreateMesh"/></strong>. The vertex description describes the layout of the mesh's vertex buffers.</p>	
                /// </summary>	
                /// <param name="descOut">No documentation.</param>	
                /// <param name="declCountRef">No documentation.</param>	
                /// <returns><p>The return value is one of the values listed in Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::GetVertexDescription']/*"/>	
                /// <msdn-id>bb173922</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Mesh::GetVertexDescription([Out, Buffer] const D3D10_INPUT_ELEMENT_DESC** ppDesc,[In] unsigned int* pDeclCount)</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::GetVertexDescription</unmanaged-short>	
                internal void GetVertexDescription(SharpDX.Direct3D10.InputElement[] descOut, int declCountRef) {
                    unsafe {
                        SharpDX.Direct3D10.InputElement.__Native[] descOut__ = new SharpDX.Direct3D10.InputElement.__Native[descOut.Length];
                        SharpDX.Result __result__;
                        fixed (void* descOut_ = descOut__)
                            __result__= 
            				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, descOut_, &declCountRef,((void**)(*(void**)_nativePointer))[7]);		
                        for (int i = 0; i < descOut.Length; i++)
                            descOut[i].__MarshalFrom(ref descOut__[i]);				
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Set vertex data into one of the mesh's vertex buffers.</p>	
                /// </summary>	
                /// <param name="iBuffer"><dd>  <p>The vertex buffer to be filled with pData.</p> </dd></param>	
                /// <param name="dataRef"><dd>  <p>The vertex data to set.</p> </dd></param>	
                /// <returns><p>The return value is one of the values listed in Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::SetVertexData']/*"/>	
                /// <msdn-id>bb173931</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Mesh::SetVertexData([In] unsigned int iBuffer,[In] const void* pData)</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::SetVertexData</unmanaged-short>	
                internal void SetVertexData(int iBuffer, System.IntPtr dataRef) {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, iBuffer, (void*)dataRef,((void**)(*(void**)_nativePointer))[8]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Retrieves the vertex buffer associated with the mesh.</p>	
                /// </summary>	
                /// <param name="iBuffer"><dd>  <p>The vertex buffer to get. This is an index value.</p> </dd></param>	
                /// <returns><dd>  <p>The vertex buffer. See <strong><see cref="SharpDX.Direct3D10.MeshBuffer"/></strong> </p> </dd></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::GetVertexBuffer']/*"/>	
                /// <msdn-id>bb173919</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Mesh::GetVertexBuffer([In] unsigned int iBuffer,[In] ID3DX10MeshBuffer** ppVertexBuffer)</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::GetVertexBuffer</unmanaged-short>	
                public SharpDX.Direct3D10.MeshBuffer GetVertexBuffer(int iBuffer) {
                    unsafe {
                        SharpDX.Direct3D10.MeshBuffer vertexBufferOut;
                        IntPtr vertexBufferOut_ = IntPtr.Zero;
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, iBuffer, &vertexBufferOut_,((void**)(*(void**)_nativePointer))[9]);		
                        vertexBufferOut= (vertexBufferOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.MeshBuffer(vertexBufferOut_);	
                        __result__.CheckError();
                        return vertexBufferOut;
                    }
                }
                
                /// <summary>	
                /// <p>Set the mesh's index data.</p>	
                /// </summary>	
                /// <param name="dataRef"><dd>  <p>The index data.</p> </dd></param>	
                /// <param name="cIndices"><dd>  <p>The number of indices in pData.</p> </dd></param>	
                /// <returns><p>The return value is one of the values listed in Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::SetIndexData']/*"/>	
                /// <msdn-id>bb173929</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Mesh::SetIndexData([In] const void* pData,[In] unsigned int cIndices)</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::SetIndexData</unmanaged-short>	
                internal void SetIndexData(System.IntPtr dataRef, int cIndices) {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)dataRef, cIndices,((void**)(*(void**)_nativePointer))[10]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Retrieves the data in an index buffer.</p>	
                /// </summary>	
                /// <returns><dd>  <p>Address of a reference to a <see cref="SharpDX.Direct3D10.MeshBuffer"/> interface, representing the index buffer associated with the mesh.</p> </dd></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::GetIndexBuffer']/*"/>	
                /// <msdn-id>bb173917</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Mesh::GetIndexBuffer([In] ID3DX10MeshBuffer** ppIndexBuffer)</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::GetIndexBuffer</unmanaged-short>	
                public SharpDX.Direct3D10.MeshBuffer GetIndexBuffer() {
                    unsafe {
                        SharpDX.Direct3D10.MeshBuffer indexBufferOut;
                        IntPtr indexBufferOut_ = IntPtr.Zero;
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &indexBufferOut_,((void**)(*(void**)_nativePointer))[11]);		
                        indexBufferOut= (indexBufferOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.MeshBuffer(indexBufferOut_);	
                        __result__.CheckError();
                        return indexBufferOut;
                    }
                }
                
                /// <summary>	
                /// <p>Set the mesh's attribute data.</p>	
                /// </summary>	
                /// <param name="dataRef"><dd>  <p>The attribute data to set.</p> </dd></param>	
                /// <returns><p>The return value is one of the values listed in Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::SetAttributeData']/*"/>	
                /// <msdn-id>bb173927</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Mesh::SetAttributeData([In] const void* pData)</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::SetAttributeData</unmanaged-short>	
                internal void SetAttributeData(System.IntPtr dataRef) {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)dataRef,((void**)(*(void**)_nativePointer))[12]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Access the mesh's attribute buffer.</p>	
                /// </summary>	
                /// <param name="attributeBufferOut"><dd>  <p>The attribute buffer. See <strong><see cref="SharpDX.Direct3D10.MeshBuffer"/></strong>.</p> </dd></param>	
                /// <returns><p>The return value is one of the values listed in Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::GetAttributeBuffer']/*"/>	
                /// <msdn-id>bb173911</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Mesh::GetAttributeBuffer([In] ID3DX10MeshBuffer** ppAttributeBuffer)</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::GetAttributeBuffer</unmanaged-short>	
                public void GetAttributeBuffer(out SharpDX.Direct3D10.MeshBuffer attributeBufferOut) {
                    unsafe {
                        IntPtr attributeBufferOut_ = IntPtr.Zero;
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &attributeBufferOut_,((void**)(*(void**)_nativePointer))[13]);		
                        attributeBufferOut= (attributeBufferOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.MeshBuffer(attributeBufferOut_);	
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Sets the attribute table for a mesh and the number of entries stored in the table.</p>	
                /// </summary>	
                /// <param name="attribTableRef"><dd>  <p>Pointer to an array of <see cref="SharpDX.Direct3D10.MeshAttributeRange"/> structures, representing the entries in the mesh attribute table.</p> </dd></param>	
                /// <param name="cAttribTableSize"><dd>  <p>Number of attributes in the mesh attribute table.</p> </dd></param>	
                /// <returns><p>The return value is one of the values listed in Direct3D 10 Return Codes.</p></returns>	
                /// <remarks>	
                /// <p>If an application keeps track of the information in an attribute table, and rearranges the table as a result of changes to attributes or faces, this method allows the application to update the attribute tables instead of calling <see cref="SharpDX.Direct3D10.Mesh.Optimize"/> again.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::SetAttributeTable']/*"/>	
                /// <msdn-id>bb173928</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Mesh::SetAttributeTable([In, Buffer] const D3DX10_ATTRIBUTE_RANGE* pAttribTable,[In] unsigned int cAttribTableSize)</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::SetAttributeTable</unmanaged-short>	
                internal void SetAttributeTable(SharpDX.Direct3D10.MeshAttributeRange[] attribTableRef, int cAttribTableSize) {
                    unsafe {
                        SharpDX.Result __result__;
                        fixed (void* attribTableRef_ = attribTableRef)
                            __result__= 
            				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, attribTableRef_, cAttribTableSize,((void**)(*(void**)_nativePointer))[14]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Retrieves either an attribute table for a mesh, or the number of entries stored in an attribute table for a mesh.</p>	
                /// </summary>	
                /// <param name="attribTableRef"><dd>  <p>Pointer to an array of <see cref="SharpDX.Direct3D10.MeshAttributeRange"/> structures, representing the entries in the mesh's attribute table. Specify <strong><c>null</c></strong> to retrieve the value for pAttribTableSize.</p> </dd></param>	
                /// <param name="attribTableSizeRef"><dd>  <p>Pointer to either the number of entries stored in pAttribTable or a value to be filled in with the number of entries stored in the attribute table for the mesh.</p> </dd></param>	
                /// <returns><p>The return value is one of the values listed in Direct3D 10 Return Codes.</p></returns>	
                /// <remarks>	
                /// <p>An attribute table is used to identify areas of the mesh that need to be drawn with different textures, render states, materials, and so on. In addition, the application can use the attribute table to hide portions of a mesh by not drawing a given attribute identifier when drawing the frame.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::GetAttributeTable']/*"/>	
                /// <msdn-id>bb173912</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Mesh::GetAttributeTable([Out, Buffer, Optional] D3DX10_ATTRIBUTE_RANGE* pAttribTable,[InOut] unsigned int* pAttribTableSize)</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::GetAttributeTable</unmanaged-short>	
                internal void GetAttributeTable(SharpDX.Direct3D10.MeshAttributeRange[] attribTableRef, ref int attribTableSizeRef) {
                    unsafe {
                        SharpDX.Direct3D10.MeshAttributeRange[] attribTableRef__ = attribTableRef;
                        SharpDX.Result __result__;
                        fixed (void* attribTableRef_ = attribTableRef__)
                            fixed (void* attribTableSizeRef_ = &attribTableSizeRef)
                                __result__= 
                				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, attribTableRef_, attribTableSizeRef_,((void**)(*(void**)_nativePointer))[15]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Generate a list of mesh edges, as well as a list of faces that share each edge.</p>	
                /// </summary>	
                /// <param name="epsilon"><dd>  <p>Specifies that vertices that differ in position by less than epsilon should be treated as coincident.</p> </dd></param>	
                /// <returns><p>The return value is one of the values listed in Direct3D 10 Return Codes.</p></returns>	
                /// <remarks>	
                /// <p>After an application generates adjacency information for a mesh, the mesh data can be optimized for better drawing performance.</p><p>The order of the entries in the adjacency buffer is determined by the order of the vertex indices in the index buffer. The adjacent triangle 0 always corresponds to the edge between the indices of the corners 0 and 1. The adjacent triangle 1 always corresponds to the edge between the indices of the corners 1 and 2 while the adjacent triangle 2 corresponds to the edge between the indices of the corners 2 and 0.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::GenerateAdjacencyAndPointReps']/*"/>	
                /// <msdn-id>bb173907</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Mesh::GenerateAdjacencyAndPointReps([In] float Epsilon)</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::GenerateAdjacencyAndPointReps</unmanaged-short>	
                public void GenerateAdjacencyAndPointRepresentation(float epsilon) {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, epsilon,((void**)(*(void**)_nativePointer))[16]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Adds adjacency data to the mesh's index buffer. When the mesh is to be sent to a geometry shader that takes adjacency data, it is neccessary for the mesh's index buffer to contain adjacency data.</p>	
                /// </summary>	
                /// <returns><p>The return value is one of the values listed in Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::GenerateGSAdjacency']/*"/>	
                /// <msdn-id>bb173909</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Mesh::GenerateGSAdjacency()</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::GenerateGSAdjacency</unmanaged-short>	
                public void GenerateGeometryShaderAdjacency() {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[17]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Set the mesh's adjacency data.</p>	
                /// </summary>	
                /// <param name="adjacencyRef"><dd>  <p>The adjacency data to set.</p> </dd></param>	
                /// <returns><p>The return value is one of the values listed in Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::SetAdjacencyData']/*"/>	
                /// <msdn-id>bb173926</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Mesh::SetAdjacencyData([In] const void* pAdjacency)</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::SetAdjacencyData</unmanaged-short>	
                internal void SetAdjacencyData(System.IntPtr adjacencyRef) {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)adjacencyRef,((void**)(*(void**)_nativePointer))[18]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Access the mesh's adjacency buffer.</p>	
                /// </summary>	
                /// <returns><dd>  <p>The adjacency buffer. See <strong><see cref="SharpDX.Direct3D10.MeshBuffer"/></strong>.</p> </dd></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::GetAdjacencyBuffer']/*"/>	
                /// <msdn-id>bb173910</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Mesh::GetAdjacencyBuffer([In] ID3DX10MeshBuffer** ppAdjacency)</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::GetAdjacencyBuffer</unmanaged-short>	
                public SharpDX.Direct3D10.MeshBuffer GetAdjacencyBuffer() {
                    unsafe {
                        SharpDX.Direct3D10.MeshBuffer adjacencyOut;
                        IntPtr adjacencyOut_ = IntPtr.Zero;
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &adjacencyOut_,((void**)(*(void**)_nativePointer))[19]);		
                        adjacencyOut= (adjacencyOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.MeshBuffer(adjacencyOut_);	
                        __result__.CheckError();
                        return adjacencyOut;
                    }
                }
                
                /// <summary>	
                /// <p>Set the point rep data for the mesh.</p>	
                /// </summary>	
                /// <param name="pointRepsRef"><dd>  <p>The point rep data to set.</p> </dd></param>	
                /// <returns><p>The return value is one of the values listed in Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::SetPointRepData']/*"/>	
                /// <msdn-id>bb173930</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Mesh::SetPointRepData([In] const void* pPointReps)</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::SetPointRepData</unmanaged-short>	
                internal void SetPointRepData(System.IntPtr pointRepsRef) {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, (void*)pointRepsRef,((void**)(*(void**)_nativePointer))[20]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Get the mesh's point rep buffer.</p>	
                /// </summary>	
                /// <param name="pointRepsOut"><dd>  <p>Pointer to a mesh buffer containing the mesh's point rep data. See <strong><see cref="SharpDX.Direct3D10.MeshBuffer"/></strong>.</p> </dd></param>	
                /// <returns><p>The return value is one of the values listed in Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::GetPointRepBuffer']/*"/>	
                /// <msdn-id>bb173918</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Mesh::GetPointRepBuffer([In] ID3DX10MeshBuffer** ppPointReps)</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::GetPointRepBuffer</unmanaged-short>	
                internal void GetPointRepBuffer(out SharpDX.Direct3D10.MeshBuffer pointRepsOut) {
                    unsafe {
                        IntPtr pointRepsOut_ = IntPtr.Zero;
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &pointRepsOut_,((void**)(*(void**)_nativePointer))[21]);		
                        pointRepsOut= (pointRepsOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.MeshBuffer(pointRepsOut_);	
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Removes mesh data from the device that has been committed to the device (with <strong><see cref="SharpDX.Direct3D10.Mesh.Commit"/></strong>).</p>	
                /// </summary>	
                /// <param name="dwDiscard">No documentation.</param>	
                /// <returns><p>The return value is one of the values listed in Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::Discard']/*"/>	
                /// <msdn-id>bb173904</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Mesh::Discard([In] D3DX10_MESH_DISCARD_FLAGS dwDiscard)</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::Discard</unmanaged-short>	
                public void Discard(SharpDX.Direct3D10.MeshDiscardFlags dwDiscard) {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, unchecked((int)dwDiscard),((void**)(*(void**)_nativePointer))[22]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Creates a new mesh and fills it with the data of a previously loaded mesh.</p>	
                /// </summary>	
                /// <param name="flags"><dd>  <p>Creation flags to be applied to the new mesh. See <strong>D3DX10_MESH</strong>.</p> </dd></param>	
                /// <param name="posSemanticRef"><dd>  <p>The semantic name for the position data.</p> </dd></param>	
                /// <param name="descRef"><dd>  <p>Array of <see cref="SharpDX.Direct3D10.InputElement"/> structures, describing the vertex format for the returned mesh. See <strong><see cref="SharpDX.Direct3D10.InputElement"/></strong>.</p> </dd></param>	
                /// <param name="declCount"><dd>  <p>The number of elements in the pDesc array.</p> </dd></param>	
                /// <param name="cloneMeshOut"><dd>  <p>The new mesh.</p> </dd></param>	
                /// <returns><p>The return value is one of the values listed in Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::CloneMesh']/*"/>	
                /// <msdn-id>bb173902</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Mesh::CloneMesh([In] unsigned int Flags,[In] const char* pPosSemantic,[In, Buffer] const D3D10_INPUT_ELEMENT_DESC* pDesc,[In] unsigned int DeclCount,[In] ID3DX10Mesh** ppCloneMesh)</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::CloneMesh</unmanaged-short>	
                internal void CloneMesh(int flags, string posSemanticRef, SharpDX.Direct3D10.InputElement[] descRef, int declCount, out SharpDX.Direct3D10.Mesh cloneMeshOut) {
                    unsafe {
                        IntPtr posSemanticRef_ = Utilities.StringToHGlobalAnsi(posSemanticRef);
                        SharpDX.Direct3D10.InputElement.__Native[] descRef__ = new SharpDX.Direct3D10.InputElement.__Native[descRef.Length];
                        for (int i = 0; i < descRef.Length; i++)
                            descRef[i].__MarshalTo(ref descRef__[i]);				
                        IntPtr cloneMeshOut_ = IntPtr.Zero;
                        SharpDX.Result __result__;
                        fixed (void* descRef_ = descRef__)
                            __result__= 
            				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, flags, (void*)posSemanticRef_, descRef_, declCount, &cloneMeshOut_,((void**)(*(void**)_nativePointer))[23]);		
                        Marshal.FreeHGlobal(posSemanticRef_ );
                        for (int i = 0; i < descRef.Length; i++)
                            descRef[i].__MarshalFree(ref descRef__[i]);
                        cloneMeshOut= (cloneMeshOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.Mesh(cloneMeshOut_);	
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Generates a new mesh with reordered faces and vertices to optimize drawing performance.</p>	
                /// </summary>	
                /// <param name="flags"><dd>  <p>Specifies the type of optimization to perform. This parameter can be set to a combination of one or more flags from D3DXMESHOPT and D3DXMESH (except D3DXMESH_32BIT, D3DXMESH_IB_WRITEONLY, and D3DXMESH_WRITEONLY).</p> </dd></param>	
                /// <param name="faceRemapRef"><dd>  <p>An array of UINTs, one per face, that identifies the original mesh face that corresponds to each face in the optimized mesh. If the value supplied for this argument is <strong><c>null</c></strong>, face remap data is not returned.</p> </dd></param>	
                /// <param name="vertexRemapOut"><dd>  <p>Address of a reference to an <strong><see cref="SharpDX.Direct3D.Blob"/> Interface</strong>, which contains a DWORD for each vertex that specifies how the new vertices map to the old vertices. This remap is useful if you need to alter external data based on the new vertex mapping.</p> </dd></param>	
                /// <returns><p>The return value is one of the values listed in Direct3D 10 Return Codes.</p></returns>	
                /// <remarks>	
                /// <p>This method generates a new mesh. Before running Optimize, an application must generate an adjacency buffer by calling <strong><see cref="SharpDX.Direct3D10.Mesh.GenerateAdjacencyAndPointRepresentation"/></strong>. The adjacency buffer contains adjacency data, such as a list of edges and the faces that are adjacent to each other.</p><p>This method is very similar to the <strong><see cref="SharpDX.Direct3D10.Mesh.CloneMesh"/></strong> method, except that it can perform optimization while generating the new clone of the mesh. The output mesh inherits all of the creation parameters of the input mesh.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::Optimize']/*"/>	
                /// <msdn-id>bb173925</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Mesh::Optimize([In] unsigned int Flags,[Out, Buffer, Optional] unsigned int* pFaceRemap,[In] void** ppVertexRemap)</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::Optimize</unmanaged-short>	
                internal void Optimize(int flags, int[] faceRemapRef, System.IntPtr vertexRemapOut) {
                    unsafe {
                        int[] faceRemapRef__ = faceRemapRef;
                        SharpDX.Result __result__;
                        fixed (void* faceRemapRef_ = faceRemapRef__)
                            __result__= 
            				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, flags, faceRemapRef_, (void*)vertexRemapOut,((void**)(*(void**)_nativePointer))[24]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Generate an attribute buffer from the data in the mesh's attribute table. An attribute buffer is another format for storing the data in the attribute table. Both the attribute buffer and the attribute table are internal data structures in the mesh.</p>	
                /// </summary>	
                /// <returns><p>The return value is one of the values listed in Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::GenerateAttributeBufferFromTable']/*"/>	
                /// <msdn-id>bb173908</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Mesh::GenerateAttributeBufferFromTable()</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::GenerateAttributeBufferFromTable</unmanaged-short>	
                public void GenerateAttributeBufferFromTable() {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[25]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Commit any changes made to a mesh to the device so that the changes can be rendered. This should be called after a mesh's data is altered and before it is rendered. A mesh cannot be rendered unless it is committed to the device. See remarks.</p>	
                /// </summary>	
                /// <returns><p>The return value is one of the values listed in Direct3D 10 Return Codes.</p></returns>	
                /// <remarks>	
                /// <p>When a mesh is loaded, it's data is loaded into staging resources, meaning the data can be altered but not rendered. When CommitToDevice is called, the data from the staging resources are copied into device resources so that they can be rendered. Although the data is committed to the device, the staging resources remain and can be modified. If any modifications are made to the staging resources, the staging resources must be committed to the device again in order for those changes to be rendered on screen.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::CommitToDevice']/*"/>	
                /// <msdn-id>bb173903</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Mesh::CommitToDevice()</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::CommitToDevice</unmanaged-short>	
                public void Commit() {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[26]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Draws a subset of a mesh.</p>	
                /// </summary>	
                /// <param name="attribId"><dd>  <p>Specifies which subset of the mesh to draw. This value is used to differentiate faces in a mesh as belonging to one or more attribute groups.</p> </dd></param>	
                /// <returns><p>The return value is one of the values listed in Direct3D 10 Return Codes.</p></returns>	
                /// <remarks>	
                /// <p>An attribute table is used to identify areas of the mesh that need to be drawn with different textures, render states, materials, and so on. In addition, the application can use the attribute table to hide portions of a mesh by not drawing a given attribute identifier (AttribId) when drawing the frame.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::DrawSubset']/*"/>	
                /// <msdn-id>bb173905</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Mesh::DrawSubset([In] unsigned int AttribId)</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::DrawSubset</unmanaged-short>	
                public void DrawSubset(int attribId) {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, attribId,((void**)(*(void**)_nativePointer))[27]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Draw several instances of the same subset of a mesh.</p>	
                /// </summary>	
                /// <param name="attribId"><dd>  <p>Specifies which subset of the mesh to draw. This value is used to differentiate faces in a mesh as belonging to one or more attribute groups.  See remarks.</p> </dd></param>	
                /// <param name="instanceCount"><dd>  <p>Number of instances to render.</p> </dd></param>	
                /// <param name="startInstanceLocation"><dd>  <p>Which instance to start fetching from in each buffer marked as instance data.</p> </dd></param>	
                /// <returns><p>The return value is one of the values listed in Direct3D 10 Return Codes.</p></returns>	
                /// <remarks>	
                /// <p>A mesh contains an attribute table. The attribute table can divide a mesh into subsets, where each subset is identified with an attribute ID.  For example, a mesh with 200 faces, divided into three subsets, might have an attribute table that looks like this:</p><table> <tr><td>AttribID 0</td><td>Faces 0 ~ 50</td></tr> <tr><td>AttribID 1</td><td>Faces 51 ~ 125</td></tr> <tr><td>AttribID 2</td><td>Faces 126 ~ 200</td></tr> </table><p>?</p><p>Instancing may extend performance by reusing the same geometry to draw multiple objects in a scene.  One example of instancing could be to draw the same object with different positions and colors.  Indexing requires multiple vertex buffers: at least one for per-vertex data and a second buffer for per-instance data.</p><p>Drawing instances with DrawSubsetInstanced is very similar to the process used with <strong><see cref="SharpDX.Direct3D10.Device.DrawIndexedInstanced"/></strong> that is outlined  in Instancing Sample.  The key difference when using DrawSubsetInstanced is that vertex and index buffers must be extracted  from the <strong><see cref="SharpDX.Direct3D10.Mesh"/> Interface</strong> object before the instancing data can be combined.</p><p>The following code illustrates extracting the vertex and index buffers from the mesh object.</p><pre> <see cref="SharpDX.Direct3D10.Buffer"/>* vertexBuffer; pDeviceObj-&gt;pMesh-&gt;GetDeviceVertexBuffer(0, &amp;vertexBuffer); <see cref="SharpDX.Direct3D10.Buffer"/>* indexBuffer; pDeviceObj-&gt;pMesh-&gt;GetDeviceIndexBuffer(&amp;indexBuffer); </pre>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::DrawSubsetInstanced']/*"/>	
                /// <msdn-id>bb173906</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Mesh::DrawSubsetInstanced([In] unsigned int AttribId,[In] unsigned int InstanceCount,[In] unsigned int StartInstanceLocation)</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::DrawSubsetInstanced</unmanaged-short>	
                public void DrawSubsetInstanced(int attribId, int instanceCount, int startInstanceLocation) {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, attribId, instanceCount, startInstanceLocation,((void**)(*(void**)_nativePointer))[28]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Access the mesh's vertex buffer after it has been committed to the device with <strong><see cref="SharpDX.Direct3D10.Mesh.Commit"/></strong>. This is different from <strong><see cref="SharpDX.Direct3D10.Mesh.GetVertexBuffer"/></strong>, which returns the vertex buffer before it has been committed to the device.</p>	
                /// </summary>	
                /// <param name="iBuffer">No documentation.</param>	
                /// <returns>No documentation.</returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::GetDeviceVertexBuffer']/*"/>	
                /// <msdn-id>bb173914</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Mesh::GetDeviceVertexBuffer([In] unsigned int iBuffer,[In] ID3D10Buffer** ppVertexBuffer)</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::GetDeviceVertexBuffer</unmanaged-short>	
                public SharpDX.Direct3D10.Buffer GetDeviceVertexBuffer(int iBuffer) {
                    unsafe {
                        SharpDX.Direct3D10.Buffer vertexBufferOut;
                        IntPtr vertexBufferOut_ = IntPtr.Zero;
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, iBuffer, &vertexBufferOut_,((void**)(*(void**)_nativePointer))[29]);		
                        vertexBufferOut= (vertexBufferOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.Buffer(vertexBufferOut_);	
                        __result__.CheckError();
                        return vertexBufferOut;
                    }
                }
                
                /// <summary>	
                /// <p>Access the mesh's index buffer after it has been committed to the device with <strong><see cref="SharpDX.Direct3D10.Mesh.Commit"/></strong>. This is different from <strong><see cref="SharpDX.Direct3D10.Mesh.GetIndexBuffer"/></strong>, which returns the index buffer before it has been committed to the device.</p>	
                /// </summary>	
                /// <returns>No documentation.</returns>	
                /// <remarks>	
                /// <p>If the mesh's index buffer has not already been committed to the device, this API will automatically commit the index buffer before it returns a reference to the buffer.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Mesh::GetDeviceIndexBuffer']/*"/>	
                /// <msdn-id>bb173913</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Mesh::GetDeviceIndexBuffer([In] ID3D10Buffer** ppIndexBuffer)</unmanaged>	
                /// <unmanaged-short>ID3DX10Mesh::GetDeviceIndexBuffer</unmanaged-short>	
                public SharpDX.Direct3D10.Buffer GetDeviceIndexBuffer() {
                    unsafe {
                        SharpDX.Direct3D10.Buffer indexBufferOut;
                        IntPtr indexBufferOut_ = IntPtr.Zero;
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &indexBufferOut_,((void**)(*(void**)_nativePointer))[30]);		
                        indexBufferOut= (indexBufferOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.Buffer(indexBufferOut_);	
                        __result__.CheckError();
                        return indexBufferOut;
                    }
                }
            }
            /// <summary>	
            /// <p>A mesh buffer is a buffer that contains data about a mesh. It can contain one of five different types of data: vertex data, index data, adjacency data, attribute data, or point rep data. The structure is used to access these five pieces of data through the following five APIs: <strong><see cref="SharpDX.Direct3D10.Mesh.GetVertexBuffer"/></strong>, <strong><see cref="SharpDX.Direct3D10.Mesh.GetIndexBuffer"/></strong>, <strong><see cref="SharpDX.Direct3D10.Mesh.GetAdjacencyBuffer"/></strong>, <strong><see cref="SharpDX.Direct3D10.Mesh.GetAttributeBuffer"/></strong>, or <strong><see cref="SharpDX.Direct3D10.Mesh.GetPointRepBuffer"/></strong>.</p>	
            /// </summary>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10MeshBuffer']/*"/>	
            /// <msdn-id>bb173898</msdn-id>	
            /// <unmanaged>ID3DX10MeshBuffer</unmanaged>	
            /// <unmanaged-short>ID3DX10MeshBuffer</unmanaged-short>	
            [Guid("04b0d117-1041-46b1-aa8a-3952848ba22e")]
            public partial class MeshBuffer : SharpDX.ComObject {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.MeshBuffer"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public MeshBuffer(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.MeshBuffer"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.MeshBuffer(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.MeshBuffer(nativePointer);
        		}
                
                
                /// <summary>	
                /// <p>Get the size of the mesh buffer, in bytes.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10MeshBuffer::GetSize']/*"/>	
                /// <msdn-id>bb173899</msdn-id>	
                /// <unmanaged>GetSize</unmanaged>	
                /// <unmanaged-short>GetSize</unmanaged-short>	
                /// <unmanaged>SIZE_T ID3DX10MeshBuffer::GetSize()</unmanaged>
                public SharpDX.PointerSize SizeInBytes {
                        get { return GetSizeInBytes(); }
                }
                
                /// <summary>	
                /// <p>Get a reference to the mesh buffer memory to modify its contents.</p>	
                /// </summary>	
                /// <param name="dataOut"><dd>  <p>Pointer to the buffer data.</p> </dd></param>	
                /// <param name="sizeRef"><dd>  <p>Size of the buffer in bytes.</p> </dd></param>	
                /// <returns><p>The return value is one of the values listed in Direct3D 10 Return Codes.</p></returns>	
                /// <remarks>	
                /// <table> <tr><td> <p>Differences between Direct3D 9 and Direct3D 10:</p> <p>Map() in Direct3D 10 is analogous to resource Map() in Direct3D 9.</p> </td></tr> </table><p>?</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10MeshBuffer::Map']/*"/>	
                /// <msdn-id>bb173900</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10MeshBuffer::Map([Out] void** ppData,[Out] SIZE_T* pSize)</unmanaged>	
                /// <unmanaged-short>ID3DX10MeshBuffer::Map</unmanaged-short>	
                internal void Map(out System.IntPtr dataOut, out SharpDX.PointerSize sizeRef) {
                    unsafe {
                        sizeRef = new SharpDX.PointerSize();
                        SharpDX.Result __result__;
                        fixed (void* dataOut_ = &dataOut)
                            fixed (void* sizeRef_ = &sizeRef)
                                __result__= 
                				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, dataOut_, sizeRef_,((void**)(*(void**)_nativePointer))[3]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Unmap a buffer.</p>	
                /// </summary>	
                /// <returns><p>The return value is one of the values listed in Direct3D 10 Return Codes.</p></returns>	
                /// <remarks>	
                /// <table> <tr><td> <p>Differences between Direct3D 9 and Direct3D 10:</p> <p>Unmap() in Direct3D 10 is analogous to resource Unlock() in Direct3D 9.</p> </td></tr> </table><p>?</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10MeshBuffer::Unmap']/*"/>	
                /// <msdn-id>bb173901</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10MeshBuffer::Unmap()</unmanaged>	
                /// <unmanaged-short>ID3DX10MeshBuffer::Unmap</unmanaged-short>	
                public void Unmap() {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Get the size of the mesh buffer, in bytes.</p>	
                /// </summary>	
                /// <returns><p>The size of the mesh buffer, in bytes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10MeshBuffer::GetSize']/*"/>	
                /// <msdn-id>bb173899</msdn-id>	
                /// <unmanaged>SIZE_T ID3DX10MeshBuffer::GetSize()</unmanaged>	
                /// <unmanaged-short>ID3DX10MeshBuffer::GetSize</unmanaged-short>	
                internal SharpDX.PointerSize GetSizeInBytes() {
                    unsafe {
                        SharpDX.PointerSize __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.CallivoidPtr(_nativePointer,((void**)(*(void**)_nativePointer))[5]);		
                        return __result__;
                    }
                }
            }
            /// <summary>	
            /// <p>The device interface represents a virtual adapter for Direct3D 10.0; it is used to perform rendering and create Direct3D resources.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>A device is created using <strong><see cref="SharpDX.Direct3D10.D3D10.CreateDevice"/></strong>.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device']/*"/>	
            /// <msdn-id>bb173528</msdn-id>	
            /// <unmanaged>ID3D10Device</unmanaged>	
            /// <unmanaged-short>ID3D10Device</unmanaged-short>	
            [Guid("9B7E4C0F-342C-4106-A19F-4F2704F689F0")]
            public partial class OutputMergerStage : SharpDX.CppObject {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.OutputMergerStage"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public OutputMergerStage(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.OutputMergerStage"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.OutputMergerStage(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.OutputMergerStage(nativePointer);
        		}
                
                
                /// <summary>	
                /// <p>Bind one or more render targets and the depth-stencil buffer to the output-merger stage.</p>	
                /// </summary>	
                /// <param name="numViews">No documentation.</param>	
                /// <param name="renderTargetViewsOut">No documentation.</param>	
                /// <param name="depthStencilViewRef">No documentation.</param>	
                /// <remarks>	
                /// <p>A call to <strong>OMSetRenderTargets</strong> overrides all bounded render targets and the depth stencil target regardless of the number of render targets in <em>ppRenderTargetViews</em>.</p><p>The maximum number of render targets a device can have active at any given time is set by a #define in D3D10.h called D3D10_SIMULTANEOUS_RENDER_TARGET_COUNT. It is invalid to try to set the same subresource to multiple render target slots.</p><p>If any subresources are also currently bound for reading or writing (perhaps in a different part of the pipeline), those bind points will be <strong><c>null</c></strong>'ed out to prevent the same subresource from being read and written simultaneously in a single rendering operation.</p><p>The method will not hold references to the interfaces passed in. For that reason, applications should be careful not to release interfaces currently in use by the device.</p><p>See Binding Resources and Pipeline stages for more information on binding resources.</p><p>The pixel shader must be able to simultaneously render to at least eight separate render targets. All of these render targets must access the same type of resource: Buffer, Texture1D, Texture1DArray, Texture2D, Texture2DArray, Texture3D, or TextureCube. All render targets must have the same size in all dimensions (width and height, and depth for 3D or array size for *Array types). If render targets use multisample anti-aliasing, all bound render targets and depth buffer must be the same form of multisample resource (that is, the sample counts must be the same). Each render target can have a different data format. These render target formats are not required to have identical bit-per-element counts.</p><p>Any combination of the eight slots for render targets can have a render target set or not set.</p><p>The same resource view cannot be bound to multiple render target slots simultaneously. However, you can set multiple non-overlapping resource views of a single resource as simultaneous multiple render targets.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::OMSetRenderTargets']/*"/>	
                /// <msdn-id>bb173597</msdn-id>	
                /// <unmanaged>void ID3D10Device::OMSetRenderTargets([In] unsigned int NumViews,[In, Buffer, Optional] const ID3D10RenderTargetView** ppRenderTargetViews,[In, Optional] ID3D10DepthStencilView* pDepthStencilView)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::OMSetRenderTargets</unmanaged-short>	
                public void SetRenderTargets(int numViews, SharpDX.Direct3D10.RenderTargetView[] renderTargetViewsOut, SharpDX.Direct3D10.DepthStencilView depthStencilViewRef) {
                    unsafe {
                        IntPtr* renderTargetViewsOut_ = (IntPtr*)0;
                        if ( renderTargetViewsOut != null ) {
                            IntPtr* renderTargetViewsOut__ = stackalloc IntPtr[renderTargetViewsOut.Length];
                            renderTargetViewsOut_ = renderTargetViewsOut__;
                            for (int i = 0; i < renderTargetViewsOut.Length; i++)                        
                                renderTargetViewsOut_[i] =  (renderTargetViewsOut[i] == null)? IntPtr.Zero : renderTargetViewsOut[i].NativePointer;
                        }
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, numViews, renderTargetViewsOut_, (void*)((depthStencilViewRef == null)?IntPtr.Zero:depthStencilViewRef.NativePointer),((void**)(*(void**)_nativePointer))[24]);		
                    }
                }
                
                /// <summary>	
                /// <p>Bind one or more render targets and the depth-stencil buffer to the output-merger stage.</p>	
                /// </summary>	
                /// <param name="numViews">No documentation.</param>	
                /// <param name="renderTargetViewsOut">No documentation.</param>	
                /// <param name="depthStencilViewRef">No documentation.</param>	
                /// <remarks>	
                /// <p>A call to <strong>OMSetRenderTargets</strong> overrides all bounded render targets and the depth stencil target regardless of the number of render targets in <em>ppRenderTargetViews</em>.</p><p>The maximum number of render targets a device can have active at any given time is set by a #define in D3D10.h called D3D10_SIMULTANEOUS_RENDER_TARGET_COUNT. It is invalid to try to set the same subresource to multiple render target slots.</p><p>If any subresources are also currently bound for reading or writing (perhaps in a different part of the pipeline), those bind points will be <strong><c>null</c></strong>'ed out to prevent the same subresource from being read and written simultaneously in a single rendering operation.</p><p>The method will not hold references to the interfaces passed in. For that reason, applications should be careful not to release interfaces currently in use by the device.</p><p>See Binding Resources and Pipeline stages for more information on binding resources.</p><p>The pixel shader must be able to simultaneously render to at least eight separate render targets. All of these render targets must access the same type of resource: Buffer, Texture1D, Texture1DArray, Texture2D, Texture2DArray, Texture3D, or TextureCube. All render targets must have the same size in all dimensions (width and height, and depth for 3D or array size for *Array types). If render targets use multisample anti-aliasing, all bound render targets and depth buffer must be the same form of multisample resource (that is, the sample counts must be the same). Each render target can have a different data format. These render target formats are not required to have identical bit-per-element counts.</p><p>Any combination of the eight slots for render targets can have a render target set or not set.</p><p>The same resource view cannot be bound to multiple render target slots simultaneously. However, you can set multiple non-overlapping resource views of a single resource as simultaneous multiple render targets.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::OMSetRenderTargets']/*"/>	
                /// <msdn-id>bb173597</msdn-id>	
                /// <unmanaged>void ID3D10Device::OMSetRenderTargets([In] unsigned int NumViews,[In, Buffer, Optional] const ID3D10RenderTargetView** ppRenderTargetViews,[In, Optional] ID3D10DepthStencilView* pDepthStencilView)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::OMSetRenderTargets</unmanaged-short>	
                public void SetRenderTargets(int numViews, SharpDX.ComArray<SharpDX.Direct3D10.RenderTargetView> renderTargetViewsOut, SharpDX.Direct3D10.DepthStencilView depthStencilViewRef) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, numViews, (void*)((renderTargetViewsOut == null)?IntPtr.Zero:renderTargetViewsOut.NativePointer), (void*)((depthStencilViewRef == null)?IntPtr.Zero:depthStencilViewRef.NativePointer),((void**)(*(void**)_nativePointer))[24]);		
                    }
                }
                
                /// <summary>	
                /// <p>Bind one or more render targets and the depth-stencil buffer to the output-merger stage.</p>	
                /// </summary>	
                /// <param name="numViews">No documentation.</param>	
                /// <param name="renderTargetViewsOut">No documentation.</param>	
                /// <param name="depthStencilViewRef">No documentation.</param>	
                /// <remarks>	
                /// <p>A call to <strong>OMSetRenderTargets</strong> overrides all bounded render targets and the depth stencil target regardless of the number of render targets in <em>ppRenderTargetViews</em>.</p><p>The maximum number of render targets a device can have active at any given time is set by a #define in D3D10.h called D3D10_SIMULTANEOUS_RENDER_TARGET_COUNT. It is invalid to try to set the same subresource to multiple render target slots.</p><p>If any subresources are also currently bound for reading or writing (perhaps in a different part of the pipeline), those bind points will be <strong><c>null</c></strong>'ed out to prevent the same subresource from being read and written simultaneously in a single rendering operation.</p><p>The method will not hold references to the interfaces passed in. For that reason, applications should be careful not to release interfaces currently in use by the device.</p><p>See Binding Resources and Pipeline stages for more information on binding resources.</p><p>The pixel shader must be able to simultaneously render to at least eight separate render targets. All of these render targets must access the same type of resource: Buffer, Texture1D, Texture1DArray, Texture2D, Texture2DArray, Texture3D, or TextureCube. All render targets must have the same size in all dimensions (width and height, and depth for 3D or array size for *Array types). If render targets use multisample anti-aliasing, all bound render targets and depth buffer must be the same form of multisample resource (that is, the sample counts must be the same). Each render target can have a different data format. These render target formats are not required to have identical bit-per-element counts.</p><p>Any combination of the eight slots for render targets can have a render target set or not set.</p><p>The same resource view cannot be bound to multiple render target slots simultaneously. However, you can set multiple non-overlapping resource views of a single resource as simultaneous multiple render targets.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::OMSetRenderTargets']/*"/>	
                /// <msdn-id>bb173597</msdn-id>	
                /// <unmanaged>void ID3D10Device::OMSetRenderTargets([In] unsigned int NumViews,[In, Buffer, Optional] const ID3D10RenderTargetView** ppRenderTargetViews,[In, Optional] ID3D10DepthStencilView* pDepthStencilView)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::OMSetRenderTargets</unmanaged-short>	
                private void SetRenderTargets(int numViews, System.IntPtr renderTargetViewsOut, System.IntPtr depthStencilViewRef) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, numViews, (void*)renderTargetViewsOut, (void*)depthStencilViewRef,((void**)(*(void**)_nativePointer))[24]);		
                    }
                }
                
                /// <summary>	
                /// <p>Set the blend state of the output-merger stage.</p>	
                /// </summary>	
                /// <param name="blendStateRef">No documentation.</param>	
                /// <param name="blendFactor">No documentation.</param>	
                /// <param name="sampleMask">No documentation.</param>	
                /// <remarks>	
                /// <p>Blend state is used by the output-merger stage to determine how to blend together two RGB pixel values and two alpha values. The two RGB pixel values and two alpha values are the RGB pixel value and alpha value that the pixel shader outputs and the RGB pixel value and alpha value already in the output render target. The <strong>blend option</strong> controls the data source that the blending stage uses to modulate values for the pixel shader, render target, or both. The <strong>blend operation</strong> controls how the blending stage mathematically combines these modulated values.</p><p>To create a blend-state interface, call <strong><see cref="SharpDX.Direct3D10.Device.CreateBlendState"/></strong>.</p><p>Passing in <strong><c>null</c></strong> for the blend-state interface indicates to the runtime to set a default blending state.  The following table indicates the default blending parameters.</p><table> <tr><th>State</th><th>Default Value</th></tr> <tr><td>AlphaToCoverageEnable</td><td><strong><see cref="SharpDX.Result.False"/></strong></td></tr> <tr><td>BlendEnable</td><td><strong><see cref="SharpDX.Result.False"/></strong>[8]</td></tr> <tr><td>SrcBlend</td><td><see cref="SharpDX.Direct3D10.BlendOption.One"/></td></tr> <tr><td>DstBlend</td><td><see cref="SharpDX.Direct3D10.BlendOption.Zero"/></td></tr> <tr><td>BlendOp</td><td><see cref="SharpDX.Direct3D10.BlendOperation.Add"/></td></tr> <tr><td>SrcBlendAlpha</td><td><see cref="SharpDX.Direct3D10.BlendOption.One"/></td></tr> <tr><td>DstBlendAlpha</td><td><see cref="SharpDX.Direct3D10.BlendOption.Zero"/></td></tr> <tr><td>BlendOpAlpha</td><td><see cref="SharpDX.Direct3D10.BlendOperation.Add"/></td></tr> <tr><td>RenderTargetWriteMask[8]</td><td><see cref="SharpDX.Direct3D10.ColorWriteMaskFlags.All"/>[8]</td></tr> </table><p>?</p><p>A sample mask determines which samples get updated in all the active render targets. The mapping of bits in a sample mask to samples in a multisample render target is the responsibility of an individual application. A sample mask is always applied; it is independent of whether multisampling is enabled, and does not depend on whether an application uses multisample render targets.</p><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::OMSetBlendState']/*"/>	
                /// <msdn-id>bb173595</msdn-id>	
                /// <unmanaged>void ID3D10Device::OMSetBlendState([In, Optional] ID3D10BlendState* pBlendState,[In] const SHARPDX_COLOR4* BlendFactor,[In] unsigned int SampleMask)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::OMSetBlendState</unmanaged-short>	
                public void SetBlendState(SharpDX.Direct3D10.BlendState blendStateRef, SharpDX.Mathematics.Interop.RawColor4 blendFactor, int sampleMask) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, (void*)((blendStateRef == null)?IntPtr.Zero:blendStateRef.NativePointer), &blendFactor, sampleMask,((void**)(*(void**)_nativePointer))[25]);		
                    }
                }
                
                /// <summary>	
                /// <p>Sets the depth-stencil state of  the output-merger stage.</p>	
                /// </summary>	
                /// <param name="depthStencilStateRef">No documentation.</param>	
                /// <param name="stencilRef">No documentation.</param>	
                /// <remarks>	
                /// <p>To create a depth-stencil state interface, call <strong><see cref="SharpDX.Direct3D10.Device.CreateDepthStencilState"/></strong>.</p><p>Depth-stencil state is used by the output-merger stage to  setup depth-stencil testing.  The stencil reference value is the control value used in the depth-stencil test.</p><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an  interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::OMSetDepthStencilState']/*"/>	
                /// <msdn-id>bb173596</msdn-id>	
                /// <unmanaged>void ID3D10Device::OMSetDepthStencilState([In, Optional] ID3D10DepthStencilState* pDepthStencilState,[In] unsigned int StencilRef)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::OMSetDepthStencilState</unmanaged-short>	
                public void SetDepthStencilState(SharpDX.Direct3D10.DepthStencilState depthStencilStateRef, int stencilRef) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, (void*)((depthStencilStateRef == null)?IntPtr.Zero:depthStencilStateRef.NativePointer), stencilRef,((void**)(*(void**)_nativePointer))[26]);		
                    }
                }
                
                /// <summary>	
                /// <p>Get references to the render targets and the depth-stencil buffer that are available to the output-merger stage.</p>	
                /// </summary>	
                /// <param name="numViews">No documentation.</param>	
                /// <param name="renderTargetViewsOut">No documentation.</param>	
                /// <param name="depthStencilViewOut">No documentation.</param>	
                /// <remarks>	
                /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::OMGetRenderTargets']/*"/>	
                /// <msdn-id>bb173594</msdn-id>	
                /// <unmanaged>void ID3D10Device::OMGetRenderTargets([In] unsigned int NumViews,[Out, Buffer, Optional] ID3D10RenderTargetView** ppRenderTargetViews,[Out, Optional] ID3D10DepthStencilView** ppDepthStencilView)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::OMGetRenderTargets</unmanaged-short>	
                internal void GetRenderTargets(int numViews, SharpDX.Direct3D10.RenderTargetView[] renderTargetViewsOut, out SharpDX.Direct3D10.DepthStencilView depthStencilViewOut) {
                    unsafe {
                        IntPtr* renderTargetViewsOut_ = stackalloc IntPtr[renderTargetViewsOut == null ? 0 : renderTargetViewsOut.Length];
                        IntPtr depthStencilViewOut_ = IntPtr.Zero;
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, numViews, renderTargetViewsOut==null?(void*)0:renderTargetViewsOut_, &depthStencilViewOut_,((void**)(*(void**)_nativePointer))[56]);		
                        if (renderTargetViewsOut != null)
                        for (int i = 0; i < renderTargetViewsOut.Length; i++)
                            renderTargetViewsOut[i] = (renderTargetViewsOut_[i] == IntPtr.Zero)?null:new SharpDX.Direct3D10.RenderTargetView(renderTargetViewsOut_[i]);	
                        depthStencilViewOut= (depthStencilViewOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.DepthStencilView(depthStencilViewOut_);	
                    }
                }
                
                /// <summary>	
                /// <p>Get the blend state of the output-merger stage.</p>	
                /// </summary>	
                /// <param name="blendStateOut">No documentation.</param>	
                /// <param name="blendFactor">No documentation.</param>	
                /// <param name="sampleMaskRef">No documentation.</param>	
                /// <remarks>	
                /// <p>The reference count of the returned interface will be incremented by one when the blend state is retrieved. Applications must release returned reference(s) when they are no longer needed, or else there will be a memory leak.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::OMGetBlendState']/*"/>	
                /// <msdn-id>bb173592</msdn-id>	
                /// <unmanaged>void ID3D10Device::OMGetBlendState([Out, Optional] ID3D10BlendState** ppBlendState,[Out, Optional] SHARPDX_COLOR4* BlendFactor,[Out, Optional] unsigned int* pSampleMask)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::OMGetBlendState</unmanaged-short>	
                internal void GetBlendState(out SharpDX.Direct3D10.BlendState blendStateOut, out SharpDX.Mathematics.Interop.RawColor4 blendFactor, out int sampleMaskRef) {
                    unsafe {
                        IntPtr blendStateOut_ = IntPtr.Zero;
                        blendFactor = new SharpDX.Mathematics.Interop.RawColor4();
                        fixed (void* blendFactor_ = &blendFactor)
                            fixed (void* sampleMaskRef_ = &sampleMaskRef)
                                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, &blendStateOut_, blendFactor_, sampleMaskRef_,((void**)(*(void**)_nativePointer))[57]);		
                        blendStateOut= (blendStateOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.BlendState(blendStateOut_);	
                    }
                }
                
                /// <summary>	
                /// <p>Gets the depth-stencil state of the output-merger stage.</p>	
                /// </summary>	
                /// <param name="depthStencilStateOut">No documentation.</param>	
                /// <param name="stencilRefRef">No documentation.</param>	
                /// <remarks>	
                /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::OMGetDepthStencilState']/*"/>	
                /// <msdn-id>bb173593</msdn-id>	
                /// <unmanaged>void ID3D10Device::OMGetDepthStencilState([Out, Optional] ID3D10DepthStencilState** ppDepthStencilState,[Out, Optional] unsigned int* pStencilRef)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::OMGetDepthStencilState</unmanaged-short>	
                internal void GetDepthStencilState(out SharpDX.Direct3D10.DepthStencilState depthStencilStateOut, out int stencilRefRef) {
                    unsafe {
                        IntPtr depthStencilStateOut_ = IntPtr.Zero;
                        fixed (void* stencilRefRef_ = &stencilRefRef)
                            SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, &depthStencilStateOut_, stencilRefRef_,((void**)(*(void**)_nativePointer))[58]);		
                        depthStencilStateOut= (depthStencilStateOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.DepthStencilState(depthStencilStateOut_);	
                    }
                }
            }
            /// <summary>	
            /// <p>A pixel-shader interface manages an executable program (a pixel shader) that controls the pixel-shader stage.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>The pixel-shader interface has no methods; use HLSL to implement your shader functionality. All shaders in Direct3D 10 are implemented from a common set of features referred to as the common shader core.</p><p>To create a pixel shader interface, call <strong><see cref="SharpDX.Direct3D10.Device.CreatePixelShader"/></strong>. Before using a pixel shader you must bind it to the device by calling <strong><see cref="SharpDX.Direct3D10.PixelShaderStage.Set"/></strong>.</p><p>This interface is defined in D3D10.h.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10PixelShader']/*"/>	
            /// <msdn-id>bb173821</msdn-id>	
            /// <unmanaged>ID3D10PixelShader</unmanaged>	
            /// <unmanaged-short>ID3D10PixelShader</unmanaged-short>	
            [Guid("4968B601-9D00-4cde-8346-8E7F675819B6")]
            public partial class PixelShader : SharpDX.Direct3D10.DeviceChild {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.PixelShader"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public PixelShader(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.PixelShader"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.PixelShader(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.PixelShader(nativePointer);
        		}
                
            }
            /// <summary>	
            /// <p>The device interface represents a virtual adapter for Direct3D 10.0; it is used to perform rendering and create Direct3D resources.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>A device is created using <strong><see cref="SharpDX.Direct3D10.D3D10.CreateDevice"/></strong>.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device']/*"/>	
            /// <msdn-id>bb173528</msdn-id>	
            /// <unmanaged>ID3D10Device</unmanaged>	
            /// <unmanaged-short>ID3D10Device</unmanaged-short>	
            [Guid("9B7E4C0F-342C-4106-A19F-4F2704F689F0")]
            public partial class PixelShaderStage : CommonShaderStage<PixelShader> {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.PixelShaderStage"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public PixelShaderStage(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.PixelShaderStage"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.PixelShaderStage(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.PixelShaderStage(nativePointer);
        		}
                
                
                /// <summary>	
                /// <p>Bind an array of shader resources to the pixel shader stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numViews">No documentation.</param>	
                /// <param name="shaderResourceViewsOut">No documentation.</param>	
                /// <remarks>	
                /// <p>If you bind a subresource as an input and an output, this API will fill the destination shader resource slot with <strong><c>null</c></strong>. The debug layer (when active) will alert you if this is true.</p><p>For information about creating shader-resource views, see <strong><see cref="SharpDX.Direct3D10.Device.CreateShaderResourceView"/></strong>.</p><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::PSSetShaderResources']/*"/>	
                /// <msdn-id>bb173606</msdn-id>	
                /// <unmanaged>void ID3D10Device::PSSetShaderResources([In] unsigned int StartSlot,[In] unsigned int NumViews,[In, Buffer, Optional] const ID3D10ShaderResourceView** ppShaderResourceViews)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::PSSetShaderResources</unmanaged-short>	
                public override void SetShaderResources(int startSlot, int numViews, SharpDX.Direct3D10.ShaderResourceView[] shaderResourceViewsOut) {
                    unsafe {
                        IntPtr* shaderResourceViewsOut_ = (IntPtr*)0;
                        if ( shaderResourceViewsOut != null ) {
                            IntPtr* shaderResourceViewsOut__ = stackalloc IntPtr[shaderResourceViewsOut.Length];
                            shaderResourceViewsOut_ = shaderResourceViewsOut__;
                            for (int i = 0; i < shaderResourceViewsOut.Length; i++)                        
                                shaderResourceViewsOut_[i] =  (shaderResourceViewsOut[i] == null)? IntPtr.Zero : shaderResourceViewsOut[i].NativePointer;
                        }
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numViews, shaderResourceViewsOut_,((void**)(*(void**)_nativePointer))[4]);		
                    }
                }
                
                /// <summary>	
                /// <p>Bind an array of shader resources to the pixel shader stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numViews">No documentation.</param>	
                /// <param name="shaderResourceViewsOut">No documentation.</param>	
                /// <remarks>	
                /// <p>If you bind a subresource as an input and an output, this API will fill the destination shader resource slot with <strong><c>null</c></strong>. The debug layer (when active) will alert you if this is true.</p><p>For information about creating shader-resource views, see <strong><see cref="SharpDX.Direct3D10.Device.CreateShaderResourceView"/></strong>.</p><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::PSSetShaderResources']/*"/>	
                /// <msdn-id>bb173606</msdn-id>	
                /// <unmanaged>void ID3D10Device::PSSetShaderResources([In] unsigned int StartSlot,[In] unsigned int NumViews,[In, Buffer, Optional] const ID3D10ShaderResourceView** ppShaderResourceViews)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::PSSetShaderResources</unmanaged-short>	
                public override void SetShaderResources(int startSlot, int numViews, SharpDX.ComArray<SharpDX.Direct3D10.ShaderResourceView> shaderResourceViewsOut) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numViews, (void*)((shaderResourceViewsOut == null)?IntPtr.Zero:shaderResourceViewsOut.NativePointer),((void**)(*(void**)_nativePointer))[4]);		
                    }
                }
                
                /// <summary>	
                /// <p>Bind an array of shader resources to the pixel shader stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numViews">No documentation.</param>	
                /// <param name="shaderResourceViewsOut">No documentation.</param>	
                /// <remarks>	
                /// <p>If you bind a subresource as an input and an output, this API will fill the destination shader resource slot with <strong><c>null</c></strong>. The debug layer (when active) will alert you if this is true.</p><p>For information about creating shader-resource views, see <strong><see cref="SharpDX.Direct3D10.Device.CreateShaderResourceView"/></strong>.</p><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::PSSetShaderResources']/*"/>	
                /// <msdn-id>bb173606</msdn-id>	
                /// <unmanaged>void ID3D10Device::PSSetShaderResources([In] unsigned int StartSlot,[In] unsigned int NumViews,[In, Buffer, Optional] const ID3D10ShaderResourceView** ppShaderResourceViews)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::PSSetShaderResources</unmanaged-short>	
                private void SetShaderResources(int startSlot, int numViews, System.IntPtr shaderResourceViewsOut) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numViews, (void*)shaderResourceViewsOut,((void**)(*(void**)_nativePointer))[4]);		
                    }
                }
                
                /// <summary>	
                /// <p>Sets a pixel shader to the device.</p>	
                /// </summary>	
                /// <param name="pixelShaderRef"><dd>  <p>Pointer to a pixel shader (see <strong><see cref="SharpDX.Direct3D10.PixelShader"/></strong>). Passing in <strong><c>null</c></strong> disables the shader for this pipeline stage.</p> </dd></param>	
                /// <remarks>	
                /// <p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::PSSetShader']/*"/>	
                /// <msdn-id>bb173605</msdn-id>	
                /// <unmanaged>void ID3D10Device::PSSetShader([In, Optional] ID3D10PixelShader* pPixelShader)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::PSSetShader</unmanaged-short>	
                public void Set(SharpDX.Direct3D10.PixelShader pixelShaderRef) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, (void*)((pixelShaderRef == null)?IntPtr.Zero:pixelShaderRef.NativePointer),((void**)(*(void**)_nativePointer))[5]);		
                    }
                }
                
                /// <summary>	
                /// <p>Set an array of sampler states to the pixel shader pipeline stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numSamplers">No documentation.</param>	
                /// <param name="samplersOut">No documentation.</param>	
                /// <remarks>	
                /// <p>Any sampler may be set to <strong><c>null</c></strong>; this invokes the default state, which is defined to be the following.</p><table> <tr><th>State</th><th>Default Value</th></tr> <tr><td>Filter</td><td><see cref="SharpDX.Direct3D10.Filter.MinMagMipLinear"/></td></tr> <tr><td>AddressU</td><td><see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/></td></tr> <tr><td>AddressV</td><td><see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/></td></tr> <tr><td>AddressW</td><td><see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/></td></tr> <tr><td>MipLODBias</td><td>0</td></tr> <tr><td>MaxAnisotropy</td><td>1</td></tr> <tr><td>ComparisonFunc</td><td><see cref="SharpDX.Direct3D10.Comparison.Never"/></td></tr> <tr><td>BorderColor[0]</td><td>1.0f</td></tr> <tr><td>BorderColor[1]</td><td>1.0f</td></tr> <tr><td>BorderColor[2]</td><td>1.0f</td></tr> <tr><td>BorderColor[3]</td><td>1.0f</td></tr> <tr><td>MinLOD</td><td>-FLT_MAX</td></tr> <tr><td>MaxLOD</td><td>FLT_MAX</td></tr> </table><p>?</p><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::PSSetSamplers']/*"/>	
                /// <msdn-id>bb173604</msdn-id>	
                /// <unmanaged>void ID3D10Device::PSSetSamplers([In] unsigned int StartSlot,[In] unsigned int NumSamplers,[In, Buffer, Optional] const ID3D10SamplerState** ppSamplers)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::PSSetSamplers</unmanaged-short>	
                public override void SetSamplers(int startSlot, int numSamplers, SharpDX.Direct3D10.SamplerState[] samplersOut) {
                    unsafe {
                        IntPtr* samplersOut_ = (IntPtr*)0;
                        if ( samplersOut != null ) {
                            IntPtr* samplersOut__ = stackalloc IntPtr[samplersOut.Length];
                            samplersOut_ = samplersOut__;
                            for (int i = 0; i < samplersOut.Length; i++)                        
                                samplersOut_[i] =  (samplersOut[i] == null)? IntPtr.Zero : samplersOut[i].NativePointer;
                        }
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numSamplers, samplersOut_,((void**)(*(void**)_nativePointer))[6]);		
                    }
                }
                
                /// <summary>	
                /// <p>Set an array of sampler states to the pixel shader pipeline stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numSamplers">No documentation.</param>	
                /// <param name="samplersOut">No documentation.</param>	
                /// <remarks>	
                /// <p>Any sampler may be set to <strong><c>null</c></strong>; this invokes the default state, which is defined to be the following.</p><table> <tr><th>State</th><th>Default Value</th></tr> <tr><td>Filter</td><td><see cref="SharpDX.Direct3D10.Filter.MinMagMipLinear"/></td></tr> <tr><td>AddressU</td><td><see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/></td></tr> <tr><td>AddressV</td><td><see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/></td></tr> <tr><td>AddressW</td><td><see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/></td></tr> <tr><td>MipLODBias</td><td>0</td></tr> <tr><td>MaxAnisotropy</td><td>1</td></tr> <tr><td>ComparisonFunc</td><td><see cref="SharpDX.Direct3D10.Comparison.Never"/></td></tr> <tr><td>BorderColor[0]</td><td>1.0f</td></tr> <tr><td>BorderColor[1]</td><td>1.0f</td></tr> <tr><td>BorderColor[2]</td><td>1.0f</td></tr> <tr><td>BorderColor[3]</td><td>1.0f</td></tr> <tr><td>MinLOD</td><td>-FLT_MAX</td></tr> <tr><td>MaxLOD</td><td>FLT_MAX</td></tr> </table><p>?</p><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::PSSetSamplers']/*"/>	
                /// <msdn-id>bb173604</msdn-id>	
                /// <unmanaged>void ID3D10Device::PSSetSamplers([In] unsigned int StartSlot,[In] unsigned int NumSamplers,[In, Buffer, Optional] const ID3D10SamplerState** ppSamplers)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::PSSetSamplers</unmanaged-short>	
                public override void SetSamplers(int startSlot, int numSamplers, SharpDX.ComArray<SharpDX.Direct3D10.SamplerState> samplersOut) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numSamplers, (void*)((samplersOut == null)?IntPtr.Zero:samplersOut.NativePointer),((void**)(*(void**)_nativePointer))[6]);		
                    }
                }
                
                /// <summary>	
                /// <p>Set an array of sampler states to the pixel shader pipeline stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numSamplers">No documentation.</param>	
                /// <param name="samplersOut">No documentation.</param>	
                /// <remarks>	
                /// <p>Any sampler may be set to <strong><c>null</c></strong>; this invokes the default state, which is defined to be the following.</p><table> <tr><th>State</th><th>Default Value</th></tr> <tr><td>Filter</td><td><see cref="SharpDX.Direct3D10.Filter.MinMagMipLinear"/></td></tr> <tr><td>AddressU</td><td><see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/></td></tr> <tr><td>AddressV</td><td><see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/></td></tr> <tr><td>AddressW</td><td><see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/></td></tr> <tr><td>MipLODBias</td><td>0</td></tr> <tr><td>MaxAnisotropy</td><td>1</td></tr> <tr><td>ComparisonFunc</td><td><see cref="SharpDX.Direct3D10.Comparison.Never"/></td></tr> <tr><td>BorderColor[0]</td><td>1.0f</td></tr> <tr><td>BorderColor[1]</td><td>1.0f</td></tr> <tr><td>BorderColor[2]</td><td>1.0f</td></tr> <tr><td>BorderColor[3]</td><td>1.0f</td></tr> <tr><td>MinLOD</td><td>-FLT_MAX</td></tr> <tr><td>MaxLOD</td><td>FLT_MAX</td></tr> </table><p>?</p><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::PSSetSamplers']/*"/>	
                /// <msdn-id>bb173604</msdn-id>	
                /// <unmanaged>void ID3D10Device::PSSetSamplers([In] unsigned int StartSlot,[In] unsigned int NumSamplers,[In, Buffer, Optional] const ID3D10SamplerState** ppSamplers)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::PSSetSamplers</unmanaged-short>	
                private void SetSamplers(int startSlot, int numSamplers, System.IntPtr samplersOut) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numSamplers, (void*)samplersOut,((void**)(*(void**)_nativePointer))[6]);		
                    }
                }
                
                /// <summary>	
                /// <p>Set the constant buffers used by the pixel shader pipeline stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numBuffers">No documentation.</param>	
                /// <param name="constantBuffersOut">No documentation.</param>	
                /// <remarks>	
                /// <p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::PSSetConstantBuffers']/*"/>	
                /// <msdn-id>bb173603</msdn-id>	
                /// <unmanaged>void ID3D10Device::PSSetConstantBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D10Buffer** ppConstantBuffers)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::PSSetConstantBuffers</unmanaged-short>	
                public override void SetConstantBuffers(int startSlot, int numBuffers, SharpDX.Direct3D10.Buffer[] constantBuffersOut) {
                    unsafe {
                        IntPtr* constantBuffersOut_ = (IntPtr*)0;
                        if ( constantBuffersOut != null ) {
                            IntPtr* constantBuffersOut__ = stackalloc IntPtr[constantBuffersOut.Length];
                            constantBuffersOut_ = constantBuffersOut__;
                            for (int i = 0; i < constantBuffersOut.Length; i++)                        
                                constantBuffersOut_[i] =  (constantBuffersOut[i] == null)? IntPtr.Zero : constantBuffersOut[i].NativePointer;
                        }
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numBuffers, constantBuffersOut_,((void**)(*(void**)_nativePointer))[10]);		
                    }
                }
                
                /// <summary>	
                /// <p>Set the constant buffers used by the pixel shader pipeline stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numBuffers">No documentation.</param>	
                /// <param name="constantBuffersOut">No documentation.</param>	
                /// <remarks>	
                /// <p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::PSSetConstantBuffers']/*"/>	
                /// <msdn-id>bb173603</msdn-id>	
                /// <unmanaged>void ID3D10Device::PSSetConstantBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D10Buffer** ppConstantBuffers)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::PSSetConstantBuffers</unmanaged-short>	
                public override void SetConstantBuffers(int startSlot, int numBuffers, SharpDX.ComArray<SharpDX.Direct3D10.Buffer> constantBuffersOut) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numBuffers, (void*)((constantBuffersOut == null)?IntPtr.Zero:constantBuffersOut.NativePointer),((void**)(*(void**)_nativePointer))[10]);		
                    }
                }
                
                /// <summary>	
                /// <p>Set the constant buffers used by the pixel shader pipeline stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numBuffers">No documentation.</param>	
                /// <param name="constantBuffersOut">No documentation.</param>	
                /// <remarks>	
                /// <p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::PSSetConstantBuffers']/*"/>	
                /// <msdn-id>bb173603</msdn-id>	
                /// <unmanaged>void ID3D10Device::PSSetConstantBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D10Buffer** ppConstantBuffers)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::PSSetConstantBuffers</unmanaged-short>	
                private void SetConstantBuffers(int startSlot, int numBuffers, System.IntPtr constantBuffersOut) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numBuffers, (void*)constantBuffersOut,((void**)(*(void**)_nativePointer))[10]);		
                    }
                }
                
                /// <summary>	
                /// <p>Get the pixel shader resources.</p>	
                /// </summary>	
                /// <param name="startSlot"><dd>  <p>Index into the device's zero-based array to begin getting shader resources from.</p> </dd></param>	
                /// <param name="numViews"><dd>  <p>The number of resources to get from the device. Up to a maximum of 128 slots are available for shader resources.</p> </dd></param>	
                /// <param name="shaderResourceViewsOut"><dd>  <p>Array of <strong>shader resource view</strong> interfaces to be returned by the device.</p> </dd></param>	
                /// <remarks>	
                /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::PSGetShaderResources']/*"/>	
                /// <msdn-id>bb173602</msdn-id>	
                /// <unmanaged>void ID3D10Device::PSGetShaderResources([In] unsigned int StartSlot,[In] unsigned int NumViews,[Out, Buffer, Optional] ID3D10ShaderResourceView** ppShaderResourceViews)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::PSGetShaderResources</unmanaged-short>	
                internal override void GetShaderResources(int startSlot, int numViews, SharpDX.Direct3D10.ShaderResourceView[] shaderResourceViewsOut) {
                    unsafe {
                        IntPtr* shaderResourceViewsOut_ = stackalloc IntPtr[shaderResourceViewsOut == null ? 0 : shaderResourceViewsOut.Length];
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numViews, shaderResourceViewsOut==null?(void*)0:shaderResourceViewsOut_,((void**)(*(void**)_nativePointer))[40]);		
                        if (shaderResourceViewsOut != null)
                        for (int i = 0; i < shaderResourceViewsOut.Length; i++)
                            shaderResourceViewsOut[i] = (shaderResourceViewsOut_[i] == IntPtr.Zero)?null:new SharpDX.Direct3D10.ShaderResourceView(shaderResourceViewsOut_[i]);	
                    }
                }
                
                /// <summary>	
                /// <p>Get the pixel shader currently set on the device.</p>	
                /// </summary>	
                /// <param name="pixelShaderOut"><dd>  <p>Address of a reference to a pixel shader (see <strong><see cref="SharpDX.Direct3D10.PixelShader"/></strong>) to be returned by the method.</p> </dd></param>	
                /// <remarks>	
                /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::PSGetShader']/*"/>	
                /// <msdn-id>bb173601</msdn-id>	
                /// <unmanaged>void ID3D10Device::PSGetShader([Out] ID3D10PixelShader** ppPixelShader)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::PSGetShader</unmanaged-short>	
                public void Get(out SharpDX.Direct3D10.PixelShader pixelShaderOut) {
                    unsafe {
                        IntPtr pixelShaderOut_ = IntPtr.Zero;
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, &pixelShaderOut_,((void**)(*(void**)_nativePointer))[41]);		
                        pixelShaderOut= (pixelShaderOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.PixelShader(pixelShaderOut_);	
                    }
                }
                
                /// <summary>	
                /// <p>Get an array of sampler states from the pixel shader pipeline stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numSamplers">No documentation.</param>	
                /// <param name="samplersOut">No documentation.</param>	
                /// <remarks>	
                /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::PSGetSamplers']/*"/>	
                /// <msdn-id>bb173600</msdn-id>	
                /// <unmanaged>void ID3D10Device::PSGetSamplers([In] unsigned int StartSlot,[In] unsigned int NumSamplers,[Out, Buffer, Optional] ID3D10SamplerState** ppSamplers)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::PSGetSamplers</unmanaged-short>	
                internal override void GetSamplers(int startSlot, int numSamplers, SharpDX.Direct3D10.SamplerState[] samplersOut) {
                    unsafe {
                        IntPtr* samplersOut_ = stackalloc IntPtr[samplersOut == null ? 0 : samplersOut.Length];
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numSamplers, samplersOut==null?(void*)0:samplersOut_,((void**)(*(void**)_nativePointer))[42]);		
                        if (samplersOut != null)
                        for (int i = 0; i < samplersOut.Length; i++)
                            samplersOut[i] = (samplersOut_[i] == IntPtr.Zero)?null:new SharpDX.Direct3D10.SamplerState(samplersOut_[i]);	
                    }
                }
                
                /// <summary>	
                /// <p>Get the constant buffers used by the pixel shader pipeline stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numBuffers">No documentation.</param>	
                /// <param name="constantBuffersOut">No documentation.</param>	
                /// <remarks>	
                /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::PSGetConstantBuffers']/*"/>	
                /// <msdn-id>bb173599</msdn-id>	
                /// <unmanaged>void ID3D10Device::PSGetConstantBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[Out, Buffer, Optional] ID3D10Buffer** ppConstantBuffers)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::PSGetConstantBuffers</unmanaged-short>	
                internal override void GetConstantBuffers(int startSlot, int numBuffers, SharpDX.Direct3D10.Buffer[] constantBuffersOut) {
                    unsafe {
                        IntPtr* constantBuffersOut_ = stackalloc IntPtr[constantBuffersOut == null ? 0 : constantBuffersOut.Length];
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numBuffers, constantBuffersOut==null?(void*)0:constantBuffersOut_,((void**)(*(void**)_nativePointer))[44]);		
                        if (constantBuffersOut != null)
                        for (int i = 0; i < constantBuffersOut.Length; i++)
                            constantBuffersOut[i] = (constantBuffersOut_[i] == IntPtr.Zero)?null:new SharpDX.Direct3D10.Buffer(constantBuffersOut_[i]);	
                    }
                }
            }
            /// <summary>	
            /// <p>A predicate interface determines whether geometry should be processed depending on the results of a previous draw call.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>A predicate can be created with <strong><see cref="SharpDX.Direct3D10.Device.CreatePredicate"/></strong>, and used with <strong><see cref="SharpDX.Direct3D10.Device.SetPredication"/></strong>.</p><p>There are two types of predicates in Direct3D 10: stream-output-overflow predicates and occlusion predicates. Stream-output-overflow predicates will cause any geometry residing in stream-output buffers that were overflowed to not be processed. Occlusion predicates will cause any geometry that did not have a single sample pass the depth/stencil tests to not be processed.</p><p>For an example of occlusion-predicated rendering, see Draw Predicated Sample. </p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Predicate']/*"/>	
            /// <msdn-id>bb173822</msdn-id>	
            /// <unmanaged>ID3D10Predicate</unmanaged>	
            /// <unmanaged-short>ID3D10Predicate</unmanaged-short>	
            [Guid("9B7E4C10-342C-4106-A19F-4F2704F689F0")]
            public partial class Predicate : SharpDX.Direct3D10.Query {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.Predicate"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public Predicate(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.Predicate"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.Predicate(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.Predicate(nativePointer);
        		}
                
            }
            /// <summary>	
            /// <p>A query interface queries information from the GPU.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>A query can be created with <strong><see cref="SharpDX.Direct3D10.Device.CreateQuery"/></strong>.</p><p>This interface inherits the functionality of an <strong><see cref="SharpDX.Direct3D10.Asynchronous"/> Interface</strong>.</p><p>Query data is typically gathered by issuing an <strong><see cref="SharpDX.Direct3D10.Asynchronous.Begin"/></strong> command, issuing some graphics commands, issuing an <strong><see cref="SharpDX.Direct3D10.Asynchronous.End"/></strong> command, and then calling <strong><see cref="SharpDX.Direct3D10.Asynchronous.GetData"/></strong> to get data about what happened in between the Begin and End calls. The data returned by GetData will be different depending on the type of query.</p><p>There are, however, some queries that do not require calls to Begin. For a list of possible queries see <strong><see cref="SharpDX.Direct3D10.QueryType"/></strong>.</p><p>A query is typically executed as shown in the following code:</p><pre><see cref="SharpDX.Direct3D10.QueryDescription"/> queryDesc; ... // Fill out queryDesc structure <see cref="SharpDX.Direct3D10.Query"/> * pQuery;	
            /// pDevice-&gt;CreateQuery(&amp;queryDesc, &amp;pQuery); pQuery-&gt;Begin(); ... // Issue graphis commands, do whatever pQuery-&gt;End(); UINT64 queryData; // This data type is different depending on the query type while( <see cref="SharpDX.Result.Ok"/> != pQuery-&gt;GetData(&amp;queryData, sizeof(UINT64), 0) )	
            /// {	
            /// }	
            /// </pre><p>When using a query that does not require a call to Begin, it still requires a call to End. The call to End causes the data returned by GetData to be accurate up until the last call to End.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Query']/*"/>	
            /// <msdn-id>bb173823</msdn-id>	
            /// <unmanaged>ID3D10Query</unmanaged>	
            /// <unmanaged-short>ID3D10Query</unmanaged-short>	
            [Guid("9B7E4C0E-342C-4106-A19F-4F2704F689F0")]
            public partial class Query : SharpDX.Direct3D10.Asynchronous {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.Query"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public Query(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.Query"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.Query(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.Query(nativePointer);
        		}
                
                
                /// <summary>	
                /// <p>Get a query description.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Query::GetDesc']/*"/>	
                /// <msdn-id>bb173824</msdn-id>	
                /// <unmanaged>GetDesc</unmanaged>	
                /// <unmanaged-short>GetDesc</unmanaged-short>	
                /// <unmanaged>void ID3D10Query::GetDesc([Out] D3D10_QUERY_DESC* pDesc)</unmanaged>
                public SharpDX.Direct3D10.QueryDescription Description {
                        get { SharpDX.Direct3D10.QueryDescription __output__; GetDescription(out __output__); return __output__; }
                }
                
                /// <summary>	
                /// <p>Get a query description.</p>	
                /// </summary>	
                /// <param name="descRef"><dd>  <p>Pointer to a query description (see <strong><see cref="SharpDX.Direct3D10.QueryDescription"/></strong>).</p> </dd></param>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Query::GetDesc']/*"/>	
                /// <msdn-id>bb173824</msdn-id>	
                /// <unmanaged>void ID3D10Query::GetDesc([Out] D3D10_QUERY_DESC* pDesc)</unmanaged>	
                /// <unmanaged-short>ID3D10Query::GetDesc</unmanaged-short>	
                internal void GetDescription(out SharpDX.Direct3D10.QueryDescription descRef) {
                    unsafe {
                        descRef = new SharpDX.Direct3D10.QueryDescription();
                        fixed (void* descRef_ = &descRef)
                            SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, descRef_,((void**)(*(void**)_nativePointer))[11]);		
                    }
                }
            }
            /// <summary>	
            /// <p>The device interface represents a virtual adapter for Direct3D 10.0; it is used to perform rendering and create Direct3D resources.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>A device is created using <strong><see cref="SharpDX.Direct3D10.D3D10.CreateDevice"/></strong>.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device']/*"/>	
            /// <msdn-id>bb173528</msdn-id>	
            /// <unmanaged>ID3D10Device</unmanaged>	
            /// <unmanaged-short>ID3D10Device</unmanaged-short>	
            [Guid("9B7E4C0F-342C-4106-A19F-4F2704F689F0")]
            public partial class RasterizerStage : SharpDX.CppObject {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.RasterizerStage"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public RasterizerStage(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.RasterizerStage"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.RasterizerStage(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.RasterizerStage(nativePointer);
        		}
                
                
                /// <summary>	
                /// <p>Get or sets the <strong>rasterizer state</strong> from the rasterizer stage of the pipeline.</p>	
                /// </summary>	
                /// <remarks>	
                /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::RSGetState']/*"/>	
                /// <msdn-id>bb173609</msdn-id>	
                /// <unmanaged>RSGetState / RSSetState</unmanaged>	
                /// <unmanaged-short>RSGetState</unmanaged-short>	
                /// <unmanaged>void ID3D10Device::RSGetState([Out] ID3D10RasterizerState** ppRasterizerState)</unmanaged>
                public SharpDX.Direct3D10.RasterizerState State {
                        get { SharpDX.Direct3D10.RasterizerState __output__; GetState(out __output__); return __output__; }
                        set { SetState(value); }
                }
                
                /// <summary>	
                /// <p>Set the <strong>rasterizer state</strong> for the rasterizer stage of the pipeline.</p>	
                /// </summary>	
                /// <param name="rasterizerStateRef">No documentation.</param>	
                /// <remarks>	
                /// <p>To create a rasterizer state interface, call <strong><see cref="SharpDX.Direct3D10.Device.CreateRasterizerState"/></strong>. For more details on setting up the rasterizer state, see Set Rasterizer State.</p><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::RSSetState']/*"/>	
                /// <msdn-id>bb173612</msdn-id>	
                /// <unmanaged>void ID3D10Device::RSSetState([In, Optional] ID3D10RasterizerState* pRasterizerState)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::RSSetState</unmanaged-short>	
                internal void SetState(SharpDX.Direct3D10.RasterizerState rasterizerStateRef) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, (void*)((rasterizerStateRef == null)?IntPtr.Zero:rasterizerStateRef.NativePointer),((void**)(*(void**)_nativePointer))[29]);		
                    }
                }
                
                /// <summary>	
                /// <p>Bind an array of viewports to the rasterizer stage of the pipeline.</p>	
                /// </summary>	
                /// <param name="numViewports">No documentation.</param>	
                /// <param name="viewportsRef">No documentation.</param>	
                /// <remarks>	
                /// <p>All viewports must be set atomically as one operation. Any viewports not defined by the call are disabled.</p><p>Which viewport to use is determined by the SV_ViewportArrayIndex semantic output by a geometry shader (see shader semantic syntax). If a geometry shader does not make use of the SV_ViewportArrayIndex semantic then Direct3D will use the first viewport in the array.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::RSSetViewports']/*"/>	
                /// <msdn-id>bb173613</msdn-id>	
                /// <unmanaged>void ID3D10Device::RSSetViewports([In] unsigned int NumViewports,[In, Buffer, Optional] const D3D10_VIEWPORT* pViewports)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::RSSetViewports</unmanaged-short>	
                internal void SetViewports(int numViewports, SharpDX.Mathematics.Interop.RawViewport[] viewportsRef) {
                    unsafe {
                        SharpDX.Mathematics.Interop.RawViewport[] viewportsRef__ = viewportsRef;
                        fixed (void* viewportsRef_ = viewportsRef__)
                            SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, numViewports, viewportsRef_,((void**)(*(void**)_nativePointer))[30]);		
                    }
                }
                
                /// <summary>	
                /// <p>Bind an array of scissor rectangles to the rasterizer stage.</p>	
                /// </summary>	
                /// <param name="numRects">No documentation.</param>	
                /// <param name="rectsRef">No documentation.</param>	
                /// <remarks>	
                /// <p>The scissor rectangles will only be used if ScissorEnable is set to true in the rasterizer state (see <strong><see cref="SharpDX.Direct3D10.RasterizerStateDescription"/></strong>).</p><p>Which scissor rectangle to use is determined by the SV_ViewportArrayIndex semantic output by a geometry shader (see shader semantic syntax). If a geometry shader does not make use of the SV_ViewportArrayIndex semantic then Direct3D will use the first scissor rectangle in the array.</p><p>Each scissor rectangle in the array corresponds to a viewport in an array of viewports (see <strong><see cref="SharpDX.Direct3D10.RasterizerStage.SetViewports"/></strong>).</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::RSSetScissorRects']/*"/>	
                /// <msdn-id>bb173611</msdn-id>	
                /// <unmanaged>void ID3D10Device::RSSetScissorRects([In] unsigned int NumRects,[In, Buffer, Optional] const RECT* pRects)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::RSSetScissorRects</unmanaged-short>	
                internal void SetScissorRects(int numRects, SharpDX.Mathematics.Interop.RawRectangle[] rectsRef) {
                    unsafe {
                        SharpDX.Mathematics.Interop.RawRectangle[] rectsRef__ = rectsRef;
                        fixed (void* rectsRef_ = rectsRef__)
                            SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, numRects, rectsRef_,((void**)(*(void**)_nativePointer))[31]);		
                    }
                }
                
                /// <summary>	
                /// <p>Get the <strong>rasterizer state</strong> from the rasterizer stage of the pipeline.</p>	
                /// </summary>	
                /// <param name="rasterizerStateOut">No documentation.</param>	
                /// <remarks>	
                /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::RSGetState']/*"/>	
                /// <msdn-id>bb173609</msdn-id>	
                /// <unmanaged>void ID3D10Device::RSGetState([Out] ID3D10RasterizerState** ppRasterizerState)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::RSGetState</unmanaged-short>	
                internal void GetState(out SharpDX.Direct3D10.RasterizerState rasterizerStateOut) {
                    unsafe {
                        IntPtr rasterizerStateOut_ = IntPtr.Zero;
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, &rasterizerStateOut_,((void**)(*(void**)_nativePointer))[60]);		
                        rasterizerStateOut= (rasterizerStateOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.RasterizerState(rasterizerStateOut_);	
                    }
                }
                
                /// <summary>	
                /// <p>Get the array of viewports bound  to the rasterizer stage </p>	
                /// </summary>	
                /// <param name="numViewports">No documentation.</param>	
                /// <param name="viewportsRef">No documentation.</param>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::RSGetViewports']/*"/>	
                /// <msdn-id>bb173610</msdn-id>	
                /// <unmanaged>void ID3D10Device::RSGetViewports([InOut] unsigned int* NumViewports,[Out, Buffer, Optional] D3D10_VIEWPORT* pViewports)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::RSGetViewports</unmanaged-short>	
                internal void GetViewports(ref int numViewports, SharpDX.Mathematics.Interop.RawViewport[] viewportsRef) {
                    unsafe {
                        SharpDX.Mathematics.Interop.RawViewport[] viewportsRef__ = viewportsRef;
                        fixed (void* numViewports_ = &numViewports)
                            fixed (void* viewportsRef_ = viewportsRef__)
                                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, numViewports_, viewportsRef_,((void**)(*(void**)_nativePointer))[61]);		
                    }
                }
                
                /// <summary>	
                /// <p>Get the array of scissor rectangles bound to the rasterizer stage.</p>	
                /// </summary>	
                /// <param name="numRects">No documentation.</param>	
                /// <param name="rectsRef">No documentation.</param>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::RSGetScissorRects']/*"/>	
                /// <msdn-id>bb173608</msdn-id>	
                /// <unmanaged>void ID3D10Device::RSGetScissorRects([InOut] unsigned int* NumRects,[Out, Buffer, Optional] RECT* pRects)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::RSGetScissorRects</unmanaged-short>	
                internal void GetScissorRects(ref int numRects, SharpDX.Mathematics.Interop.RawRectangle[] rectsRef) {
                    unsafe {
                        SharpDX.Mathematics.Interop.RawRectangle[] rectsRef__ = rectsRef;
                        fixed (void* numRects_ = &numRects)
                            fixed (void* rectsRef_ = rectsRef__)
                                SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, numRects_, rectsRef_,((void**)(*(void**)_nativePointer))[62]);		
                    }
                }
            }
            /// <summary>	
            /// <p>A rasterizer-state interface accesses rasterizer state for the rasterizer stage.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>A rasterizer-state object is created with <strong><see cref="SharpDX.Direct3D10.Device.CreateRasterizerState"/></strong> and bound to the pipeline with <strong><see cref="SharpDX.Direct3D10.RasterizerStage.SetState"/></strong>.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10RasterizerState']/*"/>	
            /// <msdn-id>bb173825</msdn-id>	
            /// <unmanaged>ID3D10RasterizerState</unmanaged>	
            /// <unmanaged-short>ID3D10RasterizerState</unmanaged-short>	
            [Guid("A2A07292-89AF-4345-BE2E-C53D9FBB6E9F")]
            public partial class RasterizerState : SharpDX.Direct3D10.DeviceChild {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.RasterizerState"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public RasterizerState(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.RasterizerState"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.RasterizerState(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.RasterizerState(nativePointer);
        		}
                
                
                /// <summary>	
                /// <p>Get the properties of a rasterizer-state object.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10RasterizerState::GetDesc']/*"/>	
                /// <msdn-id>bb173826</msdn-id>	
                /// <unmanaged>GetDesc</unmanaged>	
                /// <unmanaged-short>GetDesc</unmanaged-short>	
                /// <unmanaged>void ID3D10RasterizerState::GetDesc([Out] D3D10_RASTERIZER_DESC* pDesc)</unmanaged>
                public SharpDX.Direct3D10.RasterizerStateDescription Description {
                        get { SharpDX.Direct3D10.RasterizerStateDescription __output__; GetDescription(out __output__); return __output__; }
                }
                
                /// <summary>	
                /// <p>Get the properties of a rasterizer-state object.</p>	
                /// </summary>	
                /// <param name="descRef"><dd>  <p>Pointer to a rasterizer-state description (see <strong><see cref="SharpDX.Direct3D10.RasterizerStateDescription"/></strong>).</p> </dd></param>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10RasterizerState::GetDesc']/*"/>	
                /// <msdn-id>bb173826</msdn-id>	
                /// <unmanaged>void ID3D10RasterizerState::GetDesc([Out] D3D10_RASTERIZER_DESC* pDesc)</unmanaged>	
                /// <unmanaged-short>ID3D10RasterizerState::GetDesc</unmanaged-short>	
                internal void GetDescription(out SharpDX.Direct3D10.RasterizerStateDescription descRef) {
                    unsafe {
                        descRef = new SharpDX.Direct3D10.RasterizerStateDescription();
                        fixed (void* descRef_ = &descRef)
                            SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, descRef_,((void**)(*(void**)_nativePointer))[7]);		
                    }
                }
            }
            /// <summary>	
            /// <p>A render-target-view interface identifies the render-target subresources that can be accessed during rendering.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>To create a render-target view, call <strong><see cref="SharpDX.Direct3D10.Device.CreateRenderTargetView"/></strong>. To bind a render-target view to the pipeline, call <strong><see cref="SharpDX.Direct3D10.OutputMergerStage.SetRenderTargets"/></strong>.</p><p>A rendertarget is a resource that can be written by the output-merger stage at the end of a render pass. Each render-target should also have a corresponding depth-stencil view.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10RenderTargetView']/*"/>	
            /// <msdn-id>bb173827</msdn-id>	
            /// <unmanaged>ID3D10RenderTargetView</unmanaged>	
            /// <unmanaged-short>ID3D10RenderTargetView</unmanaged-short>	
            [Guid("9B7E4C08-342C-4106-A19F-4F2704F689F0")]
            public partial class RenderTargetView : SharpDX.Direct3D10.ResourceView {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.RenderTargetView"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public RenderTargetView(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.RenderTargetView"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.RenderTargetView(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.RenderTargetView(nativePointer);
        		}
                
                
                /// <summary>	
                /// <p>Get the properties of a render target view.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10RenderTargetView::GetDesc']/*"/>	
                /// <msdn-id>bb173828</msdn-id>	
                /// <unmanaged>GetDesc</unmanaged>	
                /// <unmanaged-short>GetDesc</unmanaged-short>	
                /// <unmanaged>void ID3D10RenderTargetView::GetDesc([Out] D3D10_RENDER_TARGET_VIEW_DESC* pDesc)</unmanaged>
                public SharpDX.Direct3D10.RenderTargetViewDescription Description {
                        get { SharpDX.Direct3D10.RenderTargetViewDescription __output__; GetDescription(out __output__); return __output__; }
                }
                
                /// <summary>	
                /// <p>Get the properties of a render target view.</p>	
                /// </summary>	
                /// <param name="descRef"><dd>  <p>Pointer to the description of a render target view (see <strong><see cref="SharpDX.Direct3D10.RenderTargetViewDescription"/></strong>).</p> </dd></param>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10RenderTargetView::GetDesc']/*"/>	
                /// <msdn-id>bb173828</msdn-id>	
                /// <unmanaged>void ID3D10RenderTargetView::GetDesc([Out] D3D10_RENDER_TARGET_VIEW_DESC* pDesc)</unmanaged>	
                /// <unmanaged-short>ID3D10RenderTargetView::GetDesc</unmanaged-short>	
                internal void GetDescription(out SharpDX.Direct3D10.RenderTargetViewDescription descRef) {
                    unsafe {
                        descRef = new SharpDX.Direct3D10.RenderTargetViewDescription();
                        fixed (void* descRef_ = &descRef)
                            SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, descRef_,((void**)(*(void**)_nativePointer))[8]);		
                    }
                }
            }
            /// <summary>	
            /// <p>A resource interface provides common actions on all resources.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>A resource interface cannot be created directly; instead, buffers and textures are created that inherit from a resource interface (see Creating Buffer Resources or Creating Texture Resources).</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Resource']/*"/>	
            /// <msdn-id>bb173829</msdn-id>	
            /// <unmanaged>ID3D10Resource</unmanaged>	
            /// <unmanaged-short>ID3D10Resource</unmanaged-short>	
            [Guid("9B7E4C01-342C-4106-A19F-4F2704F689F0")]
            public partial class Resource : SharpDX.Direct3D10.DeviceChild {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.Resource"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public Resource(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.Resource"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.Resource(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.Resource(nativePointer);
        		}
                
                
                /// <summary>Constant MaximumMipLevels.</summary>
                /// <unmanaged>D3D10_REQ_MIP_LEVELS</unmanaged>
                public const int MaximumMipLevels = 14;
                
                /// <summary>Constant ResourceSizeInMegabytes.</summary>
                /// <unmanaged>D3D10_REQ_RESOURCE_SIZE_IN_MEGABYTES</unmanaged>
                public const int ResourceSizeInMegabytes = 128;
                
                /// <summary>Constant MaximumTexture1DArraySize.</summary>
                /// <unmanaged>D3D10_REQ_TEXTURE1D_ARRAY_AXIS_DIMENSION</unmanaged>
                public const int MaximumTexture1DArraySize = 512;
                
                /// <summary>Constant MaximumTexture2DArraySize.</summary>
                /// <unmanaged>D3D10_REQ_TEXTURE2D_ARRAY_AXIS_DIMENSION</unmanaged>
                public const int MaximumTexture2DArraySize = 512;
                
                /// <summary>Constant MaximumTexture1DSize.</summary>
                /// <unmanaged>D3D10_REQ_TEXTURE1D_U_DIMENSION</unmanaged>
                public const int MaximumTexture1DSize = 8192;
                
                /// <summary>Constant MaximumTexture2DSize.</summary>
                /// <unmanaged>D3D10_REQ_TEXTURE2D_U_OR_V_DIMENSION</unmanaged>
                public const int MaximumTexture2DSize = 8192;
                
                /// <summary>Constant MaximumTexture3DSize.</summary>
                /// <unmanaged>D3D10_REQ_TEXTURE3D_U_V_OR_W_DIMENSION</unmanaged>
                public const int MaximumTexture3DSize = 2048;
                
                /// <summary>Constant MaximumTextureCubeSize.</summary>
                /// <unmanaged>D3D10_REQ_TEXTURECUBE_DIMENSION</unmanaged>
                public const int MaximumTextureCubeSize = 8192;
                
                /// <summary>	
                /// <p>Get the type of the resource.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Resource::GetType']/*"/>	
                /// <msdn-id>bb173831</msdn-id>	
                /// <unmanaged>GetType</unmanaged>	
                /// <unmanaged-short>GetType</unmanaged-short>	
                /// <unmanaged>void ID3D10Resource::GetType([Out] D3D10_RESOURCE_DIMENSION* rType)</unmanaged>
                public SharpDX.Direct3D10.ResourceDimension TypeInfo {
                        get { SharpDX.Direct3D10.ResourceDimension __output__; GetTypeInfo(out __output__); return __output__; }
                }
                
                /// <summary>	
                /// <p>Get or sets the eviction priority of a resource.</p>	
                /// </summary>	
                /// <remarks>	
                /// <p>This method is a wrapper for <strong>GetEvictionPriority</strong> and is provided in the <strong><see cref="SharpDX.Direct3D10.Resource"/> Interface</strong> interface for convenience.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Resource::GetEvictionPriority']/*"/>	
                /// <msdn-id>bb173830</msdn-id>	
                /// <unmanaged>GetEvictionPriority / SetEvictionPriority</unmanaged>	
                /// <unmanaged-short>GetEvictionPriority</unmanaged-short>	
                /// <unmanaged>unsigned int ID3D10Resource::GetEvictionPriority()</unmanaged>
                public int EvictionPriority {
                        get { return GetEvictionPriority(); }
                        set { SetEvictionPriority(value); }
                }
                
                /// <summary>	
                /// <p>Get the type of the resource.</p>	
                /// </summary>	
                /// <param name="rType"><dd>  <p>Pointer to the resource type (see <strong><see cref="SharpDX.Direct3D10.ResourceDimension"/></strong>).</p> </dd></param>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Resource::GetType']/*"/>	
                /// <msdn-id>bb173831</msdn-id>	
                /// <unmanaged>void ID3D10Resource::GetType([Out] D3D10_RESOURCE_DIMENSION* rType)</unmanaged>	
                /// <unmanaged-short>ID3D10Resource::GetType</unmanaged-short>	
                internal void GetTypeInfo(out SharpDX.Direct3D10.ResourceDimension rType) {
                    unsafe {
                        fixed (void* rType_ = &rType)
                            SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, rType_,((void**)(*(void**)_nativePointer))[7]);		
                    }
                }
                
                /// <summary>	
                /// <p>Set the eviction priority of a resource.</p>	
                /// </summary>	
                /// <param name="evictionPriority"><dd>  <p>Eviction priority for the resource, which is one of the following values:</p> <ul> <li><see cref="SharpDX.DXGI.ResourcePriority.Minimum"/></li> <li><see cref="SharpDX.DXGI.ResourcePriority.Low"/></li> <li><see cref="SharpDX.DXGI.ResourcePriority.Normal"/></li> <li><see cref="SharpDX.DXGI.ResourcePriority.High"/></li> <li><see cref="SharpDX.DXGI.ResourcePriority.Maximum"/></li> </ul> </dd></param>	
                /// <remarks>	
                /// <p>Resource priorities determine which resource to evict from video memory when the system has run out of video memory. The resource will not be lost; it will be removed from video memory and placed into system memory, or possibly placed onto the hard drive. The resource will be loaded back into video memory when it is required.</p><p>A resource that is set to the maximum priority, <see cref="SharpDX.DXGI.ResourcePriority.Maximum"/>, is only evicted if there is no other way of resolving the incoming memory request. The Windows Display Driver Model (WDDM) tries to split an incoming memory request to its minimum size and evict lower-priority resources before evicting a resource with maximum priority.</p><p>Changing the priorities of resources should be done carefully. The wrong eviction priorities could be a detriment to performance rather than an improvement. See <strong>QueryResourceResidency</strong> for additional information.</p><p>This method is a wrapper for <strong>SetEvictionPriority</strong> and is provided in the <strong><see cref="SharpDX.Direct3D10.Resource"/> Interface</strong> interface for convenience.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Resource::SetEvictionPriority']/*"/>	
                /// <msdn-id>bb173832</msdn-id>	
                /// <unmanaged>void ID3D10Resource::SetEvictionPriority([In] unsigned int EvictionPriority)</unmanaged>	
                /// <unmanaged-short>ID3D10Resource::SetEvictionPriority</unmanaged-short>	
                internal void SetEvictionPriority(int evictionPriority) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, evictionPriority,((void**)(*(void**)_nativePointer))[8]);		
                    }
                }
                
                /// <summary>	
                /// <p>Get the eviction priority of a resource.</p>	
                /// </summary>	
                /// <returns><p>One of the following values, which specifies the eviction priority for the resource:</p><ul> <li><see cref="SharpDX.DXGI.ResourcePriority.Minimum"/></li> <li><see cref="SharpDX.DXGI.ResourcePriority.Low"/></li> <li><see cref="SharpDX.DXGI.ResourcePriority.Normal"/></li> <li><see cref="SharpDX.DXGI.ResourcePriority.High"/></li> <li><see cref="SharpDX.DXGI.ResourcePriority.Maximum"/></li> </ul></returns>	
                /// <remarks>	
                /// <p>This method is a wrapper for <strong>GetEvictionPriority</strong> and is provided in the <strong><see cref="SharpDX.Direct3D10.Resource"/> Interface</strong> interface for convenience.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Resource::GetEvictionPriority']/*"/>	
                /// <msdn-id>bb173830</msdn-id>	
                /// <unmanaged>unsigned int ID3D10Resource::GetEvictionPriority()</unmanaged>	
                /// <unmanaged-short>ID3D10Resource::GetEvictionPriority</unmanaged-short>	
                internal int GetEvictionPriority() {
                    unsafe {
                        int __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[9]);		
                        return __result__;
                    }
                }
            }
            /// <summary>	
            /// <p>A view interface specifies the parts of a resource the pipeline can access during rendering (see view).</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>A view interface is the base interface for all views. There are three types of views; a depth-stencil view, a render-target view, and a shader-resource view.</p><ul> <li>To create a render-target view, call <strong><see cref="SharpDX.Direct3D10.Device.CreateRenderTargetView"/></strong>.</li> <li>To create a depth-stencil view, call <strong><see cref="SharpDX.Direct3D10.Device.CreateDepthStencilView"/></strong>.</li> <li>To create a shader-resource view, call <strong><see cref="SharpDX.Direct3D10.Device.CreateShaderResourceView"/></strong>.</li> </ul><p>All resources must be bound to the pipeline before they can be accessed.</p><ul> <li>To bind a render-target view or a depth-stencil view, call <strong><see cref="SharpDX.Direct3D10.OutputMergerStage.SetRenderTargets"/></strong>.</li> <li>To bind a shader-resource view, call <strong><see cref="SharpDX.Direct3D10.VertexShaderStage.SetShaderResources"/></strong>.</li> </ul><p>A view can also be used to access a typeless resource.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10View']/*"/>	
            /// <msdn-id>bb173876</msdn-id>	
            /// <unmanaged>ID3D10View</unmanaged>	
            /// <unmanaged-short>ID3D10View</unmanaged-short>	
            [Guid("C902B03F-60A7-49BA-9936-2A3AB37A7E33")]
            public partial class ResourceView : SharpDX.Direct3D10.DeviceChild {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.ResourceView"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public ResourceView(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.ResourceView"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.ResourceView(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.ResourceView(nativePointer);
        		}
                
                
                /// <summary>	
                /// <p>Get the resource that is accessed through this view.</p>	
                /// </summary>	
                /// <remarks>	
                /// <p>This function increments the reference count of the resource by one, so it is necessary to call Release on the returned reference when the application is done with it. Destroying (or losing) the returned reference before Release is called will result in a memory leak.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10View::GetResource']/*"/>	
                /// <msdn-id>bb173877</msdn-id>	
                /// <unmanaged>GetResource</unmanaged>	
                /// <unmanaged-short>GetResource</unmanaged-short>	
                /// <unmanaged>void ID3D10View::GetResource([Out] ID3D10Resource** ppResource)</unmanaged>
                public SharpDX.Direct3D10.Resource Resource {
                        get { SharpDX.Direct3D10.Resource __output__; GetResource(out __output__); return __output__; }
                }
                
                /// <summary>	
                /// <p>Get the resource that is accessed through this view.</p>	
                /// </summary>	
                /// <param name="resourceOut"><dd>  <p>Address of a reference to the resource that is accessed through this view. (See <strong><see cref="SharpDX.Direct3D10.Resource"/></strong>.)</p> </dd></param>	
                /// <remarks>	
                /// <p>This function increments the reference count of the resource by one, so it is necessary to call Release on the returned reference when the application is done with it. Destroying (or losing) the returned reference before Release is called will result in a memory leak.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10View::GetResource']/*"/>	
                /// <msdn-id>bb173877</msdn-id>	
                /// <unmanaged>void ID3D10View::GetResource([Out] ID3D10Resource** ppResource)</unmanaged>	
                /// <unmanaged-short>ID3D10View::GetResource</unmanaged-short>	
                internal void GetResource(out SharpDX.Direct3D10.Resource resourceOut) {
                    unsafe {
                        IntPtr resourceOut_ = IntPtr.Zero;
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, &resourceOut_,((void**)(*(void**)_nativePointer))[7]);		
                        resourceOut= (resourceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.Resource(resourceOut_);	
                    }
                }
            }
            /// <summary>	
            /// <p>A sampler-state interface accesses sampler state for a texture.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>Create a sampler-state object by calling <strong><see cref="SharpDX.Direct3D10.Device.CreateSamplerState"/></strong>.</p><p>To initialize sampler state, bind the sampler-state object to the pipeline by calling <strong><see cref="SharpDX.Direct3D10.VertexShaderStage.SetSamplers"/></strong>, <strong><see cref="SharpDX.Direct3D10.GeometryShaderStage.SetSamplers"/></strong>, or <strong><see cref="SharpDX.Direct3D10.PixelShaderStage.SetSamplers"/></strong>.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10SamplerState']/*"/>	
            /// <msdn-id>bb173833</msdn-id>	
            /// <unmanaged>ID3D10SamplerState</unmanaged>	
            /// <unmanaged-short>ID3D10SamplerState</unmanaged-short>	
            [Guid("9B7E4C0C-342C-4106-A19F-4F2704F689F0")]
            public partial class SamplerState : SharpDX.Direct3D10.DeviceChild {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.SamplerState"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public SamplerState(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.SamplerState"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.SamplerState(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.SamplerState(nativePointer);
        		}
                
                
                /// <summary>	
                /// <p>Get the sampler state.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10SamplerState::GetDesc']/*"/>	
                /// <msdn-id>bb173834</msdn-id>	
                /// <unmanaged>GetDesc</unmanaged>	
                /// <unmanaged-short>GetDesc</unmanaged-short>	
                /// <unmanaged>void ID3D10SamplerState::GetDesc([Out] D3D10_SAMPLER_DESC* pDesc)</unmanaged>
                public SharpDX.Direct3D10.SamplerStateDescription Description {
                        get { SharpDX.Direct3D10.SamplerStateDescription __output__; GetDescription(out __output__); return __output__; }
                }
                
                /// <summary>	
                /// <p>Get the sampler state.</p>	
                /// </summary>	
                /// <param name="descRef"><dd>  <p>A reference to the sampler state (see <strong><see cref="SharpDX.Direct3D10.SamplerStateDescription"/></strong>).</p> </dd></param>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10SamplerState::GetDesc']/*"/>	
                /// <msdn-id>bb173834</msdn-id>	
                /// <unmanaged>void ID3D10SamplerState::GetDesc([Out] D3D10_SAMPLER_DESC* pDesc)</unmanaged>	
                /// <unmanaged-short>ID3D10SamplerState::GetDesc</unmanaged-short>	
                internal void GetDescription(out SharpDX.Direct3D10.SamplerStateDescription descRef) {
                    unsafe {
                        descRef = new SharpDX.Direct3D10.SamplerStateDescription();
                        fixed (void* descRef_ = &descRef)
                            SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, descRef_,((void**)(*(void**)_nativePointer))[7]);		
                    }
                }
            }
            /// <summary>	
            /// <p>A shader-resource-view interface specifies the subresources a shader can access during rendering. Examples of shader resources include a constant buffer, a texture buffer, a texture or a sampler.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>To create a shader-resource view, call <strong><see cref="SharpDX.Direct3D10.Device.CreateShaderResourceView"/></strong>.</p><p>A shader-resource view is required when binding a resource to a shader stage; the binding occurs by calling <strong><see cref="SharpDX.Direct3D10.GeometryShaderStage.SetShaderResources"/></strong>, <strong><see cref="SharpDX.Direct3D10.VertexShaderStage.SetShaderResources"/></strong> or <strong><see cref="SharpDX.Direct3D10.PixelShaderStage.SetShaderResources"/></strong>.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10ShaderResourceView']/*"/>	
            /// <msdn-id>bb173854</msdn-id>	
            /// <unmanaged>ID3D10ShaderResourceView</unmanaged>	
            /// <unmanaged-short>ID3D10ShaderResourceView</unmanaged-short>	
            [Guid("9B7E4C07-342C-4106-A19F-4F2704F689F0")]
            public partial class ShaderResourceView : SharpDX.Direct3D10.ResourceView {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.ShaderResourceView"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public ShaderResourceView(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.ShaderResourceView"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.ShaderResourceView(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.ShaderResourceView(nativePointer);
        		}
                
                
                /// <summary>	
                /// <p>Get the shader resource view's description.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10ShaderResourceView::GetDesc']/*"/>	
                /// <msdn-id>bb173855</msdn-id>	
                /// <unmanaged>GetDesc</unmanaged>	
                /// <unmanaged-short>GetDesc</unmanaged-short>	
                /// <unmanaged>void ID3D10ShaderResourceView::GetDesc([Out] D3D10_SHADER_RESOURCE_VIEW_DESC* pDesc)</unmanaged>
                public SharpDX.Direct3D10.ShaderResourceViewDescription Description {
                        get { SharpDX.Direct3D10.ShaderResourceViewDescription __output__; GetDescription(out __output__); return __output__; }
                }
                
                /// <summary>	
                /// <p>Get the shader resource view's description.</p>	
                /// </summary>	
                /// <param name="descRef"><dd>  <p>A reference to a <strong><see cref="SharpDX.Direct3D10.ShaderResourceViewDescription"/></strong> structure to be filled with data about the shader resource view.</p> </dd></param>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10ShaderResourceView::GetDesc']/*"/>	
                /// <msdn-id>bb173855</msdn-id>	
                /// <unmanaged>void ID3D10ShaderResourceView::GetDesc([Out] D3D10_SHADER_RESOURCE_VIEW_DESC* pDesc)</unmanaged>	
                /// <unmanaged-short>ID3D10ShaderResourceView::GetDesc</unmanaged-short>	
                internal void GetDescription(out SharpDX.Direct3D10.ShaderResourceViewDescription descRef) {
                    unsafe {
                        descRef = new SharpDX.Direct3D10.ShaderResourceViewDescription();
                        fixed (void* descRef_ = &descRef)
                            SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, descRef_,((void**)(*(void**)_nativePointer))[8]);		
                    }
                }
            }
            /// <summary>	
            /// <p>A shader-resource-view interface specifies the subresources a shader can access during rendering. Examples of shader resources include a constant buffer, a texture buffer, a texture or a sampler.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>To create a shader-resource view, call <strong><see cref="SharpDX.Direct3D10.Device1.CreateShaderResourceView1"/></strong>.</p><p>A shader-resource view is required when binding a resource to a shader stage; the binding occurs by calling <strong><see cref="SharpDX.Direct3D10.GeometryShaderStage.SetShaderResources"/></strong>, <strong><see cref="SharpDX.Direct3D10.VertexShaderStage.SetShaderResources"/></strong> or <strong><see cref="SharpDX.Direct3D10.PixelShaderStage.SetShaderResources"/></strong>.</p><p>This method requires Windows Vista Service Pack 1.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10ShaderResourceView1']/*"/>	
            /// <msdn-id>bb694557</msdn-id>	
            /// <unmanaged>ID3D10ShaderResourceView1</unmanaged>	
            /// <unmanaged-short>ID3D10ShaderResourceView1</unmanaged-short>	
            [Guid("9B7E4C87-342C-4106-A19F-4F2704F689F0")]
            public partial class ShaderResourceView1 : SharpDX.Direct3D10.ShaderResourceView {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.ShaderResourceView1"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public ShaderResourceView1(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.ShaderResourceView1"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.ShaderResourceView1(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.ShaderResourceView1(nativePointer);
        		}
                
                
                /// <summary>	
                /// <p>Get the shader resource view's description.</p>	
                /// </summary>	
                /// <remarks>	
                /// <p>This method requires Windows Vista Service Pack 1.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10ShaderResourceView1::GetDesc1']/*"/>	
                /// <msdn-id>bb694558</msdn-id>	
                /// <unmanaged>GetDesc1</unmanaged>	
                /// <unmanaged-short>GetDesc1</unmanaged-short>	
                /// <unmanaged>void ID3D10ShaderResourceView1::GetDesc1([Out] D3D10_SHADER_RESOURCE_VIEW_DESC1* pDesc)</unmanaged>
                public SharpDX.Direct3D10.ShaderResourceViewDescription1 Description1 {
                        get { SharpDX.Direct3D10.ShaderResourceViewDescription1 __output__; GetDescription1(out __output__); return __output__; }
                }
                
                /// <summary>	
                /// <p>Get the shader resource view's description.</p>	
                /// </summary>	
                /// <param name="descRef"><dd>  <p>A reference to a <strong><see cref="SharpDX.Direct3D10.ShaderResourceViewDescription1"/></strong> structure to be filled with data about the shader resource view.</p> </dd></param>	
                /// <remarks>	
                /// <p>This method requires Windows Vista Service Pack 1.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10ShaderResourceView1::GetDesc1']/*"/>	
                /// <msdn-id>bb694558</msdn-id>	
                /// <unmanaged>void ID3D10ShaderResourceView1::GetDesc1([Out] D3D10_SHADER_RESOURCE_VIEW_DESC1* pDesc)</unmanaged>	
                /// <unmanaged-short>ID3D10ShaderResourceView1::GetDesc1</unmanaged-short>	
                internal void GetDescription1(out SharpDX.Direct3D10.ShaderResourceViewDescription1 descRef) {
                    unsafe {
                        descRef = new SharpDX.Direct3D10.ShaderResourceViewDescription1();
                        fixed (void* descRef_ = &descRef)
                            SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, descRef_,((void**)(*(void**)_nativePointer))[9]);		
                    }
                }
            }
            /// <summary>	
            /// <p><see cref="SharpDX.Direct3D10.SkinInfo"/> allows you to optimize, process, and manually set the relationship between bones and vertices in your meshes (see Skeletal Animation on Wikipedia). It is most useful for making .x files exported by DCC Apps (such as 3DS Max and Maya) more hardware-friendly, and for improving the render speed of your skinned meshes in software render mode.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>Create a <see cref="SharpDX.Direct3D10.SkinInfo"/> interface with <strong><see cref="SharpDX.Direct3D10.D3DX10.CreateSkinInfo"/></strong>, <strong>D3DX10CreateSkinInfoFromBlendedMesh</strong>, or <strong>D3DX10CreateSkinInfoFVF</strong>.</p><p>The LPD3DX10SKININFO type is defined as a reference to the <strong><see cref="SharpDX.Direct3D10.SkinInfo"/></strong> interface. </p><pre> typedef struct <see cref="SharpDX.Direct3D10.SkinInfo"/> *LPD3DX10SKININFO;	
            /// </pre>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10SkinInfo']/*"/>	
            /// <msdn-id>bb173932</msdn-id>	
            /// <unmanaged>ID3DX10SkinInfo</unmanaged>	
            /// <unmanaged-short>ID3DX10SkinInfo</unmanaged-short>	
            [Guid("420bd604-1c76-4a34-a466-e45d0658a32c")]
            public partial class SkinInfo : SharpDX.ComObject {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.SkinInfo"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public SkinInfo(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.SkinInfo"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.SkinInfo(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.SkinInfo(nativePointer);
        		}
                
                
                /// <summary>	
                /// <p>Get the number of vertices in <see cref="SharpDX.Direct3D10.SkinInfo"/>.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10SkinInfo::GetNumVertices']/*"/>	
                /// <msdn-id>bb173945</msdn-id>	
                /// <unmanaged>GetNumVertices</unmanaged>	
                /// <unmanaged-short>GetNumVertices</unmanaged-short>	
                /// <unmanaged>unsigned int ID3DX10SkinInfo::GetNumVertices()</unmanaged>
                public int NumVertices {
                        get { return GetNumVertices(); }
                }
                
                /// <summary>	
                /// <p>Get the number of bones in <see cref="SharpDX.Direct3D10.SkinInfo"/>.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10SkinInfo::GetNumBones']/*"/>	
                /// <msdn-id>bb173944</msdn-id>	
                /// <unmanaged>GetNumBones</unmanaged>	
                /// <unmanaged-short>GetNumBones</unmanaged-short>	
                /// <unmanaged>unsigned int ID3DX10SkinInfo::GetNumBones()</unmanaged>
                public int NumBones {
                        get { return GetNumBones(); }
                }
                
                /// <summary>	
                /// <p>Get the number of vertices a bone can maximally influence.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10SkinInfo::GetMaxBoneInfluences']/*"/>	
                /// <msdn-id>bb173943</msdn-id>	
                /// <unmanaged>GetMaxBoneInfluences</unmanaged>	
                /// <unmanaged-short>GetMaxBoneInfluences</unmanaged-short>	
                /// <unmanaged>unsigned int ID3DX10SkinInfo::GetMaxBoneInfluences()</unmanaged>
                public int MaxBoneInfluences {
                        get { return GetMaxBoneInfluences(); }
                }
                
                /// <summary>	
                /// <p>Get the number of vertices in <see cref="SharpDX.Direct3D10.SkinInfo"/>.</p>	
                /// </summary>	
                /// <returns><p>The number of vertices in <see cref="SharpDX.Direct3D10.SkinInfo"/>.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10SkinInfo::GetNumVertices']/*"/>	
                /// <msdn-id>bb173945</msdn-id>	
                /// <unmanaged>unsigned int ID3DX10SkinInfo::GetNumVertices()</unmanaged>	
                /// <unmanaged-short>ID3DX10SkinInfo::GetNumVertices</unmanaged-short>	
                internal int GetNumVertices() {
                    unsafe {
                        int __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[3]);		
                        return __result__;
                    }
                }
                
                /// <summary>	
                /// <p>Get the number of bones in <see cref="SharpDX.Direct3D10.SkinInfo"/>.</p>	
                /// </summary>	
                /// <returns><p>The number of bones in <see cref="SharpDX.Direct3D10.SkinInfo"/>.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10SkinInfo::GetNumBones']/*"/>	
                /// <msdn-id>bb173944</msdn-id>	
                /// <unmanaged>unsigned int ID3DX10SkinInfo::GetNumBones()</unmanaged>	
                /// <unmanaged-short>ID3DX10SkinInfo::GetNumBones</unmanaged-short>	
                internal int GetNumBones() {
                    unsafe {
                        int __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                        return __result__;
                    }
                }
                
                /// <summary>	
                /// <p>Get the number of vertices a bone can maximally influence.</p>	
                /// </summary>	
                /// <returns><p>The number of vertices a bone can maximally influence.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10SkinInfo::GetMaxBoneInfluences']/*"/>	
                /// <msdn-id>bb173943</msdn-id>	
                /// <unmanaged>unsigned int ID3DX10SkinInfo::GetMaxBoneInfluences()</unmanaged>	
                /// <unmanaged-short>ID3DX10SkinInfo::GetMaxBoneInfluences</unmanaged-short>	
                internal int GetMaxBoneInfluences() {
                    unsafe {
                        int __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[5]);		
                        return __result__;
                    }
                }
                
                /// <summary>	
                /// <p>Allocate space for additional vertices.</p>	
                /// </summary>	
                /// <param name="count"><dd>  <p>The number of vertices to add.</p> </dd></param>	
                /// <returns><p>If this method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be: E_OUTOFMEMORY.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10SkinInfo::AddVertices']/*"/>	
                /// <msdn-id>bb173935</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10SkinInfo::AddVertices([In] unsigned int Count)</unmanaged>	
                /// <unmanaged-short>ID3DX10SkinInfo::AddVertices</unmanaged-short>	
                public void AddVertices(int count) {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, count,((void**)(*(void**)_nativePointer))[6]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Change which vertices are influenced by which bones.</p>	
                /// </summary>	
                /// <param name="newVertexCount"><dd>  <p>The new number of vertices.</p> </dd></param>	
                /// <param name="vertexRemapRef"><dd>  <p>A reference to an array of vertex indices, which describe the remapping. For example, say SkinInfo contains some vertices such that bone0 is mapped to v0, bone1 to v1, and bone2 to v2, and array with 2,1,0 is specified for pBoneRemap. This will cause bone0 to be mapped to v2, bone1 to v1, and bone2 to v0.</p> </dd></param>	
                /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be: E_OUTOFMEMORY or E_INVALIDARG.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10SkinInfo::RemapVertices']/*"/>	
                /// <msdn-id>bb173947</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10SkinInfo::RemapVertices([In] unsigned int NewVertexCount,[In, Buffer] unsigned int* pVertexRemap)</unmanaged>	
                /// <unmanaged-short>ID3DX10SkinInfo::RemapVertices</unmanaged-short>	
                public void RemapVertices(int newVertexCount, int[] vertexRemapRef) {
                    unsafe {
                        SharpDX.Result __result__;
                        fixed (void* vertexRemapRef_ = vertexRemapRef)
                            __result__= 
            				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, newVertexCount, vertexRemapRef_,((void**)(*(void**)_nativePointer))[7]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Allocate space for more bones.</p>	
                /// </summary>	
                /// <param name="count"><dd>  <p>The number of bones to add.</p> </dd></param>	
                /// <returns><p>If this method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be: E_OUTOFMEMORY.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10SkinInfo::AddBones']/*"/>	
                /// <msdn-id>bb173934</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10SkinInfo::AddBones([In] unsigned int Count)</unmanaged>	
                /// <unmanaged-short>ID3DX10SkinInfo::AddBones</unmanaged-short>	
                public void AddBones(int count) {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, count,((void**)(*(void**)_nativePointer))[8]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Remove a bone.</p>	
                /// </summary>	
                /// <param name="index"><dd>  <p>An index that specifies which bone to remove. Must be between 0 and the value returned by <strong><see cref="SharpDX.Direct3D10.SkinInfo.GetNumBones"/></strong>.</p> </dd></param>	
                /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be: E_INVALIDARG.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10SkinInfo::RemoveBone']/*"/>	
                /// <msdn-id>bb173948</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10SkinInfo::RemoveBone([In] unsigned int Index)</unmanaged>	
                /// <unmanaged-short>ID3DX10SkinInfo::RemoveBone</unmanaged-short>	
                public void RemoveBone(int index) {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, index,((void**)(*(void**)_nativePointer))[9]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Change which bones influence which vertices.</p>	
                /// </summary>	
                /// <param name="newBoneCount"><dd>  <p>The new number of bones.</p> </dd></param>	
                /// <param name="boneRemapRef"><dd>  <p>A reference to an array of bone indices, which describe the remapping. For example, say SkinInfo contains some bones such that bone0 is mapped to v0, bone1 to v1, and bone2 to v2, and array with 2,1,0 is specified for pBoneRemap. This will cause bone0 to be mapped to v2, bone1 to v1, and bone2 to v0.</p> </dd></param>	
                /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be: E_OUTOFMEMORY or E_INVALIDARG.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10SkinInfo::RemapBones']/*"/>	
                /// <msdn-id>bb173946</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10SkinInfo::RemapBones([In] unsigned int NewBoneCount,[In, Buffer] unsigned int* pBoneRemap)</unmanaged>	
                /// <unmanaged-short>ID3DX10SkinInfo::RemapBones</unmanaged-short>	
                public void RemapBones(int newBoneCount, int[] boneRemapRef) {
                    unsafe {
                        SharpDX.Result __result__;
                        fixed (void* boneRemapRef_ = boneRemapRef)
                            __result__= 
            				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, newBoneCount, boneRemapRef_,((void**)(*(void**)_nativePointer))[10]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Enable an existing bone to influence a group of vertices and define how much influence the bone has on each vertex.</p>	
                /// </summary>	
                /// <param name="boneIndex"><dd>  <p>An index that specifies an existing bone. Must be between 0 and the value returned by <strong><see cref="SharpDX.Direct3D10.SkinInfo.GetNumBones"/></strong>.</p> </dd></param>	
                /// <param name="influenceCount"><dd>  <p>Number of vertices to add to the bone's influence.</p> </dd></param>	
                /// <param name="indicesRef"><dd>  <p>Pointer to an array of vertex indices.  Each member of this array has a corresponding member in pWeights, such that pIndices[i] corresponds to pWeights[i].  The corresponding value in pWeights[i] determines how much influence BoneIndex will have on the vertex indexed by pIndices[i]. The size of the pIndices array must be equal to or greater than InfluenceCount.</p> </dd></param>	
                /// <param name="weightsRef"><dd>  <p>Pointer to an array of bone weights.  Each member of this array has a corresponding member in pIndices, such that pWeights[i] corresponds to pIndices[i]. Each value in pWeights is between 0 and 1 and defines the amount of influence the bone has over each vertex. The size of pWeights must be equal to or greater than InfluenceCount.</p> </dd></param>	
                /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be: E_INVALIDARG or E_OUTOFMEMORY.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10SkinInfo::AddBoneInfluences']/*"/>	
                /// <msdn-id>bb173933</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10SkinInfo::AddBoneInfluences([In] unsigned int BoneIndex,[In] unsigned int InfluenceCount,[In, Buffer] unsigned int* pIndices,[In, Buffer] float* pWeights)</unmanaged>	
                /// <unmanaged-short>ID3DX10SkinInfo::AddBoneInfluences</unmanaged-short>	
                public void AddBoneInfluences(int boneIndex, int influenceCount, int[] indicesRef, float[] weightsRef) {
                    unsafe {
                        SharpDX.Result __result__;
                        fixed (void* indicesRef_ = indicesRef)
                            fixed (void* weightsRef_ = weightsRef)
                                __result__= 
                				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, boneIndex, influenceCount, indicesRef_, weightsRef_,((void**)(*(void**)_nativePointer))[11]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Clear a bone's list of vertices that it influences.</p>	
                /// </summary>	
                /// <param name="boneIndex"><dd>  <p>An index that specifies an existing bone. Must be between 0 and the value returned by <strong><see cref="SharpDX.Direct3D10.SkinInfo.GetNumBones"/></strong>.</p> </dd></param>	
                /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be: E_INVALIDARG.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10SkinInfo::ClearBoneInfluences']/*"/>	
                /// <msdn-id>bb173936</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10SkinInfo::ClearBoneInfluences([In] unsigned int BoneIndex)</unmanaged>	
                /// <unmanaged-short>ID3DX10SkinInfo::ClearBoneInfluences</unmanaged-short>	
                public void ClearBoneInfluences(int boneIndex) {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, boneIndex,((void**)(*(void**)_nativePointer))[12]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Get the number of vertices that a given bone influences.</p>	
                /// </summary>	
                /// <param name="boneIndex"><dd>  <p>An index that specifies an existing bone. Must be between 0 and the value returned by <strong><see cref="SharpDX.Direct3D10.SkinInfo.GetNumBones"/></strong>.</p> </dd></param>	
                /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be: E_INVALIDARG.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10SkinInfo::GetBoneInfluenceCount']/*"/>	
                /// <msdn-id>bb173941</msdn-id>	
                /// <unmanaged>unsigned int ID3DX10SkinInfo::GetBoneInfluenceCount([In] unsigned int BoneIndex)</unmanaged>	
                /// <unmanaged-short>ID3DX10SkinInfo::GetBoneInfluenceCount</unmanaged-short>	
                public int GetBoneInfluenceCount(int boneIndex) {
                    unsafe {
                        int __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, boneIndex,((void**)(*(void**)_nativePointer))[13]);		
                        return __result__;
                    }
                }
                
                /// <summary>	
                /// <p>Get a list of vertices that a given bone influences and a list of the amount of influence that bone has on each vertex.</p>	
                /// </summary>	
                /// <param name="boneIndex"><dd>  <p>An index that specifies an existing bone. Must be between 0 and the value returned by <strong><see cref="SharpDX.Direct3D10.SkinInfo.GetNumBones"/></strong>.</p> </dd></param>	
                /// <param name="offset"><dd>  <p>An offset from the top of the bone's list of influenced vertices. This must be between 0 and the value returned by <strong><see cref="SharpDX.Direct3D10.SkinInfo.GetBoneInfluenceCount"/></strong>.</p> </dd></param>	
                /// <param name="count"><dd>  <p>The number of indices and weights to retrieve.  Must be between 0 and the value returned by <see cref="SharpDX.Direct3D10.SkinInfo.GetBoneInfluenceCount"/>.</p> </dd></param>	
                /// <param name="destIndicesRef"><dd>  <p>A list of indices into the vertex buffer, each one representing a vertex influenced by the bone. These values correspond to the values in pDestWeights, such that pDestIndices[i] corresponds to pDestWeights[i].</p> </dd></param>	
                /// <param name="destWeightsRef"><dd>  <p>A list of the amount of influence the bone has on each vertex. These values correspond to the values in pDestIndices, such that pDestWeights[i] corresponds to pDestIndices[i].f</p> </dd></param>	
                /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be: E_INVALIDARG or E_OUTOFMEMORY.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10SkinInfo::GetBoneInfluences']/*"/>	
                /// <msdn-id>bb173942</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10SkinInfo::GetBoneInfluences([In] unsigned int BoneIndex,[In] unsigned int Offset,[In] unsigned int Count,[Out, Buffer] unsigned int* pDestIndices,[Out, Buffer] float* pDestWeights)</unmanaged>	
                /// <unmanaged-short>ID3DX10SkinInfo::GetBoneInfluences</unmanaged-short>	
                internal void GetBoneInfluences(int boneIndex, int offset, int count, int[] destIndicesRef, float[] destWeightsRef) {
                    unsafe {
                        SharpDX.Result __result__;
                        fixed (void* destIndicesRef_ = destIndicesRef)
                            fixed (void* destWeightsRef_ = destWeightsRef)
                                __result__= 
                				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, boneIndex, offset, count, destIndicesRef_, destWeightsRef_,((void**)(*(void**)_nativePointer))[14]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Find the index that indicates where a given vertex is in a given bone's list of influenced vertices.</p>	
                /// </summary>	
                /// <param name="boneIndex"><dd>  <p>An index that specifies an existing bone. Must be between 0 and the value returned by <strong><see cref="SharpDX.Direct3D10.SkinInfo.GetNumBones"/></strong>.</p> </dd></param>	
                /// <param name="vertexIndex"><dd>  <p>The index of the vertex in the vertex buffer.</p> </dd></param>	
                /// <param name="influenceIndexRef"><dd>  <p>The index of the vertex in the bone's list of influenced vertices.</p> </dd></param>	
                /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be: E_INVALIDARG.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10SkinInfo::FindBoneInfluenceIndex']/*"/>	
                /// <msdn-id>bb173939</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10SkinInfo::FindBoneInfluenceIndex([In] unsigned int BoneIndex,[In] unsigned int VertexIndex,[In] unsigned int* pInfluenceIndex)</unmanaged>	
                /// <unmanaged-short>ID3DX10SkinInfo::FindBoneInfluenceIndex</unmanaged-short>	
                public void FindBoneInfluenceIndex(int boneIndex, int vertexIndex, int influenceIndexRef) {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, boneIndex, vertexIndex, &influenceIndexRef,((void**)(*(void**)_nativePointer))[15]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Set the amount of influence a given bone has over a given vertex.</p>	
                /// </summary>	
                /// <param name="boneIndex"><dd>  <p>An index that specifies an existing bone. Must be between 0 and the value returned by <strong><see cref="SharpDX.Direct3D10.SkinInfo.GetNumBones"/></strong>.</p> </dd></param>	
                /// <param name="influenceIndex"><dd>  <p>An index into the bone's list of vertices that it influences.</p> </dd></param>	
                /// <param name="weight"><dd>  <p>The amount of influence, between 0 and 1, that the bone has over the vertex.</p> </dd></param>	
                /// <returns><p>If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be E_INVALIDARG.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10SkinInfo::SetBoneInfluence']/*"/>	
                /// <msdn-id>bb173949</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10SkinInfo::SetBoneInfluence([In] unsigned int BoneIndex,[In] unsigned int InfluenceIndex,[In] float Weight)</unmanaged>	
                /// <unmanaged-short>ID3DX10SkinInfo::SetBoneInfluence</unmanaged-short>	
                public void SetBoneInfluence(int boneIndex, int influenceIndex, float weight) {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, boneIndex, influenceIndex, weight,((void**)(*(void**)_nativePointer))[16]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Get the amount of influence a given bone has over a given vertex.</p>	
                /// </summary>	
                /// <param name="boneIndex"><dd>  <p>An index that specifies an existing bone. Must be between 0 and the value returned by <strong><see cref="SharpDX.Direct3D10.SkinInfo.GetNumBones"/></strong>.</p> </dd></param>	
                /// <param name="influenceIndex"><dd>  <p>An index into the bone's list of vertices that it influences.</p> </dd></param>	
                /// <param name="weightRef"><dd>  <p>The amount of influence, between 0 and 1, that the bone has over the vertex.</p> </dd></param>	
                /// <returns><p>If the method succeeds, the return value is D3D_OK. If the method fails, the return value can be E_INVALIDARG.</p></returns>	
                /// <remarks>	
                /// <p>Use <see cref="SharpDX.Direct3D10.SkinInfo.GetBoneInfluenceCount"/> to find out how many vertices the bone influences.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10SkinInfo::GetBoneInfluence']/*"/>	
                /// <msdn-id>bb173940</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10SkinInfo::GetBoneInfluence([In] unsigned int BoneIndex,[In] unsigned int InfluenceIndex,[In] float* pWeight)</unmanaged>	
                /// <unmanaged-short>ID3DX10SkinInfo::GetBoneInfluence</unmanaged-short>	
                public void GetBoneInfluence(int boneIndex, int influenceIndex, float weightRef) {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, boneIndex, influenceIndex, &weightRef,((void**)(*(void**)_nativePointer))[17]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Limit the number of bones that can influence a vertex and/or limit the amount of influence a bone can have on a vertex.</p>	
                /// </summary>	
                /// <param name="maxPerVertexInfluences"><dd>  <p>The maximum number of bones that can influence any given vertex. This value is ignored if it is greater than the value returned by <strong><see cref="SharpDX.Direct3D10.SkinInfo.GetMaxBoneInfluences"/></strong>.</p> </dd></param>	
                /// <param name="scaleMode"><dd>  <p>A flag describing how to scale the remaining weights on a given vertex after some have been chopped off by MinWeight. If D3DX10_SKININFO_NO_SCALING is specified, the weights will not be scaled at all. If D3DX10_SKININFO_SCALE_TO_1 is specified, the weights greater than MinWeight will be scaled up so that they add up to 1.0. If D3DX10_SKININFO_SCALE_TO_TOTAL is specified, the weights greater than MinWeight will be scaled up so that they add up to the original total.</p> </dd></param>	
                /// <param name="minWeight"><dd>  <p>The minimum percentage of influence, or weight, that any bone can have on any vertex. This value must be between 0 and 1.</p> </dd></param>	
                /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be: E_OUTOFMEMORY or E_INVALIDARG.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10SkinInfo::Compact']/*"/>	
                /// <msdn-id>bb173937</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10SkinInfo::Compact([In] unsigned int MaxPerVertexInfluences,[In] unsigned int ScaleMode,[In] float MinWeight)</unmanaged>	
                /// <unmanaged-short>ID3DX10SkinInfo::Compact</unmanaged-short>	
                public void Compact(int maxPerVertexInfluences, int scaleMode, float minWeight) {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, maxPerVertexInfluences, scaleMode, minWeight,((void**)(*(void**)_nativePointer))[18]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Do software skinning on an array of vertices.</p>	
                /// </summary>	
                /// <param name="startVertex"><dd>  <p>A 0-based index into pSrcVertices.</p> </dd></param>	
                /// <param name="vertexCount"><dd>  <p>Number of vertices to transform.</p> </dd></param>	
                /// <param name="srcVerticesRef"><dd>  <p>Pointer to an array of vertices to transform.</p> </dd></param>	
                /// <param name="srcStride"><dd>  <p>The size, in bytes, of a vertex in pSrcVertices.</p> </dd></param>	
                /// <param name="destVerticesRef"><dd>  <p>Pointer to an array of vertices, which will be filled with the transformed vertices.</p> </dd></param>	
                /// <param name="destStride"><dd>  <p>The size, in bytes, of a vertex in pDestVertices.</p> </dd></param>	
                /// <param name="boneMatricesRef"><dd>  <p>An array of matrices that will be used to transform the points mapped to each bone, such that the vertices mapped to bone[i] will be transformed by pBoneMatrices[i].  This array will be used to transform the matrices only if the IsNormal value in pChannelDescs is set to <strong><see cref="SharpDX.Result.False"/></strong>, otherwise pInverseTransposeBoneMatrices will be used.</p> </dd></param>	
                /// <param name="inverseTransposeBoneMatricesRef"><dd>  <p>If this value is <strong><c>null</c></strong>, it will be set equal to pBoneMatrices.  This array of matrices will be used to transform the vertices only if the IsNormal value in pChannelDescs is set to <strong>TRUE</strong>, otherwise pBoneMatrices will be used.</p> </dd></param>	
                /// <param name="channelDescsRef"><dd>  <p>Pointer to a <see cref="SharpDX.Direct3D10.SkinningChannel"/> structure, which determines the member of the vertex decl the software skinning will be done on.</p> </dd></param>	
                /// <param name="numChannels"><dd>  <p>The number of <see cref="SharpDX.Direct3D10.SkinningChannel"/> structures in pChannelDescs.</p> </dd></param>	
                /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be: E_INVALIDARG.</p></returns>	
                /// <remarks>	
                /// <p>Here is an example of how to use software skinning:</p><pre> //vertex definition	
                /// struct MyVertex	
                /// { <see cref="SharpDX.Mathematics.Interop.RawVector3"/> Position; <see cref="SharpDX.Mathematics.Interop.RawVector2"/> Weight; <see cref="SharpDX.Mathematics.Interop.RawVector2"/> TexCoord;	
                /// }; //create vertex data	
                /// const UINT numVertices = 16;	
                /// MyVertex vertices[numVertices] = {...};	
                /// MyVertex destVertices[numVertices]; //create bone matrices	
                /// <see cref="SharpDX.Mathematics.Interop.RawMatrix"/> boneMatrices[2];	
                /// D3DXMatrixIdentity(&amp;boneMatrices[0]);	
                /// D3DXMatrixRotationX(&amp;boneMatrices[1], 3.14159f / 180.0f); //create bone indices and weights	
                /// UINT boneIndices[numVertices] = {...};	
                /// float boneWeights[2][numVertices] = {...}; //create skin info, populate it with bones and vertices, and then map them to each other	
                /// <see cref="SharpDX.Direct3D10.SkinInfo"/> *pSkinInfo = <c>null</c>;	
                /// <see cref="SharpDX.Direct3D10.D3DX10.CreateSkinInfo"/>(&amp;pSkinInfo);	
                /// pSkinInfo-&gt;AddBones(2);	
                /// pSkinInfo-&gt;AddVertices(numVertices);	
                /// pSkinInfo-&gt;AddBoneInfluences(0, numVertices, boneIndices, boneWeights[0]);	
                /// pSkinInfo-&gt;AddBoneInfluences(1, numVertices, boneIndices, boneWeights[1]); //create channel desc	
                /// <see cref="SharpDX.Direct3D10.SkinningChannel"/> channelDesc;	
                /// channelDesc.SrcOffset = 0;	
                /// channelDesc.DestOffset = 0;	
                /// channelDesc.IsNormal = <see cref="SharpDX.Result.False"/>; //do the skinning	
                /// pSkinInfo-&gt;DoSoftwareSkinning(0, numVertices, vertices, sizeof(MyVertex),  destVertices, sizeof(MyVertex),  boneMatrices, <c>null</c>,  &amp;channelDesc, 1);	
                /// </pre>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10SkinInfo::DoSoftwareSkinning']/*"/>	
                /// <msdn-id>bb173938</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10SkinInfo::DoSoftwareSkinning([In] unsigned int StartVertex,[In] unsigned int VertexCount,[In] void* pSrcVertices,[In] unsigned int SrcStride,[In] void* pDestVertices,[In] unsigned int DestStride,[In] D3DXMATRIX* pBoneMatrices,[In, Optional] D3DXMATRIX* pInverseTransposeBoneMatrices,[In] D3DX10_SKINNING_CHANNEL* pChannelDescs,[In] unsigned int NumChannels)</unmanaged>	
                /// <unmanaged-short>ID3DX10SkinInfo::DoSoftwareSkinning</unmanaged-short>	
                public void DoSoftwareSkinning(int startVertex, int vertexCount, System.IntPtr srcVerticesRef, int srcStride, System.IntPtr destVerticesRef, int destStride, ref SharpDX.Mathematics.Interop.RawMatrix boneMatricesRef, SharpDX.Mathematics.Interop.RawMatrix? inverseTransposeBoneMatricesRef, SharpDX.Direct3D10.SkinningChannel channelDescsRef, int numChannels) {
                    unsafe {
                        SharpDX.Mathematics.Interop.RawMatrix inverseTransposeBoneMatricesRef_;
                        if (inverseTransposeBoneMatricesRef.HasValue)
                            inverseTransposeBoneMatricesRef_ = inverseTransposeBoneMatricesRef.Value;				
                        SharpDX.Result __result__;
                        fixed (void* boneMatricesRef_ = &boneMatricesRef)
                            __result__= 
            				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, startVertex, vertexCount, (void*)srcVerticesRef, srcStride, (void*)destVerticesRef, destStride, boneMatricesRef_, (inverseTransposeBoneMatricesRef.HasValue)?&inverseTransposeBoneMatricesRef_:(void*)IntPtr.Zero, &channelDescsRef, numChannels,((void**)(*(void**)_nativePointer))[19]);		
                        __result__.CheckError();
                    }
                }
            }
            /// <summary>	
            /// <p>The <see cref="SharpDX.Direct3D10.Sprite"/> interface provides a set of methods that simplify the process of drawing sprites using Microsoft Direct3D. This interface can operate on a set of many sprites.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>The <see cref="SharpDX.Direct3D10.Sprite"/> interface is obtained by calling the <strong><see cref="SharpDX.Direct3D10.D3DX10.CreateSprite"/></strong> function.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Sprite']/*"/>	
            /// <msdn-id>bb205601</msdn-id>	
            /// <unmanaged>ID3DX10Sprite</unmanaged>	
            /// <unmanaged-short>ID3DX10Sprite</unmanaged-short>	
            [Guid("ba0b762d-8d28-43ec-b9dc-2f84443b0614")]
            public partial class Sprite : SharpDX.ComObject {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.Sprite"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public Sprite(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.Sprite"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.Sprite(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.Sprite(nativePointer);
        		}
                
                
                /// <summary>	
                /// <p>Get or sets the view transform that applies to all sprites.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Sprite::GetViewTransform']/*"/>	
                /// <msdn-id>bb205609</msdn-id>	
                /// <unmanaged>GetViewTransform / SetViewTransform</unmanaged>	
                /// <unmanaged-short>GetViewTransform</unmanaged-short>	
                /// <unmanaged>HRESULT ID3DX10Sprite::GetViewTransform([Out] D3DXMATRIX* pViewTransform)</unmanaged>
                public SharpDX.Mathematics.Interop.RawMatrix ViewTransform {
                        get { SharpDX.Mathematics.Interop.RawMatrix __output__; GetViewTransform(out __output__); return __output__; }
                        set { SetViewTransform(ref value); }
                }
                
                /// <summary>	
                /// <p>Get or sets the sprite projection matrix that is applied to all sprites.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Sprite::GetProjectionTransform']/*"/>	
                /// <msdn-id>bb205608</msdn-id>	
                /// <unmanaged>GetProjectionTransform / SetProjectionTransform</unmanaged>	
                /// <unmanaged-short>GetProjectionTransform</unmanaged-short>	
                /// <unmanaged>HRESULT ID3DX10Sprite::GetProjectionTransform([Out] D3DXMATRIX* pProjectionTransform)</unmanaged>
                public SharpDX.Mathematics.Interop.RawMatrix ProjectionTransform {
                        get { SharpDX.Mathematics.Interop.RawMatrix __output__; GetProjectionTransform(out __output__); return __output__; }
                        set { SetProjectionTransform(ref value); }
                }
                
                /// <summary>	
                /// <p>Retrieve the device associated with the sprite object.</p>	
                /// </summary>	
                /// <remarks>	
                /// <p>Calling this method will increase the internal reference count on the <see cref="SharpDX.Direct3D10.Device"/> interface.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Sprite::GetDevice']/*"/>	
                /// <msdn-id>bb205607</msdn-id>	
                /// <unmanaged>GetDevice</unmanaged>	
                /// <unmanaged-short>GetDevice</unmanaged-short>	
                /// <unmanaged>HRESULT ID3DX10Sprite::GetDevice([Out] ID3D10Device** ppDevice)</unmanaged>
                public SharpDX.Direct3D10.Device Device {
                        get { SharpDX.Direct3D10.Device __output__; GetDevice(out __output__); return __output__; }
                }
                
                /// <summary>	
                /// <p>Prepare a device for drawing sprites.</p>	
                /// </summary>	
                /// <param name="flags"><dd>  <p>Flags that control how the sprites will be drawn. See <strong><see cref="SharpDX.Direct3D10.SpriteFlags"/></strong>.</p> </dd></param>	
                /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DERR_OUTOFVIDEOMEMORY, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p></returns>	
                /// <remarks>	
                /// <p>Every call to Begin must be matched with a call to <strong><see cref="SharpDX.Direct3D10.Sprite.End"/></strong>.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Sprite::Begin']/*"/>	
                /// <msdn-id>bb205602</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Sprite::Begin([In] D3DX10_SPRITE_FLAG flags)</unmanaged>	
                /// <unmanaged-short>ID3DX10Sprite::Begin</unmanaged-short>	
                public void Begin(SharpDX.Direct3D10.SpriteFlags flags) {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, unchecked((int)flags),((void**)(*(void**)_nativePointer))[3]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Add an array of sprites to the batch of sprites to be rendered. This must be called in between calls to <strong><see cref="SharpDX.Direct3D10.Sprite.Begin"/></strong> and <strong><see cref="SharpDX.Direct3D10.Sprite.End"/></strong>, and <strong><see cref="SharpDX.Direct3D10.Sprite.Flush"/></strong> must be called before End to send all of the batched sprites to the device for rendering. This draw method is most useful when drawing a small number of sprites that you want buffered into a large batch, such as fonts.</p>	
                /// </summary>	
                /// <param name="spritesRef">No documentation.</param>	
                /// <param name="cSprites">No documentation.</param>	
                /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Sprite::DrawSpritesBuffered']/*"/>	
                /// <msdn-id>bb205603</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Sprite::DrawSpritesBuffered([In, Buffer] D3DX10_SPRITE* pSprites,[In] unsigned int cSprites)</unmanaged>	
                /// <unmanaged-short>ID3DX10Sprite::DrawSpritesBuffered</unmanaged-short>	
                internal void DrawSpritesBuffered(SharpDX.Direct3D10.SpriteInstance[] spritesRef, int cSprites) {
                    unsafe {
                        SharpDX.Result __result__;
                        fixed (void* spritesRef_ = spritesRef)
                            __result__= 
            				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, spritesRef_, cSprites,((void**)(*(void**)_nativePointer))[4]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Force all batched sprites to be submitted to the device. Device states remain as they were after the last call to <see cref="SharpDX.Direct3D10.Sprite.Begin"/>. The list of batched sprites is then cleared.</p>	
                /// </summary>	
                /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: D3DERR_INVALIDCALL.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Sprite::Flush']/*"/>	
                /// <msdn-id>bb205606</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Sprite::Flush()</unmanaged>	
                /// <unmanaged-short>ID3DX10Sprite::Flush</unmanaged-short>	
                public void Flush() {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[5]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Draw an array of sprites. This will immediately send the sprites to the device for rendering, which is different from <strong><see cref="SharpDX.Direct3D10.Sprite.DrawSpritesBuffered"/></strong> which only adds an array of sprites to a batch of sprites to be rendered when <strong><see cref="SharpDX.Direct3D10.Sprite.Flush"/></strong> is called. This draw method is most useful when drawing a large number of sprites that have already been sorted on the CPU (or do not need to be sorted), such as in a particle system. This must be called in between calls to <strong><see cref="SharpDX.Direct3D10.Sprite.Begin"/></strong> and <strong><see cref="SharpDX.Direct3D10.Sprite.End"/></strong>.</p>	
                /// </summary>	
                /// <param name="spritesRef">No documentation.</param>	
                /// <param name="cSprites">No documentation.</param>	
                /// <param name="cbSprite">No documentation.</param>	
                /// <param name="flags">No documentation.</param>	
                /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Sprite::DrawSpritesImmediate']/*"/>	
                /// <msdn-id>bb205604</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Sprite::DrawSpritesImmediate([In, Buffer] D3DX10_SPRITE* pSprites,[In] unsigned int cSprites,[In] unsigned int cbSprite,[In] unsigned int flags)</unmanaged>	
                /// <unmanaged-short>ID3DX10Sprite::DrawSpritesImmediate</unmanaged-short>	
                internal void DrawSpritesImmediate(SharpDX.Direct3D10.SpriteInstance[] spritesRef, int cSprites, int cbSprite, int flags) {
                    unsafe {
                        SharpDX.Result __result__;
                        fixed (void* spritesRef_ = spritesRef)
                            __result__= 
            				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, spritesRef_, cSprites, cbSprite, flags,((void**)(*(void**)_nativePointer))[6]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Call this after <see cref="SharpDX.Direct3D10.Sprite.Flush"/>. If  <see cref="SharpDX.Direct3D10.SpriteFlags.SaveState"/> was specified when <see cref="SharpDX.Direct3D10.Sprite.Begin"/> was called, this API will restore the device state to how it was before <see cref="SharpDX.Direct3D10.Sprite.Begin"/> was called.</p>	
                /// </summary>	
                /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: D3DERR_INVALIDCALL.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Sprite::End']/*"/>	
                /// <msdn-id>bb205605</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Sprite::End()</unmanaged>	
                /// <unmanaged-short>ID3DX10Sprite::End</unmanaged-short>	
                public void End() {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[7]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Get the view transform that applies to all sprites.</p>	
                /// </summary>	
                /// <param name="viewTransformRef"><dd>  <p>Pointer to a <strong>D3DX10MATRIX</strong> that will be set to the transform of the sprite from the original world space.</p> </dd></param>	
                /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: D3DERR_INVALIDCALL.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Sprite::GetViewTransform']/*"/>	
                /// <msdn-id>bb205609</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Sprite::GetViewTransform([Out] D3DXMATRIX* pViewTransform)</unmanaged>	
                /// <unmanaged-short>ID3DX10Sprite::GetViewTransform</unmanaged-short>	
                internal void GetViewTransform(out SharpDX.Mathematics.Interop.RawMatrix viewTransformRef) {
                    unsafe {
                        viewTransformRef = new SharpDX.Mathematics.Interop.RawMatrix();
                        SharpDX.Result __result__;
                        fixed (void* viewTransformRef_ = &viewTransformRef)
                            __result__= 
            				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, viewTransformRef_,((void**)(*(void**)_nativePointer))[8]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Set the view transform that applies to all sprites.</p>	
                /// </summary>	
                /// <param name="viewTransformRef"><dd>  <p>Pointer to a <see cref="SharpDX.Mathematics.Interop.RawMatrix"/> that contains a transform of the sprite from the original world space. Use this transform to scale, rotate, or transform the sprite.</p> </dd></param>	
                /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: D3DERR_INVALIDCALL.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Sprite::SetViewTransform']/*"/>	
                /// <msdn-id>bb205611</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Sprite::SetViewTransform([In] D3DXMATRIX* pViewTransform)</unmanaged>	
                /// <unmanaged-short>ID3DX10Sprite::SetViewTransform</unmanaged-short>	
                internal void SetViewTransform(ref SharpDX.Mathematics.Interop.RawMatrix viewTransformRef) {
                    unsafe {
                        SharpDX.Result __result__;
                        fixed (void* viewTransformRef_ = &viewTransformRef)
                            __result__= 
            				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, viewTransformRef_,((void**)(*(void**)_nativePointer))[9]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Get the sprite projection matrix that is applied to all sprites.</p>	
                /// </summary>	
                /// <param name="projectionTransformRef"><dd>  <p>Pointer to a <strong>D3DX10MATRIX</strong> that will be set to the sprite's projection matrix.</p> </dd></param>	
                /// <returns><p>The return value is one of the values listed in Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Sprite::GetProjectionTransform']/*"/>	
                /// <msdn-id>bb205608</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Sprite::GetProjectionTransform([Out] D3DXMATRIX* pProjectionTransform)</unmanaged>	
                /// <unmanaged-short>ID3DX10Sprite::GetProjectionTransform</unmanaged-short>	
                internal void GetProjectionTransform(out SharpDX.Mathematics.Interop.RawMatrix projectionTransformRef) {
                    unsafe {
                        projectionTransformRef = new SharpDX.Mathematics.Interop.RawMatrix();
                        SharpDX.Result __result__;
                        fixed (void* projectionTransformRef_ = &projectionTransformRef)
                            __result__= 
            				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, projectionTransformRef_,((void**)(*(void**)_nativePointer))[10]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Set the projection matrix for all sprites.</p>	
                /// </summary>	
                /// <param name="projectionTransformRef"><dd>  <p>The projection matrix to be used on all sprites.</p> </dd></param>	
                /// <returns><p>The return value is one of the values listed in Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Sprite::SetProjectionTransform']/*"/>	
                /// <msdn-id>bb205610</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Sprite::SetProjectionTransform([In] D3DXMATRIX* pProjectionTransform)</unmanaged>	
                /// <unmanaged-short>ID3DX10Sprite::SetProjectionTransform</unmanaged-short>	
                internal void SetProjectionTransform(ref SharpDX.Mathematics.Interop.RawMatrix projectionTransformRef) {
                    unsafe {
                        SharpDX.Result __result__;
                        fixed (void* projectionTransformRef_ = &projectionTransformRef)
                            __result__= 
            				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, projectionTransformRef_,((void**)(*(void**)_nativePointer))[11]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Retrieve the device associated with the sprite object.</p>	
                /// </summary>	
                /// <param name="deviceOut"><dd>  <p>Address of a reference to an <see cref="SharpDX.Direct3D10.Device"/> interface, representing the Direct3D device object associated with the sprite object.</p> </dd></param>	
                /// <returns><p>If the method succeeds, the return value is <see cref="SharpDX.Result.Ok"/>. If the method fails, the following value will be returned: D3DERR_INVALIDCALL.</p></returns>	
                /// <remarks>	
                /// <p>Calling this method will increase the internal reference count on the <see cref="SharpDX.Direct3D10.Device"/> interface.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3DX10Sprite::GetDevice']/*"/>	
                /// <msdn-id>bb205607</msdn-id>	
                /// <unmanaged>HRESULT ID3DX10Sprite::GetDevice([Out] ID3D10Device** ppDevice)</unmanaged>	
                /// <unmanaged-short>ID3DX10Sprite::GetDevice</unmanaged-short>	
                internal void GetDevice(out SharpDX.Direct3D10.Device deviceOut) {
                    unsafe {
                        IntPtr deviceOut_ = IntPtr.Zero;
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &deviceOut_,((void**)(*(void**)_nativePointer))[12]);		
                        deviceOut= (deviceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.Device(deviceOut_);	
                        __result__.CheckError();
                    }
                }
            }
            /// <summary>	
            /// <p>A state-block interface encapsulates render states.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>To create a state-block interface, call <strong><see cref="SharpDX.Direct3D10.D3D10.CreateStateBlock"/></strong>.</p><p>This interface can be used to save and restore pipeline state. It can also be used to capture the current state.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10StateBlock']/*"/>	
            /// <msdn-id>bb173856</msdn-id>	
            /// <unmanaged>ID3D10StateBlock</unmanaged>	
            /// <unmanaged-short>ID3D10StateBlock</unmanaged-short>	
            [Guid("0803425a-57f5-4dd6-9465-a87570834a08")]
            public partial class StateBlock : SharpDX.ComObject {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.StateBlock"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public StateBlock(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.StateBlock"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.StateBlock(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.StateBlock(nativePointer);
        		}
                
                
                /// <summary>	
                /// <p>Get the device.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10StateBlock::GetDevice']/*"/>	
                /// <msdn-id>bb173859</msdn-id>	
                /// <unmanaged>GetDevice</unmanaged>	
                /// <unmanaged-short>GetDevice</unmanaged-short>	
                /// <unmanaged>HRESULT ID3D10StateBlock::GetDevice([Out] ID3D10Device** ppDevice)</unmanaged>
                public SharpDX.Direct3D10.Device Device {
                        get { SharpDX.Direct3D10.Device __output__; GetDevice(out __output__); return __output__; }
                }
                
                /// <summary>	
                /// <p>Capture the current value of states that are included in a stateblock.</p>	
                /// </summary>	
                /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
                /// <remarks>	
                /// <p>Capture captures current values for states within an existing state block. It does not capture the entire state of the device. Creating an empty stateblock and calling Capture does nothing if no states have been set.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10StateBlock::Capture']/*"/>	
                /// <msdn-id>bb173858</msdn-id>	
                /// <unmanaged>HRESULT ID3D10StateBlock::Capture()</unmanaged>	
                /// <unmanaged-short>ID3D10StateBlock::Capture</unmanaged-short>	
                public void Capture() {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[3]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Apply the state block to the current device state.</p>	
                /// </summary>	
                /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10StateBlock::Apply']/*"/>	
                /// <msdn-id>bb173857</msdn-id>	
                /// <unmanaged>HRESULT ID3D10StateBlock::Apply()</unmanaged>	
                /// <unmanaged-short>ID3D10StateBlock::Apply</unmanaged-short>	
                public void Apply() {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Release all references to device objects.</p>	
                /// </summary>	
                /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
                /// <remarks>	
                /// <p>Each time you return a reference to an interface (by calling <strong><see cref="SharpDX.Direct3D10.StateBlock.GetDevice"/></strong>), the internal reference count is incremented; when you are finished using a stateblock, call this method to release all references and avoid a memory leak.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10StateBlock::ReleaseAllDeviceObjects']/*"/>	
                /// <msdn-id>cc627127</msdn-id>	
                /// <unmanaged>HRESULT ID3D10StateBlock::ReleaseAllDeviceObjects()</unmanaged>	
                /// <unmanaged-short>ID3D10StateBlock::ReleaseAllDeviceObjects</unmanaged-short>	
                public void ReleaseAllDeviceObjects() {
                    unsafe {
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer,((void**)(*(void**)_nativePointer))[5]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Get the device.</p>	
                /// </summary>	
                /// <param name="deviceOut"><dd>  <p>Pointer to the <see cref="SharpDX.Direct3D10.Device"/> interface that is returned.</p> </dd></param>	
                /// <returns><p>Returns one of the following Direct3D 10 Return Codes.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10StateBlock::GetDevice']/*"/>	
                /// <msdn-id>bb173859</msdn-id>	
                /// <unmanaged>HRESULT ID3D10StateBlock::GetDevice([Out] ID3D10Device** ppDevice)</unmanaged>	
                /// <unmanaged-short>ID3D10StateBlock::GetDevice</unmanaged-short>	
                internal void GetDevice(out SharpDX.Direct3D10.Device deviceOut) {
                    unsafe {
                        IntPtr deviceOut_ = IntPtr.Zero;
                        SharpDX.Result __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, &deviceOut_,((void**)(*(void**)_nativePointer))[6]);		
                        deviceOut= (deviceOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.Device(deviceOut_);	
                        __result__.CheckError();
                    }
                }
            }
            /// <summary>	
            /// <p>The device interface represents a virtual adapter for Direct3D 10.0; it is used to perform rendering and create Direct3D resources.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>A device is created using <strong><see cref="SharpDX.Direct3D10.D3D10.CreateDevice"/></strong>.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device']/*"/>	
            /// <msdn-id>bb173528</msdn-id>	
            /// <unmanaged>ID3D10Device</unmanaged>	
            /// <unmanaged-short>ID3D10Device</unmanaged-short>	
            [Guid("9B7E4C0F-342C-4106-A19F-4F2704F689F0")]
            public partial class StreamOutputStage : SharpDX.CppObject {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.StreamOutputStage"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public StreamOutputStage(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.StreamOutputStage"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.StreamOutputStage(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.StreamOutputStage(nativePointer);
        		}
                
                
                /// <summary>	
                /// <p>Set the target output buffers for the StreamOutput stage, which enables/disables the pipeline to stream-out data.</p>	
                /// </summary>	
                /// <param name="numBuffers">No documentation.</param>	
                /// <param name="sOTargetsOut">No documentation.</param>	
                /// <param name="offsetsRef">No documentation.</param>	
                /// <remarks>	
                /// <p>Call <strong><see cref="SharpDX.Direct3D10.StreamOutputStage.SetTargets"/></strong> (before any draw calls) to stream data out; call SOSetTargets with <strong><c>null</c></strong> to stop streaming data out. For an example, see Exercise 01 from the GDC 2007 workshop, which sets the stream output rendertargets before calling draw methods in the RenderInstanceToStream function.</p><p>An offset of -1 will cause the stream output buffer to be appended, continuing after the last location written to the buffer in a previous stream output pass.</p><p>Calling this method using a buffer that is currently bound for writing will effectively bind <strong><c>null</c></strong> instead because a buffer cannot be bound as both an input and an output at the same time.</p><p>The Debug Layer will generate a warning whenever a resource is prevented from being bound simultaneously as an input and an output, but this will not prevent invalid data from being used by the runtime.</p><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::SOSetTargets']/*"/>	
                /// <msdn-id>bb173620</msdn-id>	
                /// <unmanaged>void ID3D10Device::SOSetTargets([In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D10Buffer** ppSOTargets,[In, Buffer, Optional] const unsigned int* pOffsets)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::SOSetTargets</unmanaged-short>	
                internal void SetTargets(int numBuffers, SharpDX.Direct3D10.Buffer[] sOTargetsOut, int[] offsetsRef) {
                    unsafe {
                        IntPtr* sOTargetsOut_ = (IntPtr*)0;
                        if ( sOTargetsOut != null ) {
                            IntPtr* sOTargetsOut__ = stackalloc IntPtr[sOTargetsOut.Length];
                            sOTargetsOut_ = sOTargetsOut__;
                            for (int i = 0; i < sOTargetsOut.Length; i++)                        
                                sOTargetsOut_[i] =  (sOTargetsOut[i] == null)? IntPtr.Zero : sOTargetsOut[i].NativePointer;
                        }
                        int[] offsetsRef__ = offsetsRef;
                        fixed (void* offsetsRef_ = offsetsRef__)
                            SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, numBuffers, sOTargetsOut_, offsetsRef_,((void**)(*(void**)_nativePointer))[27]);		
                    }
                }
                
                /// <summary>	
                /// <p>Set the target output buffers for the StreamOutput stage, which enables/disables the pipeline to stream-out data.</p>	
                /// </summary>	
                /// <param name="numBuffers">No documentation.</param>	
                /// <param name="sOTargetsOut">No documentation.</param>	
                /// <param name="offsetsRef">No documentation.</param>	
                /// <remarks>	
                /// <p>Call <strong><see cref="SharpDX.Direct3D10.StreamOutputStage.SetTargets"/></strong> (before any draw calls) to stream data out; call SOSetTargets with <strong><c>null</c></strong> to stop streaming data out. For an example, see Exercise 01 from the GDC 2007 workshop, which sets the stream output rendertargets before calling draw methods in the RenderInstanceToStream function.</p><p>An offset of -1 will cause the stream output buffer to be appended, continuing after the last location written to the buffer in a previous stream output pass.</p><p>Calling this method using a buffer that is currently bound for writing will effectively bind <strong><c>null</c></strong> instead because a buffer cannot be bound as both an input and an output at the same time.</p><p>The Debug Layer will generate a warning whenever a resource is prevented from being bound simultaneously as an input and an output, but this will not prevent invalid data from being used by the runtime.</p><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::SOSetTargets']/*"/>	
                /// <msdn-id>bb173620</msdn-id>	
                /// <unmanaged>void ID3D10Device::SOSetTargets([In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D10Buffer** ppSOTargets,[In, Buffer, Optional] const unsigned int* pOffsets)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::SOSetTargets</unmanaged-short>	
                internal void SetTargets(int numBuffers, SharpDX.ComArray<SharpDX.Direct3D10.Buffer> sOTargetsOut, int[] offsetsRef) {
                    unsafe {
                        int[] offsetsRef__ = offsetsRef;
                        fixed (void* offsetsRef_ = offsetsRef__)
                            SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, numBuffers, (void*)((sOTargetsOut == null)?IntPtr.Zero:sOTargetsOut.NativePointer), offsetsRef_,((void**)(*(void**)_nativePointer))[27]);		
                    }
                }
                
                /// <summary>	
                /// <p>Set the target output buffers for the StreamOutput stage, which enables/disables the pipeline to stream-out data.</p>	
                /// </summary>	
                /// <param name="numBuffers">No documentation.</param>	
                /// <param name="sOTargetsOut">No documentation.</param>	
                /// <param name="offsetsRef">No documentation.</param>	
                /// <remarks>	
                /// <p>Call <strong><see cref="SharpDX.Direct3D10.StreamOutputStage.SetTargets"/></strong> (before any draw calls) to stream data out; call SOSetTargets with <strong><c>null</c></strong> to stop streaming data out. For an example, see Exercise 01 from the GDC 2007 workshop, which sets the stream output rendertargets before calling draw methods in the RenderInstanceToStream function.</p><p>An offset of -1 will cause the stream output buffer to be appended, continuing after the last location written to the buffer in a previous stream output pass.</p><p>Calling this method using a buffer that is currently bound for writing will effectively bind <strong><c>null</c></strong> instead because a buffer cannot be bound as both an input and an output at the same time.</p><p>The Debug Layer will generate a warning whenever a resource is prevented from being bound simultaneously as an input and an output, but this will not prevent invalid data from being used by the runtime.</p><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::SOSetTargets']/*"/>	
                /// <msdn-id>bb173620</msdn-id>	
                /// <unmanaged>void ID3D10Device::SOSetTargets([In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D10Buffer** ppSOTargets,[In, Buffer, Optional] const unsigned int* pOffsets)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::SOSetTargets</unmanaged-short>	
                private void SetTargets(int numBuffers, System.IntPtr sOTargetsOut, System.IntPtr offsetsRef) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, numBuffers, (void*)sOTargetsOut, (void*)offsetsRef,((void**)(*(void**)_nativePointer))[27]);		
                    }
                }
                
                /// <summary>	
                /// <p>Get the target output buffers for the StreamOutput stage of the pipeline.</p>	
                /// </summary>	
                /// <param name="numBuffers">No documentation.</param>	
                /// <param name="sOTargetsOut">No documentation.</param>	
                /// <param name="offsetsRef">No documentation.</param>	
                /// <remarks>	
                /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::SOGetTargets']/*"/>	
                /// <msdn-id>bb173619</msdn-id>	
                /// <unmanaged>void ID3D10Device::SOGetTargets([In] unsigned int NumBuffers,[Out, Buffer, Optional] ID3D10Buffer** ppSOTargets,[Out, Buffer, Optional] unsigned int* pOffsets)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::SOGetTargets</unmanaged-short>	
                internal void GetTargets(int numBuffers, SharpDX.Direct3D10.Buffer[] sOTargetsOut, int[] offsetsRef) {
                    unsafe {
                        IntPtr* sOTargetsOut_ = stackalloc IntPtr[sOTargetsOut == null ? 0 : sOTargetsOut.Length];
                        int[] offsetsRef__ = offsetsRef;
                        fixed (void* offsetsRef_ = offsetsRef__)
                            SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, numBuffers, sOTargetsOut==null?(void*)0:sOTargetsOut_, offsetsRef_,((void**)(*(void**)_nativePointer))[59]);		
                        if (sOTargetsOut != null)
                        for (int i = 0; i < sOTargetsOut.Length; i++)
                            sOTargetsOut[i] = (sOTargetsOut_[i] == IntPtr.Zero)?null:new SharpDX.Direct3D10.Buffer(sOTargetsOut_[i]);	
                    }
                }
            }
            /// <summary>	
            /// <p>A switch-to-reference interface (see the switch-to-reference layer) enables an application to switch between a hardware and software device.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>This interface is obtained by calling <strong>QueryInterface</strong> on a <strong><see cref="SharpDX.Direct3D10.Device"/> Interface</strong> created with the <strong><see cref="SharpDX.Direct3D10.DeviceCreationFlags.SwitchToRef"/></strong> flag.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10SwitchToRef']/*"/>	
            /// <msdn-id>bb173860</msdn-id>	
            /// <unmanaged>ID3D10SwitchToRef</unmanaged>	
            /// <unmanaged-short>ID3D10SwitchToRef</unmanaged-short>	
            [Guid("9B7E4E02-342C-4106-A19F-4F2704F689F0")]
            public partial class SwitchToRef : SharpDX.ComObject {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.SwitchToRef"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public SwitchToRef(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.SwitchToRef"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.SwitchToRef(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.SwitchToRef(nativePointer);
        		}
                
                
                /// <summary>	
                /// <p>Get a boolean value that indicates the type of device being used.</p>	
                /// </summary>	
                /// <remarks>	
                /// <p>A hardware device is commonly referred to as a HAL device, which stands for a hardware accelerated device. This means that the pipeline is rendering all of the pipeline commands in hardware, using the GPU. Operating the pipeline with a HAL device gives the best performance generally, but it can be more difficult to debug since resources exist on the GPU instead of the CPU.</p><p>A software device implements rendering in software using the CPU with no hardware acceleration. A software device is commonly referred to as a reference device or REF device. Because a REF device implements rendering on the CPU, it is generally slower, but is easier to debug since it allows access to resources.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10SwitchToRef::GetUseRef']/*"/>	
                /// <msdn-id>bb173861</msdn-id>	
                /// <unmanaged>GetUseRef</unmanaged>	
                /// <unmanaged-short>GetUseRef</unmanaged-short>	
                /// <unmanaged>BOOL ID3D10SwitchToRef::GetUseRef()</unmanaged>
                public SharpDX.Mathematics.Interop.RawBool UseRef {
                        get { return GetUseRef(); }
                }
                
                /// <summary>	
                /// <p>Switch between a hardware and a software device.</p>	
                /// </summary>	
                /// <param name="useRef"><dd>  <p>A boolean value. Set this to <strong>TRUE</strong> to change to a software device, set this to <strong><see cref="SharpDX.Result.False"/></strong> to change to a hardware device.</p> </dd></param>	
                /// <returns><p>The previous value of <em>UseRef</em>.</p></returns>	
                /// <remarks>	
                /// <p>This API will fail if the device is not switchable; you must have created a device that is switchable by specifying the <see cref="SharpDX.Direct3D10.DeviceCreationFlags.SwitchToRef"/> flag during device creation (when calling <strong><see cref="SharpDX.Direct3D10.D3D10.CreateDevice"/></strong>).</p><p>Switching from a software device to a hardware device clears all cached objects from system memory. Switching from a hardware device to a software device causes resources to be downloaded to system memory.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10SwitchToRef::SetUseRef']/*"/>	
                /// <msdn-id>bb173862</msdn-id>	
                /// <unmanaged>BOOL ID3D10SwitchToRef::SetUseRef([In] BOOL UseRef)</unmanaged>	
                /// <unmanaged-short>ID3D10SwitchToRef::SetUseRef</unmanaged-short>	
                public SharpDX.Mathematics.Interop.RawBool SetUseRef(SharpDX.Mathematics.Interop.RawBool useRef) {
                    unsafe {
                        SharpDX.Mathematics.Interop.RawBool __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.CalliSharpDXMathematicsInteropRawBool36(_nativePointer, useRef,((void**)(*(void**)_nativePointer))[3]);		
                        return __result__;
                    }
                }
                
                /// <summary>	
                /// <p>Get a boolean value that indicates the type of device being used.</p>	
                /// </summary>	
                /// <returns><p><strong>TRUE</strong> if the device is a software device, <strong><see cref="SharpDX.Result.False"/></strong> if the device is a hardware device. See remarks.</p></returns>	
                /// <remarks>	
                /// <p>A hardware device is commonly referred to as a HAL device, which stands for a hardware accelerated device. This means that the pipeline is rendering all of the pipeline commands in hardware, using the GPU. Operating the pipeline with a HAL device gives the best performance generally, but it can be more difficult to debug since resources exist on the GPU instead of the CPU.</p><p>A software device implements rendering in software using the CPU with no hardware acceleration. A software device is commonly referred to as a reference device or REF device. Because a REF device implements rendering on the CPU, it is generally slower, but is easier to debug since it allows access to resources.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10SwitchToRef::GetUseRef']/*"/>	
                /// <msdn-id>bb173861</msdn-id>	
                /// <unmanaged>BOOL ID3D10SwitchToRef::GetUseRef()</unmanaged>	
                /// <unmanaged-short>ID3D10SwitchToRef::GetUseRef</unmanaged-short>	
                internal SharpDX.Mathematics.Interop.RawBool GetUseRef() {
                    unsafe {
                        SharpDX.Mathematics.Interop.RawBool __result__;
                        __result__= 
        				SharpDX.Direct3D10.LocalInterop.CalliSharpDXMathematicsInteropRawBool(_nativePointer,((void**)(*(void**)_nativePointer))[4]);		
                        return __result__;
                    }
                }
            }
            /// <summary>	
            /// <p>A 1D texture interface accesses texel data, which is structured memory.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>To create an empty 1D texture, call <strong><see cref="SharpDX.Direct3D10.Device.CreateTexture1D"/></strong>. For more details on creating and loading textures, see Creating Texture Resources.</p><p>Textures cannot be bound directly to the pipeline; instead, a view must be created and bound. Using a view, texture data can be interpreted at run time within certain restrictions. To use the texture as a render target or depth-stencil resource, call <strong><see cref="SharpDX.Direct3D10.Device.CreateRenderTargetView"/></strong>, and <strong><see cref="SharpDX.Direct3D10.Device.CreateDepthStencilView"/></strong>, respectively. To use the texture as an input to a shader, create a  by calling <strong><see cref="SharpDX.Direct3D10.Device.CreateShaderResourceView"/></strong>.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Texture1D']/*"/>	
            /// <msdn-id>bb173863</msdn-id>	
            /// <unmanaged>ID3D10Texture1D</unmanaged>	
            /// <unmanaged-short>ID3D10Texture1D</unmanaged-short>	
            [Guid("9B7E4C03-342C-4106-A19F-4F2704F689F0")]
            public partial class Texture1D : SharpDX.Direct3D10.Resource {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.Texture1D"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public Texture1D(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.Texture1D"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.Texture1D(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.Texture1D(nativePointer);
        		}
                
                
                /// <summary>	
                /// <p>Get the properties of the texture resource.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Texture1D::GetDesc']/*"/>	
                /// <msdn-id>bb173864</msdn-id>	
                /// <unmanaged>GetDesc</unmanaged>	
                /// <unmanaged-short>GetDesc</unmanaged-short>	
                /// <unmanaged>void ID3D10Texture1D::GetDesc([Out] D3D10_TEXTURE1D_DESC* pDesc)</unmanaged>
                public SharpDX.Direct3D10.Texture1DDescription Description {
                        get { SharpDX.Direct3D10.Texture1DDescription __output__; GetDescription(out __output__); return __output__; }
                }
                
                /// <summary>	
                /// <p>Get a reference to the data contained in a subresource, and deny the GPU access to that subresource.</p>	
                /// </summary>	
                /// <param name="subresource"><dd>  <p>Index number of the subresource. See <strong>D3D10CalcSubresource</strong> for more details.</p> </dd></param>	
                /// <param name="mapType"><dd>  <p>Specifies the CPU's read and write permissions for a resource. For possible values, see <strong><see cref="SharpDX.Direct3D10.MapMode"/></strong>.</p> </dd></param>	
                /// <param name="mapFlags"><dd>  <p> <strong>Flag</strong> that specifies what the CPU should do when the GPU is busy. This flag is optional.</p> </dd></param>	
                /// <param name="dataOut"><dd>  <p>Pointer to the texture resource data.</p> </dd></param>	
                /// <returns><p>If this function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. For other restrictions, and a listing of error values that can be returned by any of the <strong>Map</strong> methods, see Remarks.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Texture1D::Map']/*"/>	
                /// <msdn-id>bb173865</msdn-id>	
                /// <unmanaged>HRESULT ID3D10Texture1D::Map([In] unsigned int Subresource,[In] D3D10_MAP MapType,[In] D3D10_MAP_FLAG MapFlags,[Out] void** ppData)</unmanaged>	
                /// <unmanaged-short>ID3D10Texture1D::Map</unmanaged-short>	
                internal void Map(int subresource, SharpDX.Direct3D10.MapMode mapType, SharpDX.Direct3D10.MapFlags mapFlags, out System.IntPtr dataOut) {
                    unsafe {
                        SharpDX.Result __result__;
                        fixed (void* dataOut_ = &dataOut)
                            __result__= 
            				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, subresource, unchecked((int)mapType), unchecked((int)mapFlags), dataOut_,((void**)(*(void**)_nativePointer))[10]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Invalidate the reference to a resource that was retrieved by <strong><see cref="SharpDX.Direct3D10.Texture1D.Map"/></strong>, and re-enable the GPU's access to that resource.</p>	
                /// </summary>	
                /// <param name="subresource">No documentation.</param>	
                /// <remarks>	
                /// <p>A subresource must be mapped before Unmap is called.</p><table> <tr><td> <p>Differences between Direct3D 9 and Direct3D 10:</p> <p>Unmap in Direct3D 10 is analogous to resource Unlock in Direct3D 9.</p> </td></tr> </table><p>?</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Texture1D::Unmap']/*"/>	
                /// <msdn-id>bb173866</msdn-id>	
                /// <unmanaged>void ID3D10Texture1D::Unmap([In] unsigned int Subresource)</unmanaged>	
                /// <unmanaged-short>ID3D10Texture1D::Unmap</unmanaged-short>	
                public void Unmap(int subresource) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, subresource,((void**)(*(void**)_nativePointer))[11]);		
                    }
                }
                
                /// <summary>	
                /// <p>Get the properties of the texture resource.</p>	
                /// </summary>	
                /// <param name="descRef"><dd>  <p>Pointer to a resource description (see <strong><see cref="SharpDX.Direct3D10.Texture1DDescription"/></strong>).</p> </dd></param>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Texture1D::GetDesc']/*"/>	
                /// <msdn-id>bb173864</msdn-id>	
                /// <unmanaged>void ID3D10Texture1D::GetDesc([Out] D3D10_TEXTURE1D_DESC* pDesc)</unmanaged>	
                /// <unmanaged-short>ID3D10Texture1D::GetDesc</unmanaged-short>	
                internal void GetDescription(out SharpDX.Direct3D10.Texture1DDescription descRef) {
                    unsafe {
                        descRef = new SharpDX.Direct3D10.Texture1DDescription();
                        fixed (void* descRef_ = &descRef)
                            SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, descRef_,((void**)(*(void**)_nativePointer))[12]);		
                    }
                }
            }
            /// <summary>	
            /// <p>A 2D texture interface manages texel data, which is structured memory.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>To create an empty Texture2D resource, call <strong><see cref="SharpDX.Direct3D10.Device.CreateTexture2D"/></strong>. For more details on creating and loading textures, see Creating Texture Resources.</p><p>Textures cannot be bound directly to the pipeline; instead, a view must be created and bound. Using a view, texture data can be interpreted at run time within certain restrictions. To use the texture as a render target or depth-stencil resource, call <strong><see cref="SharpDX.Direct3D10.Device.CreateRenderTargetView"/></strong>, and <strong><see cref="SharpDX.Direct3D10.Device.CreateDepthStencilView"/></strong>, respectively. To use the texture as an input to a shader, create a  by calling <strong><see cref="SharpDX.Direct3D10.Device.CreateShaderResourceView"/></strong>.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Texture2D']/*"/>	
            /// <msdn-id>bb173867</msdn-id>	
            /// <unmanaged>ID3D10Texture2D</unmanaged>	
            /// <unmanaged-short>ID3D10Texture2D</unmanaged-short>	
            [Guid("9B7E4C04-342C-4106-A19F-4F2704F689F0")]
            public partial class Texture2D : SharpDX.Direct3D10.Resource {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.Texture2D"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public Texture2D(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.Texture2D"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.Texture2D(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.Texture2D(nativePointer);
        		}
                
                
                /// <summary>	
                /// <p>Get the properties of the texture resource.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Texture2D::GetDesc']/*"/>	
                /// <msdn-id>bb173868</msdn-id>	
                /// <unmanaged>GetDesc</unmanaged>	
                /// <unmanaged-short>GetDesc</unmanaged-short>	
                /// <unmanaged>void ID3D10Texture2D::GetDesc([Out] D3D10_TEXTURE2D_DESC* pDesc)</unmanaged>
                public SharpDX.Direct3D10.Texture2DDescription Description {
                        get { SharpDX.Direct3D10.Texture2DDescription __output__; GetDescription(out __output__); return __output__; }
                }
                
                /// <summary>	
                /// <p>Get a reference to the data contained in a subresource, and deny GPU access to that subresource.</p>	
                /// </summary>	
                /// <param name="subresource"><dd>  <p>Index number of the subresource. See <strong>D3D10CalcSubresource</strong> for more details.</p> </dd></param>	
                /// <param name="mapType"><dd>  <p>Integer that specifies the CPU's read and write permissions for a resource. For possible values, see <strong><see cref="SharpDX.Direct3D10.MapMode"/></strong>.</p> </dd></param>	
                /// <param name="mapFlags"><dd>  <p> <strong>Flag</strong> that specifies what the CPU should do when the GPU is busy. This flag is optional.</p> </dd></param>	
                /// <param name="mappedTex2DRef"><dd>  <p>Pointer to a structure (<strong><see cref="SharpDX.DataRectangle"/></strong>) that is filled in by the function and contains a reference to the resource data.</p> </dd></param>	
                /// <returns><p>If this function succeeds, it returns <see cref="SharpDX.Result.Ok"/>.</p><p>All of the Map methods have identical return values and operating restrictions. These are listed in the remarks section of <strong><see cref="SharpDX.Direct3D10.Texture1D.Map"/></strong>.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Texture2D::Map']/*"/>	
                /// <msdn-id>bb173869</msdn-id>	
                /// <unmanaged>HRESULT ID3D10Texture2D::Map([In] unsigned int Subresource,[In] D3D10_MAP MapType,[In] D3D10_MAP_FLAG MapFlags,[Out] D3D10_MAPPED_TEXTURE2D* pMappedTex2D)</unmanaged>	
                /// <unmanaged-short>ID3D10Texture2D::Map</unmanaged-short>	
                internal void Map(int subresource, SharpDX.Direct3D10.MapMode mapType, SharpDX.Direct3D10.MapFlags mapFlags, out SharpDX.DataRectangle mappedTex2DRef) {
                    unsafe {
                        mappedTex2DRef = new SharpDX.DataRectangle();
                        SharpDX.Result __result__;
                        fixed (void* mappedTex2DRef_ = &mappedTex2DRef)
                            __result__= 
            				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, subresource, unchecked((int)mapType), unchecked((int)mapFlags), mappedTex2DRef_,((void**)(*(void**)_nativePointer))[10]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Invalidate the reference to the resource that was retrieved by <strong><see cref="SharpDX.Direct3D10.Texture2D.Map"/></strong>, and re-enable GPU access to the resource.</p>	
                /// </summary>	
                /// <param name="subresource">No documentation.</param>	
                /// <remarks>	
                /// <p>A subresource must be mapped before Unmap is called.</p><table> <tr><td> <p>Differences between Direct3D 9 and Direct3D 10:</p> <p>Unmap in Direct3D 10 is analogous to resource Unlock in Direct3D 9.</p> </td></tr> </table><p>?</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Texture2D::Unmap']/*"/>	
                /// <msdn-id>bb173870</msdn-id>	
                /// <unmanaged>void ID3D10Texture2D::Unmap([In] unsigned int Subresource)</unmanaged>	
                /// <unmanaged-short>ID3D10Texture2D::Unmap</unmanaged-short>	
                public void Unmap(int subresource) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, subresource,((void**)(*(void**)_nativePointer))[11]);		
                    }
                }
                
                /// <summary>	
                /// <p>Get the properties of the texture resource.</p>	
                /// </summary>	
                /// <param name="descRef"><dd>  <p>Pointer to a resource description (see <strong><see cref="SharpDX.Direct3D10.Texture2DDescription"/></strong>).</p> </dd></param>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Texture2D::GetDesc']/*"/>	
                /// <msdn-id>bb173868</msdn-id>	
                /// <unmanaged>void ID3D10Texture2D::GetDesc([Out] D3D10_TEXTURE2D_DESC* pDesc)</unmanaged>	
                /// <unmanaged-short>ID3D10Texture2D::GetDesc</unmanaged-short>	
                internal void GetDescription(out SharpDX.Direct3D10.Texture2DDescription descRef) {
                    unsafe {
                        descRef = new SharpDX.Direct3D10.Texture2DDescription();
                        fixed (void* descRef_ = &descRef)
                            SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, descRef_,((void**)(*(void**)_nativePointer))[12]);		
                    }
                }
            }
            /// <summary>	
            /// <p>A 3D texture interface accesses texel data, which is structured memory.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>To create an empty Texture3D resource, call <strong><see cref="SharpDX.Direct3D10.Device.CreateTexture3D"/></strong>. For more details on creating and loading textures, see Creating Texture Resources.</p><p>Textures cannot be bound directly to the pipeline; instead, a view must be created and bound. Using a view, texture data can be interpreted at run time within certain restrictions. To use the texture as a render target or depth-stencil resource, call <strong><see cref="SharpDX.Direct3D10.Device.CreateRenderTargetView"/></strong>, and <strong><see cref="SharpDX.Direct3D10.Device.CreateDepthStencilView"/></strong>, respectively. To use the texture as an input to a shader, create a  by calling <strong><see cref="SharpDX.Direct3D10.Device.CreateShaderResourceView"/></strong>.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Texture3D']/*"/>	
            /// <msdn-id>bb173871</msdn-id>	
            /// <unmanaged>ID3D10Texture3D</unmanaged>	
            /// <unmanaged-short>ID3D10Texture3D</unmanaged-short>	
            [Guid("9B7E4C05-342C-4106-A19F-4F2704F689F0")]
            public partial class Texture3D : SharpDX.Direct3D10.Resource {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.Texture3D"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public Texture3D(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.Texture3D"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.Texture3D(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.Texture3D(nativePointer);
        		}
                
                
                /// <summary>	
                /// <p>Get the properties of the texture resource.</p>	
                /// </summary>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Texture3D::GetDesc']/*"/>	
                /// <msdn-id>bb173872</msdn-id>	
                /// <unmanaged>GetDesc</unmanaged>	
                /// <unmanaged-short>GetDesc</unmanaged-short>	
                /// <unmanaged>void ID3D10Texture3D::GetDesc([Out] D3D10_TEXTURE3D_DESC* pDesc)</unmanaged>
                public SharpDX.Direct3D10.Texture3DDescription Description {
                        get { SharpDX.Direct3D10.Texture3DDescription __output__; GetDescription(out __output__); return __output__; }
                }
                
                /// <summary>	
                /// <p>Get a reference to the data contained in a subresource, and deny GPU access to that subresource.</p>	
                /// </summary>	
                /// <param name="subresource"><dd>  <p>Index number of the subresource. See <strong>D3D10CalcSubresource</strong>for more details.</p> </dd></param>	
                /// <param name="mapType"><dd>  <p>Specifies the CPU's read and write permissions for a resource. For possible values, see <strong><see cref="SharpDX.Direct3D10.MapMode"/></strong>.</p> </dd></param>	
                /// <param name="mapFlags"><dd>  <p> <strong>Flag</strong> that specifies what the CPU should do when the GPU is busy. This flag is optional.</p> </dd></param>	
                /// <param name="mappedTex3DRef"><dd>  <p>Pointer to a structure (<strong><see cref="SharpDX.DataBox"/></strong>) that is filled in by the function and contains a reference to the resource data.</p> </dd></param>	
                /// <returns><p>If this function succeeds, it returns <see cref="SharpDX.Result.Ok"/>. All of the Map methods have identical return values and operating restrictions. These are listed in the remarks section of <strong><see cref="SharpDX.Direct3D10.Texture1D.Map"/></strong>.</p></returns>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Texture3D::Map']/*"/>	
                /// <msdn-id>bb173873</msdn-id>	
                /// <unmanaged>HRESULT ID3D10Texture3D::Map([In] unsigned int Subresource,[In] D3D10_MAP MapType,[In] D3D10_MAP_FLAG MapFlags,[Out] D3D10_MAPPED_TEXTURE3D* pMappedTex3D)</unmanaged>	
                /// <unmanaged-short>ID3D10Texture3D::Map</unmanaged-short>	
                internal void Map(int subresource, SharpDX.Direct3D10.MapMode mapType, SharpDX.Direct3D10.MapFlags mapFlags, out SharpDX.DataBox mappedTex3DRef) {
                    unsafe {
                        mappedTex3DRef = new SharpDX.DataBox();
                        SharpDX.Result __result__;
                        fixed (void* mappedTex3DRef_ = &mappedTex3DRef)
                            __result__= 
            				SharpDX.Direct3D10.LocalInterop.Calliint(_nativePointer, subresource, unchecked((int)mapType), unchecked((int)mapFlags), mappedTex3DRef_,((void**)(*(void**)_nativePointer))[10]);		
                        __result__.CheckError();
                    }
                }
                
                /// <summary>	
                /// <p>Invalidate the reference to the resource retrieved by <strong><see cref="SharpDX.Direct3D10.Texture3D.Map"/></strong>, and re-enable the GPU's access to the resource.</p>	
                /// </summary>	
                /// <param name="subresource">No documentation.</param>	
                /// <remarks>	
                /// <p>A subresource must be mapped before Unmap is called.</p><table> <tr><td> <p>Differences between Direct3D 9 and Direct3D 10:</p> <p>Unmap() in Direct3D 10 is analogous to resource Unlock() in Direct3D 9.</p> </td></tr> </table><p>?</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Texture3D::Unmap']/*"/>	
                /// <msdn-id>bb173874</msdn-id>	
                /// <unmanaged>void ID3D10Texture3D::Unmap([In] unsigned int Subresource)</unmanaged>	
                /// <unmanaged-short>ID3D10Texture3D::Unmap</unmanaged-short>	
                public void Unmap(int subresource) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, subresource,((void**)(*(void**)_nativePointer))[11]);		
                    }
                }
                
                /// <summary>	
                /// <p>Get the properties of the texture resource.</p>	
                /// </summary>	
                /// <param name="descRef"><dd>  <p>Pointer to a resource description (see <strong><see cref="SharpDX.Direct3D10.Texture3DDescription"/></strong>).</p> </dd></param>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Texture3D::GetDesc']/*"/>	
                /// <msdn-id>bb173872</msdn-id>	
                /// <unmanaged>void ID3D10Texture3D::GetDesc([Out] D3D10_TEXTURE3D_DESC* pDesc)</unmanaged>	
                /// <unmanaged-short>ID3D10Texture3D::GetDesc</unmanaged-short>	
                internal void GetDescription(out SharpDX.Direct3D10.Texture3DDescription descRef) {
                    unsafe {
                        descRef = new SharpDX.Direct3D10.Texture3DDescription();
                        fixed (void* descRef_ = &descRef)
                            SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, descRef_,((void**)(*(void**)_nativePointer))[12]);		
                    }
                }
            }
            /// <summary>	
            /// <p>A vertex-shader interface manages an executable program (a vertex shader) that controls the vertex-shader stage.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>The vertex-shader interface has no methods; use HLSL to implement your shader functionality. All shaders in Direct3D 10 are implemented from a common set of features referred to as the common shader core.</p><p>To create a vertex shader interface, call <strong><see cref="SharpDX.Direct3D10.Device.CreateVertexShader"/></strong>. Before using a vertex shader you must bind it to the device by calling <strong><see cref="SharpDX.Direct3D10.VertexShaderStage.Set"/></strong>.</p><p>This interface is defined in D3D10.h.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10VertexShader']/*"/>	
            /// <msdn-id>bb173875</msdn-id>	
            /// <unmanaged>ID3D10VertexShader</unmanaged>	
            /// <unmanaged-short>ID3D10VertexShader</unmanaged-short>	
            [Guid("9B7E4C0A-342C-4106-A19F-4F2704F689F0")]
            public partial class VertexShader : SharpDX.Direct3D10.DeviceChild {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.VertexShader"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public VertexShader(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.VertexShader"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.VertexShader(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.VertexShader(nativePointer);
        		}
                
            }
            /// <summary>	
            /// <p>The device interface represents a virtual adapter for Direct3D 10.0; it is used to perform rendering and create Direct3D resources.</p>	
            /// </summary>	
            /// <remarks>	
            /// <p>A device is created using <strong><see cref="SharpDX.Direct3D10.D3D10.CreateDevice"/></strong>.</p>	
            /// </remarks>	
            /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device']/*"/>	
            /// <msdn-id>bb173528</msdn-id>	
            /// <unmanaged>ID3D10Device</unmanaged>	
            /// <unmanaged-short>ID3D10Device</unmanaged-short>	
            [Guid("9B7E4C0F-342C-4106-A19F-4F2704F689F0")]
            public partial class VertexShaderStage : CommonShaderStage<VertexShader> {
                /// <summary>
                /// Initializes a new instance of the <see cref="SharpDX.Direct3D10.VertexShaderStage"/> class.
                /// </summary>
                /// <param name="nativePtr">The native pointer.</param>	
                public VertexShaderStage(IntPtr nativePtr) : base(nativePtr) {
                }
        
        		/// <summary>
        		/// Performs an explicit conversion from <see cref="System.IntPtr"/> to <see cref="SharpDX.Direct3D10.VertexShaderStage"/>. (This method is a shortcut to <see cref="SharpDX.CppObject.NativePointer"/>) 
        		/// </summary>
        		/// <param name="nativePointer">The native pointer.</param>
        		/// <returns>
        		/// The result of the conversion.
        		/// </returns>
        		public static explicit operator SharpDX.Direct3D10.VertexShaderStage(IntPtr nativePointer)
        		{
        			return nativePointer == IntPtr.Zero ? null : new SharpDX.Direct3D10.VertexShaderStage(nativePointer);
        		}
                
                
                /// <summary>	
                /// <p>Set the constant buffers used by the vertex shader pipeline stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numBuffers">No documentation.</param>	
                /// <param name="constantBuffersOut">No documentation.</param>	
                /// <remarks>	
                /// <p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::VSSetConstantBuffers']/*"/>	
                /// <msdn-id>bb173626</msdn-id>	
                /// <unmanaged>void ID3D10Device::VSSetConstantBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D10Buffer** ppConstantBuffers)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::VSSetConstantBuffers</unmanaged-short>	
                public override void SetConstantBuffers(int startSlot, int numBuffers, SharpDX.Direct3D10.Buffer[] constantBuffersOut) {
                    unsafe {
                        IntPtr* constantBuffersOut_ = (IntPtr*)0;
                        if ( constantBuffersOut != null ) {
                            IntPtr* constantBuffersOut__ = stackalloc IntPtr[constantBuffersOut.Length];
                            constantBuffersOut_ = constantBuffersOut__;
                            for (int i = 0; i < constantBuffersOut.Length; i++)                        
                                constantBuffersOut_[i] =  (constantBuffersOut[i] == null)? IntPtr.Zero : constantBuffersOut[i].NativePointer;
                        }
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numBuffers, constantBuffersOut_,((void**)(*(void**)_nativePointer))[3]);		
                    }
                }
                
                /// <summary>	
                /// <p>Set the constant buffers used by the vertex shader pipeline stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numBuffers">No documentation.</param>	
                /// <param name="constantBuffersOut">No documentation.</param>	
                /// <remarks>	
                /// <p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::VSSetConstantBuffers']/*"/>	
                /// <msdn-id>bb173626</msdn-id>	
                /// <unmanaged>void ID3D10Device::VSSetConstantBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D10Buffer** ppConstantBuffers)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::VSSetConstantBuffers</unmanaged-short>	
                public override void SetConstantBuffers(int startSlot, int numBuffers, SharpDX.ComArray<SharpDX.Direct3D10.Buffer> constantBuffersOut) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numBuffers, (void*)((constantBuffersOut == null)?IntPtr.Zero:constantBuffersOut.NativePointer),((void**)(*(void**)_nativePointer))[3]);		
                    }
                }
                
                /// <summary>	
                /// <p>Set the constant buffers used by the vertex shader pipeline stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numBuffers">No documentation.</param>	
                /// <param name="constantBuffersOut">No documentation.</param>	
                /// <remarks>	
                /// <p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::VSSetConstantBuffers']/*"/>	
                /// <msdn-id>bb173626</msdn-id>	
                /// <unmanaged>void ID3D10Device::VSSetConstantBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[In, Buffer, Optional] const ID3D10Buffer** ppConstantBuffers)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::VSSetConstantBuffers</unmanaged-short>	
                private void SetConstantBuffers(int startSlot, int numBuffers, System.IntPtr constantBuffersOut) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numBuffers, (void*)constantBuffersOut,((void**)(*(void**)_nativePointer))[3]);		
                    }
                }
                
                /// <summary>	
                /// <p>Set a vertex shader to the device.</p>	
                /// </summary>	
                /// <param name="vertexShaderRef"><dd>  <p>Pointer to a vertex shader (see <strong><see cref="SharpDX.Direct3D10.VertexShader"/></strong>). Passing in <strong><c>null</c></strong> disables the shader for this pipeline stage.</p> </dd></param>	
                /// <remarks>	
                /// <p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::VSSetShader']/*"/>	
                /// <msdn-id>bb173628</msdn-id>	
                /// <unmanaged>void ID3D10Device::VSSetShader([In, Optional] ID3D10VertexShader* pVertexShader)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::VSSetShader</unmanaged-short>	
                public void Set(SharpDX.Direct3D10.VertexShader vertexShaderRef) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, (void*)((vertexShaderRef == null)?IntPtr.Zero:vertexShaderRef.NativePointer),((void**)(*(void**)_nativePointer))[7]);		
                    }
                }
                
                /// <summary>	
                /// <p>Bind an array of shader resources to the vertex shader stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numViews">No documentation.</param>	
                /// <param name="shaderResourceViewsOut">No documentation.</param>	
                /// <remarks>	
                /// <p>If you bind a subresource as an input and an output, this API will fill the destination shader resource slot with <strong><c>null</c></strong>. The debug layer (when active) will alert you if this is true.</p><p>For information about creating shader-resource views, see <strong><see cref="SharpDX.Direct3D10.Device.CreateShaderResourceView"/></strong>.</p><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::VSSetShaderResources']/*"/>	
                /// <msdn-id>bb173629</msdn-id>	
                /// <unmanaged>void ID3D10Device::VSSetShaderResources([In] unsigned int StartSlot,[In] unsigned int NumViews,[In, Buffer, Optional] const ID3D10ShaderResourceView** ppShaderResourceViews)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::VSSetShaderResources</unmanaged-short>	
                public override void SetShaderResources(int startSlot, int numViews, SharpDX.Direct3D10.ShaderResourceView[] shaderResourceViewsOut) {
                    unsafe {
                        IntPtr* shaderResourceViewsOut_ = (IntPtr*)0;
                        if ( shaderResourceViewsOut != null ) {
                            IntPtr* shaderResourceViewsOut__ = stackalloc IntPtr[shaderResourceViewsOut.Length];
                            shaderResourceViewsOut_ = shaderResourceViewsOut__;
                            for (int i = 0; i < shaderResourceViewsOut.Length; i++)                        
                                shaderResourceViewsOut_[i] =  (shaderResourceViewsOut[i] == null)? IntPtr.Zero : shaderResourceViewsOut[i].NativePointer;
                        }
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numViews, shaderResourceViewsOut_,((void**)(*(void**)_nativePointer))[19]);		
                    }
                }
                
                /// <summary>	
                /// <p>Bind an array of shader resources to the vertex shader stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numViews">No documentation.</param>	
                /// <param name="shaderResourceViewsOut">No documentation.</param>	
                /// <remarks>	
                /// <p>If you bind a subresource as an input and an output, this API will fill the destination shader resource slot with <strong><c>null</c></strong>. The debug layer (when active) will alert you if this is true.</p><p>For information about creating shader-resource views, see <strong><see cref="SharpDX.Direct3D10.Device.CreateShaderResourceView"/></strong>.</p><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::VSSetShaderResources']/*"/>	
                /// <msdn-id>bb173629</msdn-id>	
                /// <unmanaged>void ID3D10Device::VSSetShaderResources([In] unsigned int StartSlot,[In] unsigned int NumViews,[In, Buffer, Optional] const ID3D10ShaderResourceView** ppShaderResourceViews)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::VSSetShaderResources</unmanaged-short>	
                public override void SetShaderResources(int startSlot, int numViews, SharpDX.ComArray<SharpDX.Direct3D10.ShaderResourceView> shaderResourceViewsOut) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numViews, (void*)((shaderResourceViewsOut == null)?IntPtr.Zero:shaderResourceViewsOut.NativePointer),((void**)(*(void**)_nativePointer))[19]);		
                    }
                }
                
                /// <summary>	
                /// <p>Bind an array of shader resources to the vertex shader stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numViews">No documentation.</param>	
                /// <param name="shaderResourceViewsOut">No documentation.</param>	
                /// <remarks>	
                /// <p>If you bind a subresource as an input and an output, this API will fill the destination shader resource slot with <strong><c>null</c></strong>. The debug layer (when active) will alert you if this is true.</p><p>For information about creating shader-resource views, see <strong><see cref="SharpDX.Direct3D10.Device.CreateShaderResourceView"/></strong>.</p><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::VSSetShaderResources']/*"/>	
                /// <msdn-id>bb173629</msdn-id>	
                /// <unmanaged>void ID3D10Device::VSSetShaderResources([In] unsigned int StartSlot,[In] unsigned int NumViews,[In, Buffer, Optional] const ID3D10ShaderResourceView** ppShaderResourceViews)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::VSSetShaderResources</unmanaged-short>	
                private void SetShaderResources(int startSlot, int numViews, System.IntPtr shaderResourceViewsOut) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numViews, (void*)shaderResourceViewsOut,((void**)(*(void**)_nativePointer))[19]);		
                    }
                }
                
                /// <summary>	
                /// <p>Set an array of sampler states to the vertex shader pipeline stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numSamplers">No documentation.</param>	
                /// <param name="samplersOut">No documentation.</param>	
                /// <remarks>	
                /// <p>Any sampler may be set to <strong><c>null</c></strong>; this invokes the default state, which is defined to be the following.</p><pre> //Default sampler state:	
                /// <see cref="SharpDX.Direct3D10.SamplerStateDescription"/> SamplerDesc;	
                /// SamplerDesc.Filter = <see cref="SharpDX.Direct3D10.Filter.MinMagMipLinear"/>;	
                /// SamplerDesc.AddressU = <see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/>;	
                /// SamplerDesc.AddressV = <see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/>;	
                /// SamplerDesc.AddressW = <see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/>;	
                /// SamplerDesc.MipLODBias = 0;	
                /// SamplerDesc.MaxAnisotropy = 1;	
                /// SamplerDesc.ComparisonFunc = <see cref="SharpDX.Direct3D10.Comparison.Never"/>;	
                /// SamplerDesc.BorderColor[0] = 1.0f;	
                /// SamplerDesc.BorderColor[1] = 1.0f;	
                /// SamplerDesc.BorderColor[2] = 1.0f;	
                /// SamplerDesc.BorderColor[3] = 1.0f;	
                /// SamplerDesc.MinLOD = -FLT_MAX;	
                /// SamplerDesc.MaxLOD = FLT_MAX; </pre><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::VSSetSamplers']/*"/>	
                /// <msdn-id>bb173627</msdn-id>	
                /// <unmanaged>void ID3D10Device::VSSetSamplers([In] unsigned int StartSlot,[In] unsigned int NumSamplers,[In, Buffer, Optional] const ID3D10SamplerState** ppSamplers)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::VSSetSamplers</unmanaged-short>	
                public override void SetSamplers(int startSlot, int numSamplers, SharpDX.Direct3D10.SamplerState[] samplersOut) {
                    unsafe {
                        IntPtr* samplersOut_ = (IntPtr*)0;
                        if ( samplersOut != null ) {
                            IntPtr* samplersOut__ = stackalloc IntPtr[samplersOut.Length];
                            samplersOut_ = samplersOut__;
                            for (int i = 0; i < samplersOut.Length; i++)                        
                                samplersOut_[i] =  (samplersOut[i] == null)? IntPtr.Zero : samplersOut[i].NativePointer;
                        }
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numSamplers, samplersOut_,((void**)(*(void**)_nativePointer))[20]);		
                    }
                }
                
                /// <summary>	
                /// <p>Set an array of sampler states to the vertex shader pipeline stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numSamplers">No documentation.</param>	
                /// <param name="samplersOut">No documentation.</param>	
                /// <remarks>	
                /// <p>Any sampler may be set to <strong><c>null</c></strong>; this invokes the default state, which is defined to be the following.</p><pre> //Default sampler state:	
                /// <see cref="SharpDX.Direct3D10.SamplerStateDescription"/> SamplerDesc;	
                /// SamplerDesc.Filter = <see cref="SharpDX.Direct3D10.Filter.MinMagMipLinear"/>;	
                /// SamplerDesc.AddressU = <see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/>;	
                /// SamplerDesc.AddressV = <see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/>;	
                /// SamplerDesc.AddressW = <see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/>;	
                /// SamplerDesc.MipLODBias = 0;	
                /// SamplerDesc.MaxAnisotropy = 1;	
                /// SamplerDesc.ComparisonFunc = <see cref="SharpDX.Direct3D10.Comparison.Never"/>;	
                /// SamplerDesc.BorderColor[0] = 1.0f;	
                /// SamplerDesc.BorderColor[1] = 1.0f;	
                /// SamplerDesc.BorderColor[2] = 1.0f;	
                /// SamplerDesc.BorderColor[3] = 1.0f;	
                /// SamplerDesc.MinLOD = -FLT_MAX;	
                /// SamplerDesc.MaxLOD = FLT_MAX; </pre><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::VSSetSamplers']/*"/>	
                /// <msdn-id>bb173627</msdn-id>	
                /// <unmanaged>void ID3D10Device::VSSetSamplers([In] unsigned int StartSlot,[In] unsigned int NumSamplers,[In, Buffer, Optional] const ID3D10SamplerState** ppSamplers)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::VSSetSamplers</unmanaged-short>	
                public override void SetSamplers(int startSlot, int numSamplers, SharpDX.ComArray<SharpDX.Direct3D10.SamplerState> samplersOut) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numSamplers, (void*)((samplersOut == null)?IntPtr.Zero:samplersOut.NativePointer),((void**)(*(void**)_nativePointer))[20]);		
                    }
                }
                
                /// <summary>	
                /// <p>Set an array of sampler states to the vertex shader pipeline stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numSamplers">No documentation.</param>	
                /// <param name="samplersOut">No documentation.</param>	
                /// <remarks>	
                /// <p>Any sampler may be set to <strong><c>null</c></strong>; this invokes the default state, which is defined to be the following.</p><pre> //Default sampler state:	
                /// <see cref="SharpDX.Direct3D10.SamplerStateDescription"/> SamplerDesc;	
                /// SamplerDesc.Filter = <see cref="SharpDX.Direct3D10.Filter.MinMagMipLinear"/>;	
                /// SamplerDesc.AddressU = <see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/>;	
                /// SamplerDesc.AddressV = <see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/>;	
                /// SamplerDesc.AddressW = <see cref="SharpDX.Direct3D10.TextureAddressMode.Clamp"/>;	
                /// SamplerDesc.MipLODBias = 0;	
                /// SamplerDesc.MaxAnisotropy = 1;	
                /// SamplerDesc.ComparisonFunc = <see cref="SharpDX.Direct3D10.Comparison.Never"/>;	
                /// SamplerDesc.BorderColor[0] = 1.0f;	
                /// SamplerDesc.BorderColor[1] = 1.0f;	
                /// SamplerDesc.BorderColor[2] = 1.0f;	
                /// SamplerDesc.BorderColor[3] = 1.0f;	
                /// SamplerDesc.MinLOD = -FLT_MAX;	
                /// SamplerDesc.MaxLOD = FLT_MAX; </pre><p>The method will not hold a reference to the interfaces passed in. For that reason, applications should be careful not to release an interface currently in use by the device.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::VSSetSamplers']/*"/>	
                /// <msdn-id>bb173627</msdn-id>	
                /// <unmanaged>void ID3D10Device::VSSetSamplers([In] unsigned int StartSlot,[In] unsigned int NumSamplers,[In, Buffer, Optional] const ID3D10SamplerState** ppSamplers)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::VSSetSamplers</unmanaged-short>	
                private void SetSamplers(int startSlot, int numSamplers, System.IntPtr samplersOut) {
                    unsafe {
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numSamplers, (void*)samplersOut,((void**)(*(void**)_nativePointer))[20]);		
                    }
                }
                
                /// <summary>	
                /// <p>Get the constant buffers used by the vertex shader pipeline stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numBuffers">No documentation.</param>	
                /// <param name="constantBuffersOut">No documentation.</param>	
                /// <remarks>	
                /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::VSGetConstantBuffers']/*"/>	
                /// <msdn-id>bb173622</msdn-id>	
                /// <unmanaged>void ID3D10Device::VSGetConstantBuffers([In] unsigned int StartSlot,[In] unsigned int NumBuffers,[Out, Buffer, Optional] ID3D10Buffer** ppConstantBuffers)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::VSGetConstantBuffers</unmanaged-short>	
                internal override void GetConstantBuffers(int startSlot, int numBuffers, SharpDX.Direct3D10.Buffer[] constantBuffersOut) {
                    unsafe {
                        IntPtr* constantBuffersOut_ = stackalloc IntPtr[constantBuffersOut == null ? 0 : constantBuffersOut.Length];
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numBuffers, constantBuffersOut==null?(void*)0:constantBuffersOut_,((void**)(*(void**)_nativePointer))[39]);		
                        if (constantBuffersOut != null)
                        for (int i = 0; i < constantBuffersOut.Length; i++)
                            constantBuffersOut[i] = (constantBuffersOut_[i] == IntPtr.Zero)?null:new SharpDX.Direct3D10.Buffer(constantBuffersOut_[i]);	
                    }
                }
                
                /// <summary>	
                /// <p>Get the vertex shader currently set on the device.</p>	
                /// </summary>	
                /// <param name="vertexShaderOut"><dd>  <p>Address of a reference to a vertex shader (see <strong><see cref="SharpDX.Direct3D10.VertexShader"/></strong>) to be returned by the method.</p> </dd></param>	
                /// <remarks>	
                /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::VSGetShader']/*"/>	
                /// <msdn-id>bb173624</msdn-id>	
                /// <unmanaged>void ID3D10Device::VSGetShader([Out] ID3D10VertexShader** ppVertexShader)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::VSGetShader</unmanaged-short>	
                public void Get(out SharpDX.Direct3D10.VertexShader vertexShaderOut) {
                    unsafe {
                        IntPtr vertexShaderOut_ = IntPtr.Zero;
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, &vertexShaderOut_,((void**)(*(void**)_nativePointer))[43]);		
                        vertexShaderOut= (vertexShaderOut_ == IntPtr.Zero)?null:new SharpDX.Direct3D10.VertexShader(vertexShaderOut_);	
                    }
                }
                
                /// <summary>	
                /// <p>Get the vertex shader resources.</p>	
                /// </summary>	
                /// <param name="startSlot"><dd>  <p>Index into the device's zero-based array to begin getting shader resources from.</p> </dd></param>	
                /// <param name="numViews"><dd>  <p>The number of resources to get from the device. Up to a maximum of 128 slots are available for shader resources.</p> </dd></param>	
                /// <param name="shaderResourceViewsOut"><dd>  <p>Array of <strong>shader resource view</strong> interfaces to be returned by the device.</p> </dd></param>	
                /// <remarks>	
                /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::VSGetShaderResources']/*"/>	
                /// <msdn-id>bb173625</msdn-id>	
                /// <unmanaged>void ID3D10Device::VSGetShaderResources([In] unsigned int StartSlot,[In] unsigned int NumViews,[Out, Buffer, Optional] ID3D10ShaderResourceView** ppShaderResourceViews)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::VSGetShaderResources</unmanaged-short>	
                internal override void GetShaderResources(int startSlot, int numViews, SharpDX.Direct3D10.ShaderResourceView[] shaderResourceViewsOut) {
                    unsafe {
                        IntPtr* shaderResourceViewsOut_ = stackalloc IntPtr[shaderResourceViewsOut == null ? 0 : shaderResourceViewsOut.Length];
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numViews, shaderResourceViewsOut==null?(void*)0:shaderResourceViewsOut_,((void**)(*(void**)_nativePointer))[51]);		
                        if (shaderResourceViewsOut != null)
                        for (int i = 0; i < shaderResourceViewsOut.Length; i++)
                            shaderResourceViewsOut[i] = (shaderResourceViewsOut_[i] == IntPtr.Zero)?null:new SharpDX.Direct3D10.ShaderResourceView(shaderResourceViewsOut_[i]);	
                    }
                }
                
                /// <summary>	
                /// <p>Get an array of sampler states from the vertex shader pipeline stage.</p>	
                /// </summary>	
                /// <param name="startSlot">No documentation.</param>	
                /// <param name="numSamplers">No documentation.</param>	
                /// <param name="samplersOut">No documentation.</param>	
                /// <remarks>	
                /// <p>Any returned interfaces will have their reference count incremented by one. Applications should call IUnknown::Release on the returned interfaces when they are no longer needed to avoid memory leaks.</p>	
                /// </remarks>	
                /// <include file='.\..\Documentation\CodeComments.xml' path="/comments/comment[@id='ID3D10Device::VSGetSamplers']/*"/>	
                /// <msdn-id>bb173623</msdn-id>	
                /// <unmanaged>void ID3D10Device::VSGetSamplers([In] unsigned int StartSlot,[In] unsigned int NumSamplers,[Out, Buffer, Optional] ID3D10SamplerState** ppSamplers)</unmanaged>	
                /// <unmanaged-short>ID3D10Device::VSGetSamplers</unmanaged-short>	
                internal override void GetSamplers(int startSlot, int numSamplers, SharpDX.Direct3D10.SamplerState[] samplersOut) {
                    unsafe {
                        IntPtr* samplersOut_ = stackalloc IntPtr[samplersOut == null ? 0 : samplersOut.Length];
                        SharpDX.Direct3D10.LocalInterop.Callivoid(_nativePointer, startSlot, numSamplers, samplersOut==null?(void*)0:samplersOut_,((void**)(*(void**)_nativePointer))[52]);		
                        if (samplersOut != null)
                        for (int i = 0; i < samplersOut.Length; i++)
                            samplersOut[i] = (samplersOut_[i] == IntPtr.Zero)?null:new SharpDX.Direct3D10.SamplerState(samplersOut_[i]);	
                    }
                }
            }
        }
